<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Life RPG</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#f8fafc; color:#0f172a; -webkit-tap-highlight-color:transparent; }
    .tab{display:none;}
    .tab.active{display:block;}
    .btn{border-radius:.75rem; padding:.5rem 1rem; border:1px solid #cbd5e1; background:#fff;}
    .input{width:100%; border-radius:.75rem; border:1px solid #cbd5e1; padding:.5rem .75rem; background:#fff;}
    .card{border:1px solid #e2e8f0; background:#fff; border-radius:1rem; padding:1rem;}
  </style>
</head>
<body>
  <div class="max-w-xl mx-auto min-h-screen flex flex-col">
    <!-- Header -->
    <header class="px-4 pt-6 pb-3 sticky top-0 bg-white/80 backdrop-blur z-10 border-b">
      <div class="flex items-center justify-between">
        <h1 class="text-2xl font-bold flex items-center gap-2">üéÆ Life RPG</h1>
        <span class="text-sm text-slate-500">Basis ¬∑ Migration aktiv</span>
      </div>
    </header>

    <!-- Main -->
    <main class="flex-1 px-4 pb-28 space-y-4">
      <!-- Dashboard -->
      <section id="tab-dashboard" class="tab active space-y-3">
        <div class="grid grid-cols-2 gap-3">
          <div class="card"><div class="text-xs text-slate-500">Gesamtpunkte</div><div id="totalPoints" class="text-3xl font-semibold">0</div></div>
          <div class="card"><div class="text-xs text-slate-500">Level</div><div id="currentLevel" class="text-3xl font-semibold">1</div></div>
          <div class="card"><div class="text-xs text-slate-500">Sparstand (‚Ç¨)</div><div id="savingsTotal" class="text-3xl font-semibold">0,00</div></div>
          <div class="card"><div class="text-xs text-slate-500">Streak (Tage)</div><div id="streakDays" class="text-3xl font-semibold">0</div></div>
        </div>

        <div class="card">
          <div class="font-semibold">Level-Fortschritt</div>
          <div class="w-full bg-slate-200 h-3 rounded mt-2">
            <div id="levelBar" class="h-3 rounded bg-blue-500" style="width:0%"></div>
          </div>
          <div id="levelText" class="text-xs text-slate-600 mt-1"></div>
        </div>

        <div class="card">
          <div class="font-semibold mb-2">Schnell loggen (frei)</div>
          <div class="grid grid-cols-1 gap-2">
            <input id="quickQuest" class="input" placeholder="z. B. 10 Liegest√ºtze" />
            <input id="quickPoints" type="number" class="input" placeholder="Punkte (z. B. 10)" />
            <button id="btnQuickAdd" class="btn bg-blue-600 text-white border-blue-600">+ Eintragen</button>
          </div>
          <div class="text-xs text-slate-500 mt-2">Nur zum Test. Katalog folgt separat.</div>
        </div>
      </section>

      <!-- Log -->
      <section id="tab-log" class="tab space-y-3">
        <div class="card space-y-2">
          <div class="font-semibold">Neuer Eintrag</div>
          <input type="date" id="logDate" class="input" />
          <input type="text" id="logQuest" class="input" placeholder="Questname" />
          <input type="number" id="logPoints" class="input" placeholder="Punkte" />
          <button id="btnAddEntry" class="btn bg-blue-600 text-white border-blue-600">Eintragen</button>
        </div>
        <div class="card">
          <div class="font-semibold mb-2">Eintr√§ge</div>
          <div id="logList" class="divide-y"></div>
        </div>
      </section>

      <!-- Catalog (Platzhalter, kommt in sp√§teren Schritten) -->
      <section id="tab-catalog" class="tab space-y-3">
        <div class="card">
          <div class="font-semibold">Katalog</div>
          <div class="text-sm text-slate-500">Wird im n√§chsten Schritt erg√§nzt. Bestehende Daten bleiben erhalten.</div>
        </div>
      </section>

      <!-- Settings -->
      <section id="tab-settings" class="tab space-y-3">
        <div class="card space-y-2">
          <div class="font-semibold">Einstellungen</div>
          <label class="text-sm">‚Ç¨ pro Punkt
            <input id="sEuro" type="number" step="0.01" class="input" />
          </label>
          <label class="text-sm">Level: Basis-Inkrement
            <input id="sBase" type="number" class="input" />
          </label>
          <label class="text-sm">Level: Wachstum (z. B. 0.10 = +10%)
            <input id="sGrowth" type="number" step="0.01" class="input" />
          </label>
          <label class="text-sm">Tagesziel (Anzahl Eintr√§ge)
            <input id="sDailyGoal" type="number" class="input" />
          </label>
          <div class="flex gap-2 pt-1">
            <button id="btnExport" class="btn">Export</button>
            <button id="btnImport" class="btn">Import</button>
            <input type="file" id="fileImport" class="hidden" accept="application/json" />
            <button id="btnWipe" class="btn bg-red-600 text-white border-red-600">Alles l√∂schen</button>
          </div>
        </div>
        <div class="text-xs text-slate-500 px-1">‚öôÔ∏è Migration ist aktiv ‚Äì alte Daten werden automatisch erg√§nzt, nichts geht verloren.</div>
      </section>

      <!-- Missions (Platzhalter) -->
      <section id="tab-missions" class="tab space-y-3">
        <div class="card">
          <div class="font-semibold">Missionen</div>
          <div class="text-sm text-slate-500">Kommt nach dem Katalog: mehrstufige Aufgabenketten & Freischaltung.</div>
        </div>
      </section>

      <!-- Chat (Platzhalter) -->
      <section id="tab-chat" class="tab space-y-3">
        <div class="card">
          <div class="font-semibold">Chat</div>
          <div class="text-sm text-slate-500">Wird sp√§ter aktiviert (Parsing, Vorschl√§ge, Buttons).</div>
        </div>
      </section>
    </main>

    <!-- Bottom Nav -->
    <nav class="fixed bottom-0 left-0 right-0 bg-white border-t">
      <div class="max-w-xl mx-auto grid grid-cols-5 text-center">
        <button data-tab="dashboard" class="py-3 text-blue-600">Dashboard</button>
        <button data-tab="log" class="py-3">Log</button>
        <button data-tab="catalog" class="py-3">Katalog</button>
        <button data-tab="missions" class="py-3">Missionen</button>
        <button data-tab="settings" class="py-3">Einstellungen</button>
      </div>
    </nav>
  </div>

  <script>
  // =========================================================
  // Life RPG ‚Äî Basis + Migration (Schritt 1)
  // Erweiterungen f√ºgst du IMMER oberhalb des Markers ein:
  // =======>>>>>  // [EXTENSION-POINT] F√úR K√úNFTIGE TEILE  <<<<<=======
  // =========================================================

  // ---------- Storage & Migration ----------
  const SKEY = "lifeRPG_p1"; // Beibehalten, damit bestehende Daten geladen werden

  const defaultState = {
    settings: {
      euro: 0.10,          // ‚Ç¨ pro Punkt
      base: 100,           // Level Basis-Inkrement
      growth: 0.10,        // Level Wachstum pro Stufe
      dailyGoal: 3,        // Tagesziel = mind. X Eintr√§ge/Tag
      streakPerDay: 0.02,  // +2% pro aktiven Tag
      streakMax: 0.20      // max +20%
    },
    catalog: [
      // nur als Start (falls leer) ‚Äì wird nicht doppelt, Migration √ºberschreibt NICHT vorhandene
      { name: "Sport", points: 20, category: "Gesundheit", boss: false },
      { name: "Kein Essen bestellt", points: 10, category: "Gesundheit", boss: false },
      { name: "Aufr√§umen", points: 5, category: "Ordnung", boss: false }
    ],
    rewards: [],
    missions: [],   // wird sp√§ter benutzt
    log: []         // {date, quest, points, base?}
  };

  function deepClone(v){ return JSON.parse(JSON.stringify(v)); }

  function migrate(stIn){
    let st = stIn && typeof stIn === "object" ? deepClone(stIn) : deepClone(defaultState);

    // Settings: fehlende Felder erg√§nzen
    st.settings = Object.assign({}, defaultState.settings, st.settings || {});

    // Arrays absichern
    if (!Array.isArray(st.catalog)) st.catalog = deepClone(defaultState.catalog);
    if (!Array.isArray(st.rewards)) st.rewards = [];
    if (!Array.isArray(st.missions)) st.missions = [];
    if (!Array.isArray(st.log)) st.log = [];

    // Katalogeintr√§ge vereinheitlichen
    st.catalog = st.catalog.map(q => ({
      name: String(q.name || "Unbenannte Quest"),
      points: Number(q.points || 0),
      category: q.category || "Allgemein",
      boss: !!q.boss
    }));

    // Logeintr√§ge vereinheitlichen + reparieren
    st.log = st.log.map(e => {
      const date = (e.date && typeof e.date === "string") ? e.date.slice(0,10) : new Date().toISOString().slice(0,10);
      const quest = String(e.quest || "Unbekannt");
      const points = Number(isFinite(e.points) ? e.points : 0);
      const base = Number(isFinite(e.base) ? e.base : points); // falls alt ohne base
      return { date, quest, points, base };
    });

    return st;
  }

  function load(){
    try{
      const raw = localStorage.getItem(SKEY);
      if(!raw){ 
        const initial = deepClone(defaultState);
        localStorage.setItem(SKEY, JSON.stringify(initial));
        return initial;
      }
      const parsed = JSON.parse(raw);
      return migrate(parsed);
    }catch(e){
      console.warn("Load/Migrate fallback:", e);
      const fallback = deepClone(defaultState);
      localStorage.setItem(SKEY, JSON.stringify(fallback));
      return fallback;
    }
  }

  function save(){
    localStorage.setItem(SKEY, JSON.stringify(state));
  }

  let state = load();

  // ---------- Helpers ----------
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const todayISO = () => new Date().toISOString().slice(0,10);
  const fmt = n => new Intl.NumberFormat("de-DE").format(n);
  const fmtE = n => new Intl.NumberFormat("de-DE",{minimumFractionDigits:2, maximumFractionDigits:2}).format(n);

  function streakDays(){
    // Anzahl an aufeinanderfolgenden Tagen mit >=1 Eintrag (bis inkl. heute)
    const set = new Set(state.log.map(e=>e.date));
    let s = 0; let cursor = todayISO();
    while(set.has(cursor)){
      s++;
      const d = new Date(cursor); d.setDate(d.getDate()-1);
      cursor = d.toISOString().slice(0,10);
    }
    return s;
  }

  function computePoints(base, dateISO){
    // Multiplikator durch Streak
    const s = streakDays();
    const mult = Math.min(state.settings.streakMax, Math.max(0, state.settings.streakPerDay * Math.max(0, s-1)));
    return Math.round(Number(base||0) * (1 + mult));
  }

  function progressiveThresholds(maxLevel, baseInc, growth){
    const thr=[0]; // Level1 ab 0
    for(let lv=2; lv<=maxLevel; lv++){
      const inc = Math.round(baseInc * Math.pow(1+growth, (lv-2))); // Stufe f√ºr √úbergang lv-1 -> lv
      thr[lv-1] = thr[lv-2] + inc;
    }
    return thr; // thr[i] = Mindestpunkte f√ºr Level i+1
  }

  function levelForPoints(totalPts){
    const base = Number(state.settings.base||100);
    const growth = Number(state.settings.growth||0.10);
    const thr = progressiveThresholds(100, base, growth); // bis Level 100
    let lvl = 1;
    for(let i=0;i<thr.length;i++){
      if(totalPts >= thr[i]) lvl = i+1; else break;
    }
    return { lvl, thr };
  }

  function totals(){
    const totalPts = state.log.reduce((s,e)=> s + Number(e.points||0), 0);
    const euro = Number(state.settings.euro||0);
    return { totalPts, savings: totalPts * euro };
  }

  // ---------- Render ----------
  function renderDashboard(){
    const { totalPts, savings } = totals();
    const { lvl, thr } = levelForPoints(totalPts);

    $("#totalPoints").textContent = fmt(totalPts);
    $("#savingsTotal").textContent = fmtE(savings);
    $("#currentLevel").textContent = lvl;
    $("#streakDays").textContent = fmt(streakDays());

    // Progressbar
    const prevThr = thr[lvl-1] || 0;
    const nextThr = thr[lvl] ?? (thr[thr.length-1] + (thr[thr.length-1]-thr[thr.length-2] || 100));
    const have = Math.max(0, totalPts - prevThr);
    const span = Math.max(1, nextThr - prevThr);
    const pct = Math.min(100, Math.round(100*have/span));
    $("#levelBar").style.width = pct + "%";
    $("#levelText").textContent = `Noch ${fmt(Math.max(0, nextThr-totalPts))} Punkte bis Level ${lvl+1}`;
  }

  function renderLog(){
    $("#logDate").value = todayISO();
    const rows = [...state.log].sort((a,b)=> new Date(b.date) - new Date(a.date));
    $("#logList").innerHTML = rows.map(e=>`
      <div class="py-2 flex items-start justify-between">
        <div class="text-sm">
          <div class="font-medium">${e.quest}</div>
          <div class="text-xs text-slate-500">${e.date}</div>
        </div>
        <div class="text-right text-sm font-semibold ${e.points<0?'text-red-600':''}">${e.points<0?'':'+'}${e.points}</div>
      </div>
    `).join("") || `<div class="py-6 text-center text-slate-400">Noch keine Eintr√§ge.</div>`;
  }

  function renderSettings(){
    $("#sEuro").value = state.settings.euro;
    $("#sBase").value = state.settings.base;
    $("#sGrowth").value = state.settings.growth;
    $("#sDailyGoal").value = state.settings.dailyGoal;
  }

  function renderAll(){
    renderDashboard();
    renderLog();
    renderSettings();
  }

  // ---------- Actions ----------
  function addLogEntry(dateISO, questName, basePoints){
    if(!questName) return;
    const pts = computePoints(Number(basePoints||0), dateISO);
    state.log.push({ date: dateISO, quest: questName, points: pts, base: Number(basePoints||pts) });
    save();
    renderAll();
  }

  // Buttons / Events
  $("#btnQuickAdd").addEventListener("click", ()=>{
    const q = $("#quickQuest").value.trim();
    const p = Number($("#quickPoints").value||0);
    if(!q || !p) return;
    addLogEntry(todayISO(), q, p);
    $("#quickQuest").value = "";
    $("#quickPoints").value = "";
  });

  $("#btnAddEntry").addEventListener("click", ()=>{
    const d = $("#logDate").value || todayISO();
    const q = $("#logQuest").value.trim();
    const p = Number($("#logPoints").value||0);
    if(!q || !p) return;
    addLogEntry(d, q, p);
    $("#logQuest").value = ""; $("#logPoints").value = "";
  });

  // Settings
  $("#sEuro").addEventListener("change", ()=>{ state.settings.euro = Number($("#sEuro").value||0); save(); renderAll(); });
  $("#sBase").addEventListener("change", ()=>{ state.settings.base = Number($("#sBase").value||100); save(); renderAll(); });
  $("#sGrowth").addEventListener("change", ()=>{ state.settings.growth = Number($("#sGrowth").value||0.10); save(); renderAll(); });
  $("#sDailyGoal").addEventListener("change", ()=>{ state.settings.dailyGoal = Number($("#sDailyGoal").value||1); save(); renderAll(); });

  // Export / Import / Wipe
  $("#btnExport").addEventListener("click", ()=>{
    const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `life_rpg_backup_${Date.now()}.json`;
    a.click();
  });
  $("#btnImport").addEventListener("click", ()=> $("#fileImport").click() );
  $("#fileImport").addEventListener("change", (e)=>{
    const f = e.target.files?.[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const incoming = JSON.parse(reader.result);
        state = migrate(incoming);
        save(); renderAll();
        alert("Import OK");
      }catch(err){
        alert("Import fehlgeschlagen.");
      }
    };
    reader.readAsText(f);
    e.target.value = "";
  });
  $("#btnWipe").addEventListener("click", ()=>{
    if(confirm("Wirklich ALLE Daten l√∂schen?")){
      localStorage.removeItem(SKEY);
      state = load(); // l√§dt default (inkl. Migration-Struktur)
      renderAll();
    }
  });

  // Bottom Nav
  $$(".grid [data-tab]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const tab = btn.getAttribute("data-tab");
      $$(".tab").forEach(t=> t.classList.remove("active"));
      $("#tab-"+tab).classList.add("active");
      $$(".grid [data-tab]").forEach(b=> b.classList.remove("text-blue-600"));
      btn.classList.add("text-blue-600");
      window.scrollTo({top:0, behavior:"smooth"});
    });
  });

  // Initial render
  renderAll();
<!-- ===== Part 2: Catalog + Kategorien + Quest-Level + Tages-Malus ===== -->
<script>
/* -------------------- Daten-Erweiterung & Migration -------------------- */
state.questProfiles = state.questProfiles || {}; // { [questName]: {xp, level, lastDoneDate, lastCheckDate} }

/** Aus bestehenden Logs Quest-Profile aufbauen (nur wenn leer) */
function buildQuestProfilesFromLogIfEmpty(){
  if(Object.keys(state.questProfiles).length>0) return;
  const today = todayISO();
  // xp = Summe der Punkte pro Quest (historisch), Level daraus berechnen
  const agg = {};
  state.log.forEach(e=>{
    if(!agg[e.quest]) agg[e.quest]=0;
    agg[e.quest]+=Number(e.points||0);
  });
  Object.entries(agg).forEach(([q,xp])=>{
    const last = state.log.filter(e=>e.quest===q).sort((a,b)=>a.date.localeCompare(b.date)).slice(-1)[0];
    state.questProfiles[q] = {
      xp: Math.max(0, Math.round(xp)),
      level: questLevelFromXp(Math.max(0, Math.round(xp))).level,
      lastDoneDate: last ? last.date : null,
      lastCheckDate: today
    };
  });
  save();
}

/** Sicherstellen, dass es ein Profil f√ºr die Quest gibt */
function ensureQuestProfile(qName){
  if(!state.questProfiles[qName]){
    state.questProfiles[qName] = {
      xp: 0,
      level: 1,
      lastDoneDate: null,
      lastCheckDate: todayISO()
    };
  }
  return state.questProfiles[qName];
}

/** Level-Kurven f√ºr einzelne Quests:
 * Lvl 1 bei 100 XP, Lvl 2 +110, Lvl 3 +120, ... unendlich (je Stufe +10 mehr)
 */
function questLevelFromXp(xp){
  let level = 0;
  let need = 100; // f√ºr Level 1
  let spent = 0;
  while(xp >= need){
    xp -= need;
    spent += need;
    level++;
    need += 10;
  }
  // level = Anzahl voll erreichter Stufen (Level 0 => noch nichts; wir zeigen als min. 1)
  const shownLevel = Math.max(1, level);
  const into = xp;             // XP innerhalb der aktuellen Stufe
  const nextNeed = need;       // XP n√∂tig f√ºr den n√§chsten Level-Up (ab jetzt)
  return { level: shownLevel, into, nextNeed, totalSpent: spent };
}

/** Profil nach einem Log-Eintrag aktualisieren */
function updateQuestProfileAfterLog(qName, gainedPts, dateISO){
  const p = ensureQuestProfile(qName);
  p.xp = Math.max(0, Math.round((p.xp||0) + Number(gainedPts||0)));
  const res = questLevelFromXp(p.xp);
  p.level = res.level;
  p.lastDoneDate = dateISO;
  // lastCheckDate bleibt wie gesetzt (Tages-Malus verarbeitet separat)
}

/** T√§glicher Malus pro Quest:
 * Wenn ein Tag seit lastCheckDate vergangen ist und die Quest an diesem Tag NICHT erledigt wurde,
 * werden 15 XP abgezogen. Danach wird lastCheckDate auf heute gesetzt.
 * -> Greift nur ab dem Zeitpunkt, an dem dieses Feature aktiv ist (keine Retro-Strafen).
 */
state.lastPenaltyRun = state.lastPenaltyRun || todayISO();
function runDailyQuestPenalties(){
  const today = todayISO();
  if(state.lastPenaltyRun === today) return; // heute schon erledigt

  // Hilfsfunktion: checkt, ob an einem Datum die Quest geloggt wurde
  function questWasDoneOn(qName, dateISO){
    return state.log.some(e=> e.quest===qName && e.date===dateISO && Number(e.points||0) > 0);
  }

  // Iteriere alle Profile
  Object.entries(state.questProfiles).forEach(([qName, p])=>{
    const start = p.lastCheckDate || today;
    // Wir pr√ºfen Tage zwischen (start) exklusiv bis (gestern) inklusiv
    const startD = new Date(start);
    const endD = new Date(today);
    endD.setDate(endD.getDate()-1);
    if(endD < startD) { p.lastCheckDate = today; return; }

    // Tag f√ºr Tag pr√ºfen
    const cursor = new Date(startD);
    cursor.setDate(cursor.getDate()+1); // n√§chster Tag nach lastCheckDate
    while(cursor <= endD){
      const dISO = cursor.toISOString().slice(0,10);
      if(!questWasDoneOn(qName, dISO)){
        p.xp = Math.max(0, (p.xp||0) - 15); // 15 XP Abzug
      }
      cursor.setDate(cursor.getDate()+1);
    }
    const res = questLevelFromXp(p.xp);
    p.level = res.level;
    p.lastCheckDate = today;
  });

  state.lastPenaltyRun = today;
  save();
}

/* ---------------------------- Catalog / UI ---------------------------- */

/** Eindeutige Kategorien-Liste aus dem Katalog */
function uniqueCategories(){
  const set = new Set(state.catalog.map(q=>q.category||"Allgemein"));
  return Array.from(set).sort((a,b)=> a.localeCompare(b,"de"));
}

/** Kategorie -> Summen (nur positive Punkte aus Logs von Quests, die aktuell dieser Kategorie zugeordnet sind) */
function categoryTotals(){
  const byName = {};
  state.catalog.forEach(q=> byName[q.name]=q.category||"Allgemein");
  const sums = {};
  state.log.forEach(e=>{
    if(Number(e.points||0) <= 0) return; // negative nicht addieren
    const cat = byName[e.quest] || "Allgemein";
    sums[cat] = (sums[cat]||0) + Number(e.points||0);
  });
  return sums; // {cat: sum}
}

/** Katalog rendern: Formular + Kategorien-√úbersicht + Questliste inkl. Levels */
function renderCatalogV2(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;

  // Kategorien-√úbersicht (mit Summen)
  const sums = categoryTotals();
  const cats = uniqueCategories();
  const catListHtml = cats.map(c=>{
    const sum = sums[c] || 0;
    return `<div class="flex items-center justify-between py-1">
      <div class="font-medium">${c}</div>
      <div class="text-sm text-slate-600">+${sum} Punkte</div>
    </div>`;
  }).join("") || `<div class="text-sm text-slate-500">Noch keine Kategorien.</div>`;

  // Formular + Liste
  host.innerHTML = `
    <div class="card space-y-2">
      <div class="font-semibold">Neue Quest</div>
      <input id="qName" class="input" placeholder="Questname (z. B. '10 Liegest√ºtze')" />
      <input id="qPoints" type="number" class="input" placeholder="Punkte (z. B. 10)" />
      <input id="qCategory" class="input" placeholder="Kategorie (z. B. 'Gesundheit')" />
      <label class="inline-flex items-center gap-2 text-sm mt-1">
        <input id="qBoss" type="checkbox" />
        <span>üëë Bossquest</span>
      </label>
      <button id="btnAddQuest" class="btn bg-blue-600 text-white border-blue-600">Zur Liste hinzuf√ºgen</button>
    </div>

    <div class="card">
      <div class="font-semibold mb-2">Kategorien (Summe)</div>
      <div id="catSums">${catListHtml}</div>
    </div>

    <div class="card">
      <div class="font-semibold mb-2">Quests</div>
      <div id="catalogList" class="space-y-2"></div>
    </div>
  `;

  // Liste rendern
  const list = document.getElementById("catalogList");
  const rows = state.catalog
    .slice()
    .sort((a,b)=> a.name.localeCompare(b.name,"de"))
    .map((q,i)=>{
      const p = ensureQuestProfile(q.name);
      const lvl = questLevelFromXp(p.xp||0);
      const progPct = Math.min(100, Math.round(100 * (lvl.into / Math.max(1,lvl.nextNeed))));
      return `
        <div class="border rounded p-2">
          <div class="flex items-start justify-between gap-2">
            <div class="min-w-0">
              <div class="font-medium">${q.boss?'üëë ':''}${q.name}</div>
              <div class="text-xs text-slate-600">Kategorie: 
                <button class="underline text-blue-700" data-edit-cat="${i}">${q.category||'Allgemein'}</button> ¬∑ 
                Punkte: +${q.points}
              </div>
              <div class="mt-1">
                <div class="w-full bg-slate-200 h-2 rounded">
                  <div class="h-2 rounded bg-emerald-500" style="width:${progPct}%"></div>
                </div>
                <div class="text-[11px] text-slate-600 mt-1">Quest-Level: ${lvl.level} ¬∑ ${lvl.into}/${lvl.nextNeed} XP</div>
              </div>
            </div>
            <div class="flex flex-col gap-1 shrink-0">
              <button class="btn text-xs" data-log="${i}">‚ûï Eintragen</button>
              <button class="btn text-xs" data-del="${i}">L√∂schen</button>
            </div>
          </div>
        </div>
      `;
    }).join("") || `<div class="text-sm text-slate-500">Noch keine Quests im Katalog.</div>`;
  list.innerHTML = rows;

  // Events: Add Quest
  document.getElementById("btnAddQuest").addEventListener("click", ()=>{
    const name = document.getElementById("qName").value.trim();
    const points = Number(document.getElementById("qPoints").value||0);
    const category = document.getElementById("qCategory").value.trim() || "Allgemein";
    const boss = document.getElementById("qBoss").checked;
    if(!name || !points) return;

    // Wenn die Quest schon existiert ‚Üí nur aktualisieren
    const existing = state.catalog.find(q=>q.name.toLowerCase()===name.toLowerCase());
    if(existing){
      existing.points = points;
      existing.category = category;
      existing.boss = boss;
    }else{
      state.catalog.push({name, points, category, boss});
    }
    ensureQuestProfile(name);
    save(); renderAll();
    // Formular leeren
    document.getElementById("qName").value="";
    document.getElementById("qPoints").value="";
    document.getElementById("qCategory").value="";
    document.getElementById("qBoss").checked=false;
  });

  // Events: Eintragen / L√∂schen / Kategorie √§ndern
  list.querySelectorAll("[data-log]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const idx = Number(btn.getAttribute("data-log"));
      const q = state.catalog[idx];
      const today = todayISO();
      // Punkte berechnen (mit Streak etc.)
      // Wir √ºberschreiben addLogEntry, um Quest-Profile sicher zu aktualisieren (siehe Patch unten)
      addLogEntry(today, q.name, q.points);
    });
  });

  list.querySelectorAll("[data-del]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const idx = Number(btn.getAttribute("data-del"));
      if(confirm(`'${state.catalog[idx].name}' wirklich l√∂schen?`)){
        state.catalog.splice(idx,1);
        save(); renderAll();
      }
    });
  });

  list.querySelectorAll("[data-edit-cat]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const idx = Number(btn.getAttribute("data-edit-cat"));
      const q = state.catalog[idx];
      const current = q.category || "Allgemein";
      const next = prompt("Neue Kategorie f√ºr '"+q.name+"':", current);
      if(next && next.trim()){
        q.category = next.trim();
        save(); renderAll();
      }
    });
  });
}

/* --------------- addLogEntry patch: Quest-Level sauber pflegen --------------- */
const __old_addLogEntry = addLogEntry;
addLogEntry = function(dateISO, questName, basePoints){
  // Originalberechnung (Multiplikator) √ºbernehmen, danach Profil updaten
  const pts = computePoints(Number(basePoints||0), dateISO);
  state.log.push({ date: dateISO, quest: questName, points: pts, base: Number(basePoints||pts) });
  updateQuestProfileAfterLog(questName, pts, dateISO);
  save();
  renderAll();
};

/* --------------- Render-All patch: Katalog + t√§gliche Malus-Logik --------------- */
const __old_renderAll = renderAll;
renderAll = function(){
  // T√§glichen Malus nur einmal t√§glich ausf√ºhren
  runDailyQuestPenalties();
  __old_renderAll();
  renderCatalogV2();
};

/* --------------------------- Initialisierung --------------------------- */
buildQuestProfilesFromLogIfEmpty();
save(); // nach m√∂glicher Migration
renderAll();
</script>
<!-- ===== End Part 2 ===== -->
<!-- ===== Part 3: Missionen (Chain/Alternativen/Fortschritt + 4√ó Abschluss-Bonus) ===== -->
<script>
/* ====================== Datenmodell & Migration ====================== */
/** Mission-Objekt:
 * {
 *   id, title, bonusMultiplier(=4),
 *   tasks: [
 *     { id:"1", title:"Leisten anbringen", points:30, group:null,
 *       reqAll:[], reqAnyGroups:[] },
 *     { id:"2.0", title:"Wand streichen", points:40, group:"2", reqAll:["1"], reqAnyGroups:[] },
 *     { id:"2.1", title:"Lampen anbringen", points:35, group:"2", reqAll:["1"], reqAnyGroups:[] },
 *     { id:"3", title:"Feinschliff", points:20, group:null, reqAll:["1"], reqAnyGroups:["2"] }
 *   ],
 *   done: { [taskId]: true },          // erledigte Tasks
 *   bonusGranted: false                // Abschlussbonus einmalig
 * }
 */
state.missions = state.missions || [];

function ensureDemoMission(){
  if(state.missions.length>0) return;
  state.missions.push({
    id: "m1",
    title: "Wohnzimmer fertig machen",
    bonusMultiplier: 4,
    tasks: [
      { id:"1",   title:"Leisten an die Wand bringen", points:30, group:null,  reqAll:[],    reqAnyGroups:[] },
      { id:"2.0", title:"Wand streichen",              points:40, group:"2",  reqAll:["1"], reqAnyGroups:[] },
      { id:"2.1", title:"Lampen anbringen",            points:35, group:"2",  reqAll:["1"], reqAnyGroups:[] },
      { id:"3",   title:"Feinschliff & Aufr√§umen",     points:20, group:null, reqAll:["1"], reqAnyGroups:["2"] }
    ],
    done: {},
    bonusGranted: false
  });
  save();
}
ensureDemoMission();

/* ====================== Hilfsfunktionen Missionen ====================== */
function missionById(id){ return state.missions.find(m=>m.id===id); }

function isTaskDone(m, tid){ return !!(m.done && m.done[tid]); }

function groupKeys(m){
  const set = new Set();
  (m.tasks||[]).forEach(t=>{ if(t.group) set.add(t.group); });
  return Array.from(set);
}

/** Pr√ºft, ob ein Task freigeschaltet ist */
function isTaskUnlocked(m, t){
  // alle reqAll m√ºssen erledigt sein
  if((t.reqAll||[]).some(reqId=>!isTaskDone(m, reqId))) return false;
  // alle reqAnyGroups: jede Gruppe muss MINDESTENS 1 erledigten Task besitzen
  if((t.reqAnyGroups||[]).some(g=>{
    return !m.tasks.some(x=>x.group===g && isTaskDone(m, x.id));
  })) return false;
  return true;
}

/** Ben√∂tigte Elemente, um Mission "erf√ºllt" zu betrachten:
 * - Alle Tasks OHNE Gruppe m√ºssen erledigt sein
 * - F√ºr JEDE existierende Gruppe muss mind. 1 Task dieser Gruppe erledigt sein
 * (Weitere, optionale Gruppen-Tasks d√ºrfen erledigt sein ‚Äì z√§hlen aber nicht doppelt.)
 */
function missionRequiredDoneStatus(m){
  const groups = groupKeys(m);
  const nonGroupTasks = m.tasks.filter(t=>!t.group);
  const groupsSatisfied = groups.every(g => m.tasks.some(t=>t.group===g && isTaskDone(m, t.id)));
  const nonGroupOk = nonGroupTasks.every(t=> isTaskDone(m, t.id));
  return { groupsSatisfied, nonGroupOk, groups, nonGroupTasks };
}

/** Punktebasis f√ºr Abschlussbonus:
 * Summe aller Non-Group-Tasks + pro Gruppe der H√ñCHSTE Punktewert unter den erledigten Varianten
 */
function missionCompletionBasePoints(m){
  const { groups } = missionRequiredDoneStatus(m);
  let sum = 0;
  // non-group
  m.tasks.filter(t=>!t.group && isTaskDone(m, t.id))
         .forEach(t=> sum += Number(t.points||0));
  // gruppen: max der erledigten
  groups.forEach(g=>{
    const doneInGroup = m.tasks.filter(t=>t.group===g && isTaskDone(m, t.id));
    if(doneInGroup.length>0){
      const maxPts = Math.max(...doneInGroup.map(t=>Number(t.points||0)));
      sum += maxPts;
    }
  });
  return sum;
}

/* ====================== Logging/Erledigen ====================== */
function completeTask(missionId, taskId){
  const m = missionById(missionId);
  if(!m) return;
  const t = m.tasks.find(x=>x.id===taskId);
  if(!t) return;

  // Schutz: nur wenn freigeschaltet und nicht schon erledigt
  if(isTaskDone(m, t.id) || !isTaskUnlocked(m, t)){ return; }

  // Log-Eintrag mit existierendem addLogEntry (inkl. Multiplikator & Quest-Level)
  const today = todayISO();
  addLogEntry(today, `Mission: ${m.title} ‚Äì ${t.title}`, Number(t.points||0));

  // Task markieren
  m.done = m.done || {};
  m.done[t.id] = true;
  save();

  // Pr√ºfen, ob Mission erf√ºllt und Bonus ausgeben (einmalig)
  const req = missionRequiredDoneStatus(m);
  if(req.groupsSatisfied && req.nonGroupOk && !m.bonusGranted){
    const base = missionCompletionBasePoints(m);
    const bonus = base * (Number(m.bonusMultiplier||4));
    // Bonus als separaten Eintrag
    state.log.push({date: todayISO(), quest:`Mission abgeschlossen: ${m.title} (Bonus)`, points: Math.round(bonus)});
    m.bonusGranted = true;
    save();
  }

  renderAll();
}

function revertTask(missionId, taskId){
  const m = missionById(missionId);
  if(!m) return;
  if(!isTaskDone(m, taskId)) return;
  delete m.done[taskId];
  // Bonus ggf. zur√ºcksetzen, falls durch Revert nicht mehr erf√ºllt
  const req = missionRequiredDoneStatus(m);
  if(!(req.groupsSatisfied && req.nonGroupOk)){
    m.bonusGranted = false;
  }
  save();
  renderAll();
}

/* ====================== UI: Tab & Rendering ====================== */
function ensureMissionsTab(){
  // Tab-Section erzeugen (falls fehlt)
  if(!document.getElementById("tab-missions")){
    const sec = document.createElement("section");
    sec.id = "tab-missions";
    sec.className = "tab space-y-4";
    sec.innerHTML = `
      <div class="p-3 border rounded bg-white shadow-sm">
        <div class="font-bold text-lg">Missionen</div>
        <div class="text-sm text-slate-600">Ketten-Aufgaben mit Alternativen & Abschluss-Bonus (4√ó).</div>
      </div>
      <div id="missionsList" class="space-y-3"></div>
      <div class="p-3 border rounded bg-white shadow-sm">
        <div class="font-semibold mb-2">Neue Mission</div>
        <div class="grid gap-2 md:grid-cols-2">
          <input id="msTitle" class="input" placeholder="Missionstitel (z. B. 'Keller renovieren')" />
          <input id="msBonus" type="number" class="input" value="4" placeholder="Bonus-Multiplikator (z. B. 4)" />
        </div>
        <button id="btnAddMission" class="btn bg-blue-600 text-white border-blue-600 mt-2">Mission anlegen</button>
      </div>
    `;
    document.querySelector("main").appendChild(sec);
  }

  // Nav-Button hinzuf√ºgen (falls fehlt)
  const navGrid = document.querySelector("nav .grid");
  const exists = navGrid && navGrid.querySelector('[data-tab="missions"]');
  if(navGrid && !exists){
    const btn = document.createElement("button");
    btn.setAttribute("data-tab","missions");
    btn.className = "py-3";
    btn.textContent = "Missionen";
    navGrid.appendChild(btn);

    // Klick-Handler (wie im bestehenden Code)
    btn.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
      document.getElementById("tab-missions").classList.add("active");
      document.querySelectorAll("nav [data-tab]").forEach(b=>b.classList.remove("text-blue-600"));
      btn.classList.add("text-blue-600");
    });
  }

  // "Mission anlegen"
  const addBtn = document.getElementById("btnAddMission");
  if(addBtn && !addBtn.__bound){
    addBtn.__bound = true;
    addBtn.addEventListener("click", ()=>{
      const title = (document.getElementById("msTitle").value||"").trim();
      const mult  = Number(document.getElementById("msBonus").value||4);
      if(!title) return;
      const id = "m" + (Date.now().toString(36));
      state.missions.push({
        id, title,
        bonusMultiplier: (mult>0?mult:4),
        tasks: [],
        done: {},
        bonusGranted: false
      });
      save(); renderAll();
      // Felder leeren
      document.getElementById("msTitle").value="";
      document.getElementById("msBonus").value="4";
    });
  }
}

function renderMissions(){
  ensureMissionsTab();
  const host = document.getElementById("missionsList");
  if(!host) return;

  // Missionen-Liste
  host.innerHTML = state.missions.map(m=>{
    // Fortschritt berechnen
    const req = missionRequiredDoneStatus(m);
    // Anzahl non-group done
    const nonGroupDone = (m.tasks.filter(t=>!t.group && isTaskDone(m,t.id))).length;
    const nonGroupNeed = (req.nonGroupTasks||[]).length;
    const groups = req.groups||[];
    const groupsDone = groups.filter(g=> m.tasks.some(t=>t.group===g && isTaskDone(m,t.id))).length;
    const groupsNeed = groups.length;

    const totalNeed = nonGroupNeed + groupsNeed;
    const totalDone = nonGroupDone + groupsDone;
    const pct = totalNeed>0 ? Math.round((totalDone/totalNeed)*100) : 0;

    // Tasks rendern
    const tasksHtml = m.tasks.map(t=>{
      const done = isTaskDone(m, t.id);
      const unlocked = isTaskUnlocked(m, t);
      const reqInfo = []
      ;(t.reqAll||[]).forEach(r=>{ if(!isTaskDone(m,r)) reqInfo.push(`Task ${r}`); });
      ;(t.reqAnyGroups||[]).forEach(g=>{
        const has = m.tasks.some(x=>x.group===g && isTaskDone(m,x.id));
        if(!has) reqInfo.push(`Gruppe ${g}`);
      });

      return `
        <div class="border rounded p-2 bg-white">
          <div class="flex items-start justify-between gap-2">
            <div class="min-w-0">
              <div class="font-medium">${t.group?`Gruppe ${t.group} ¬∑ `:""}${t.id} ‚Äî ${t.title}</div>
              <div class="text-xs text-slate-600">+${t.points} Punkte${reqInfo.length?` ¬∑ gesperrt: ${reqInfo.join(", ")}`:""}</div>
            </div>
            <div class="shrink-0 flex gap-1">
              ${done
                ? `<span class="px-2 py-1 text-xs rounded bg-green-100 text-green-800">Erledigt</span>
                   <button class="btn text-xs" data-mrevert="${m.id}:${t.id}">R√ºckg√§ngig</button>`
                : unlocked
                  ? `<button class="btn text-xs bg-emerald-600 text-white border-emerald-600" data-mdone="${m.id}:${t.id}">Erledigt</button>`
                  : `<span class="px-2 py-1 text-xs rounded bg-slate-100 text-slate-600">Gesperrt</span>`
              }
            </div>
          </div>
        </div>
      `;
    }).join("") || `<div class="text-sm text-slate-500">Noch keine Aufgaben ‚Äì f√ºge unten welche hinzu.</div>`;

    // Task-Editor (leichtgewichtig, pro Mission)
    const editor = `
      <div class="mt-2 grid md:grid-cols-5 gap-2">
        <input class="input md:col-span-2" placeholder="Task-ID (z. B. 1, 2.0, 2.1)" data-tid="${m.id}">
        <input class="input md:col-span-2" placeholder="Titel (z. B. 'Wand streichen')" data-ttitle="${m.id}">
        <input type="number" class="input" placeholder="Punkte" data-tpts="${m.id}">
        <input class="input" placeholder="Gruppe (optional z. B. 2)" data-tgrp="${m.id}">
        <input class="input md:col-span-2" placeholder="reqAll: kommasepariert (IDs)" data-tra="${m.id}">
        <input class="input md:col-span-2" placeholder="reqAnyGroups: kommasepariert (Gruppen-Keys)" data-trg="${m.id}">
        <button class="btn bg-blue-600 text-white border-blue-600" data-tadd="${m.id}">Task hinzuf√ºgen</button>
      </div>
    `;

    // Bonus-Hinweis & Reset
    const base = missionCompletionBasePoints(m);
    const potentialBonus = Math.round(base * (Number(m.bonusMultiplier||4)));

    return `
      <div class="p-3 border rounded bg-white shadow-sm">
        <div class="flex items-start justify-between gap-2">
          <div>
            <div class="font-semibold">${m.title}</div>
            <div class="text-xs text-slate-600">Fortschritt: ${totalDone}/${totalNeed} ¬∑ Bonus (bei Abschluss): +${potentialBonus} Punkte (√ó${m.bonusMultiplier||4})</div>
          </div>
          <div class="shrink-0 flex gap-2">
            <button class="btn text-xs" data-mreset="${m.id}">Fortschritt zur√ºcksetzen</button>
            <button class="btn text-xs text-red-700" data-mdel="${m.id}">Mission l√∂schen</button>
          </div>
        </div>
        <div class="mt-2 w-full bg-slate-200 h-2 rounded">
          <div class="h-2 rounded bg-indigo-500" style="width:${pct}%"></div>
        </div>

        <div class="mt-3 space-y-2">${tasksHtml}</div>

        <div class="mt-3">
          <div class="font-medium mb-1">Task hinzuf√ºgen</div>
          ${editor}
        </div>
      </div>
    `;
  }).join("");

  // Events binden
  // Task erledigen / revert
  host.querySelectorAll("[data-mdone]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const [mid,tid] = btn.getAttribute("data-mdone").split(":");
      completeTask(mid, tid);
    });
  });
  host.querySelectorAll("[data-mrevert]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const [mid,tid] = btn.getAttribute("data-mrevert").split(":");
      revertTask(mid, tid);
    });
  });

  // Mission l√∂schen / reset
  host.querySelectorAll("[data-mdel]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const mid = btn.getAttribute("data-mdel");
      const m = missionById(mid);
      if(m && confirm(`Mission "${m.title}" wirklich l√∂schen?`)){
        state.missions = state.missions.filter(x=>x.id!==mid);
        save(); renderAll();
      }
    });
  });
  host.querySelectorAll("[data-mreset]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const mid = btn.getAttribute("data-mreset");
      const m = missionById(mid);
      if(!m) return;
      m.done = {};
      m.bonusGranted = false;
      save(); renderAll();
    });
  });

  // Task hinzuf√ºgen
  host.querySelectorAll("[data-tadd]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const mid = btn.getAttribute("data-tadd");
      const m = missionById(mid);
      if(!m) return;

      const tid = (host.querySelector(`[data-tid="${mid}"]`).value||"").trim();
      const title = (host.querySelector(`[data-ttitle="${mid}"]`).value||"").trim();
      const pts = Number(host.querySelector(`[data-tpts="${mid}"]`).value||0);
      const grp = (host.querySelector(`[data-tgrp="${mid}"]`).value||"").trim() || null;
      const ra  = (host.querySelector(`[data-tra="${mid}"]`).value||"").trim();
      const rg  = (host.querySelector(`[data-trg="${mid}"]`).value||"").trim();

      if(!tid || !title || !pts) return;

      // Duplikat verhindern -> √ºberschreiben
      const existing = m.tasks.find(x=>x.id===tid);
      const reqAll = ra ? ra.split(",").map(s=>s.trim()).filter(Boolean) : [];
      const reqAnyGroups = rg ? rg.split(",").map(s=>s.trim()).filter(Boolean) : [];

      const taskObj = { id:tid, title, points:pts, group:grp, reqAll, reqAnyGroups };
      if(existing){
        Object.assign(existing, taskObj);
      }else{
        m.tasks.push(taskObj);
      }
      save(); renderAll();
    });
  });
}

/* ====================== Render-All Hook ====================== */
const ___old_renderAll_missions = renderAll;
renderAll = function(){
  ___old_renderAll_missions();
  renderMissions();
};
renderAll();
</script>
<!-- ===== End Part 3 ===== -->
<!-- ===== Part 4: Dynamische Meilensteine (Quests/Boss/Missionen/Kategorien) ===== -->
<script>
/* 
Ziele:
- Auto-Meilensteine ohne "undefined"
- Belohnungen sp√ºrbar h√∂her, skalierend
- Einmalige Vergabe mit Logging
- Anzeige im Dashboard

Beispiele (matcht deine Vorgaben):
- Quests: 100‚Üí100, 200‚Üí400, 500‚Üí2500  (Formel: (t/100)^2*100)
- Bossquests: 10‚Üí100, 20‚Üí200 (override), 50‚Üí2500 (sonst ~t^2)
- Missionen: 5‚Üí25, 10‚Üí100, 20‚Üí400, 50‚Üí2500 (Formel: (t/10)^2*100, 5‚Üí25)
*/

/* ====================== Setup Speicher ====================== */
state.milestonesClaims = state.milestonesClaims || {}; // { id: {claimed:true, date:"YYYY-MM-DD"} }

/* ====================== Hilfsfunktionen ====================== */
function unique(arr){ return Array.from(new Set(arr)); }

// Robust log helper: nutzt addLogEntry falls vorhanden, sonst fallback
function logQuestWithCompute(dateISO, questName, basePoints){
  if(typeof addLogEntry === "function"){
    addLogEntry(dateISO, questName, basePoints);
  }else{
    // Fallback: computePoints + push
    const pts = typeof computePoints === "function" ? computePoints(basePoints, dateISO) : basePoints;
    state.log.push({date: dateISO, quest: questName, points: pts, base: basePoints});
    save();
  }
}

// Bossquest-Namen-Set (aus Katalog)
function bossQuestNameSet(){
  const set = new Set();
  (state.catalog||[]).forEach(q=>{
    if(q && q.boss && q.name) set.add(q.name);
  });
  return set;
}

// Z√§hle "normale" Quest-Eintr√§ge (alles, was echte Aufgaben sind)
function countQuestEntries(){
  return state.log.filter(e=>{
    if(!e || typeof e.points !== "number") return false;
    // System-/Meta-Eintr√§ge ausklammern:
    const q = (e.quest||"").toLowerCase();
    if(q.startsWith("reward")) return false;
    if(q.startsWith("milestone")) return false;
    if(q.startsWith("event-")) return false;
    if(q.startsWith("tagesziel bonus")) return false;
    if(q.startsWith("timed quest verpasst")) return false;
    return true;
  }).length;
}

// Z√§hle Bossquests via Katalog-Abgleich
function countBossQuestEntries(){
  const bosses = bossQuestNameSet();
  return state.log.filter(e=>{
    const name = e && e.quest;
    return name && bosses.has(name);
  }).length;
}

// Z√§hle abgeschlossene Missionen
function countCompletedMissions(){
  return (state.missions||[]).filter(m=>m && m.bonusGranted).length;
}

// (Optional) Kategorie-Zusammenfassung, falls sp√§ter Kategorien eingef√ºhrt werden.
// Erwartet state.categories = [{id, name, ...}] und/oder state.categoryStats = {name:{points, count}}
function getCategoryPointMap(){
  // Wenn dein Kategoriensystem sp√§ter eingef√ºhrt ist, kannst du hier die echte Zuordnung nutzen.
  // Aktuell: sanfter Fallback -> leer lassen (keine Kategorien ‚Üí keine Cat-Meilensteine).
  return {}; // { "Sport": {points: 123, count: 9}, ... }
}

/* ====================== Schwellen & Belohnungen ====================== */

// Erzeugt Schwellenfolge nach 1-2-5 Serie * 10er-Potenzen: [1,2,5,10,20,50,100,200,500,...] * base
function buildThresholds(base, max){
  const out = [];
  let mul = 1;
  while(true){
    for(const k of [1,2,5]){
      const th = base * k * mul;
      if(th > max) return out;
      out.push(th);
    }
    mul *= 10;
  }
}

// Belohnungen nach deinen Vorgaben/Beispielen:
function rewardForQuests(th){         // 100‚Üí100, 200‚Üí400, 500‚Üí2500, ...
  return Math.round(Math.pow(th/100, 2) * 100);
}
function rewardForMissions(th){       // 5‚Üí25, 10‚Üí100, 20‚Üí400, 50‚Üí2500, ...
  return Math.round(Math.pow(th/10,  2) * 100);
}
function rewardForBoss(th){           // 10‚Üí100, 20‚Üí200, 50‚Üí2500 (Override), sonst ~t^2
  if(th===20) return 200;
  if(th===10) return 100;
  if(th===50) return 2500;
  return Math.round(th*th); // stark, aber motivierend
}
// Kategorien (Punkt-Meilensteine) ‚Äì einfache Progression:
function rewardForCategoryPoints(th){ // z.B. 1k‚Üí100, 2k‚Üí400, 5k‚Üí2500 ...
  return Math.round(Math.pow(th/1000, 2) * 100);
}

/* ====================== Definition dynamischer Meilensteine ====================== */
function buildDynamicMilestones(){
  const milestones = [];

  // --- Quests (Gesamt-Anzahl) ---
  const qThresholds = buildThresholds(100, 100000); // ab 100
  qThresholds.forEach(th=>{
    milestones.push({
      id: `Q-${th}`,
      label: `${th} Quests erledigt`,
      reward: rewardForQuests(th),
      type: "quests",
      threshold: th
    });
  });

  // --- Bossquests (Anzahl) ---
  const bThresholds = buildThresholds(10, 10000); // ab 10
  bThresholds.forEach(th=>{
    milestones.push({
      id: `B-${th}`,
      label: `${th} Bossquests erledigt`,
      reward: rewardForBoss(th),
      type: "boss",
      threshold: th
    });
  });

  // --- Missionen (abgeschlossene Missionen) ---
  const mThresholds = buildThresholds(5, 5000); // ab 5
  mThresholds.forEach(th=>{
    milestones.push({
      id: `M-${th}`,
      label: `${th} Missionen abgeschlossen`,
      reward: rewardForMissions(th),
      type: "missions",
      threshold: th
    });
  });

  // --- Kategorien (optional; Punkte je Kategorie) ---
  const catMap = getCategoryPointMap(); // {name:{points}}
  const catNames = Object.keys(catMap);
  const catThresholds = [1000, 2000, 5000, 10000, 20000, 50000];
  catNames.forEach(name=>{
    catThresholds.forEach(th=>{
      milestones.push({
        id: `C-${name}-${th}`,
        label: `${name}: ${th.toLocaleString()} Kategorien-Punkte`,
        reward: rewardForCategoryPoints(th),
        type: "category",
        category: name,
        threshold: th
      });
    });
  });

  return milestones;
}

/* ====================== Pr√ºfung & Vergabe ====================== */
function currentProgressByType(){
  const today = todayISO();
  const progress = {
    quests: countQuestEntries(),
    boss: countBossQuestEntries(),
    missions: countCompletedMissions(),
    category: getCategoryPointMap() // { name:{points} }
  };
  return progress;
}

function tryClaimMilestone(ms, progress){
  const id = ms.id;
  if(state.milestonesClaims[id]?.claimed) return false;

  // Pr√ºfen, ob Schwelle erreicht
  let reached = false;
  if(ms.type==="quests")   reached = progress.quests >= ms.threshold;
  if(ms.type==="boss")     reached = progress.boss   >= ms.threshold;
  if(ms.type==="missions") reached = progress.missions >= ms.threshold;
  if(ms.type==="category"){
    const cPoints = progress.category[ms.category]?.points || 0;
    reached = cPoints >= ms.threshold;
  }

  if(!reached) return false;

  // einmalig gutschreiben (direkt als POSITIVER Bonus-Eintrag)
  state.milestonesClaims[id] = {claimed:true, date: todayISO()};
  state.log.push({
    date: todayISO(),
    quest: `Milestone erreicht: ${ms.label}`,
    points: ms.reward
  });
  save();
  return true;
}

/* ====================== Render ====================== */
function renderMilestonesCard(){
  // Host-Box erzeugen/leer r√§umen
  let box = document.getElementById("milestonesBox");
  if(!box){
    box = document.createElement("div");
    box.id = "milestonesBox";
    document.getElementById("tab-dashboard").appendChild(box);
  }
  box.innerHTML = ""; // sauber neu

  const all = buildDynamicMilestones();
  const p   = currentProgressByType();

  // Auto-Claim: alles pr√ºfen (kann mehrere auf einmal ausl√∂sen)
  let anyNew = false;
  all.forEach(ms=>{
    if(tryClaimMilestone(ms, p)) anyNew = true;
  });
  if(anyNew){
    // nach Vergaben neu berechnen (damit UI die neuen Punkte/Level zeigt)
    // (Kein renderAll() hier, um Rekursion zu vermeiden; wir st√ºtzen uns auf die n√§chste Gesamtrenderung)
  }

  // Anzeige: n√§chstliegende 6 Milestones (mix aus Typen), inkl. Status
  // Sortierung: "Distanz zur Schwelle" aufsteigend
  function distance(ms){
    if(ms.type==="quests")   return Math.max(0, ms.threshold - p.quests);
    if(ms.type==="boss")     return Math.max(0, ms.threshold - p.boss);
    if(ms.type==="missions") return Math.max(0, ms.threshold - p.missions);
    if(ms.type==="category"){
      const cPoints = p.category[ms.category]?.points || 0;
      return Math.max(0, ms.threshold - cPoints);
    }
    return 9999999;
  }

  // Erreichte zuerst gesondert erfassen
  const reachedList = all.filter(ms=>{
    const claim = state.milestonesClaims[ms.id]?.claimed;
    return claim === true;
  }).slice(-5); // die letzten 5 erreichten f√ºr Kurzhistorie

  const upcoming = all
    .filter(ms=>!state.milestonesClaims[ms.id]?.claimed)
    .sort((a,b)=>distance(a)-distance(b))
    .slice(0,6);

  // UI bauen
  const wrap = document.createElement("div");
  wrap.className = "mt-4 p-3 border rounded bg-orange-50";
  wrap.innerHTML = `
    <h3 class="font-bold">üéØ Meilensteine</h3>
    <div class="text-sm text-slate-600 mb-2">Automatisch generiert ‚Äì Belohnungen einmalig bei Erreichen.</div>
    <div class="grid gap-2">
      ${upcoming.map(ms=>{
        let cur=0, max=ms.threshold, tag="";
        if(ms.type==="quests"){ cur=p.quests; tag="Quests"; }
        if(ms.type==="boss"){ cur=p.boss; tag="Bossquests"; }
        if(ms.type==="missions"){ cur=p.missions; tag="Missionen"; }
        if(ms.type==="category"){ cur=p.category[ms.category]?.points||0; tag=`${ms.category}`; }
        const pct = Math.min(100, Math.round((cur/max)*100));
        return `
          <div class="p-2 border rounded bg-white">
            <div class="flex items-center justify-between text-sm">
              <div><b>${ms.label}</b> ¬∑ Bonus: +${ms.reward} Punkte</div>
              <div>${cur.toLocaleString()} / ${max.toLocaleString()}</div>
            </div>
            <div class="w-full bg-slate-200 h-2 rounded mt-1">
              <div class="h-2 rounded bg-amber-500" style="width:${pct}%"></div>
            </div>
          </div>
        `;
      }).join("") || `<div class="text-sm text-slate-500">Alle aktuellen Meilensteine erreicht üéâ</div>`}
    </div>

    ${reachedList.length?`
      <div class="mt-3">
        <div class="font-medium mb-1">K√ºrzlich erreicht</div>
        <div class="space-y-1 text-sm">
          ${reachedList.map(ms=>{
            const d = state.milestonesClaims[ms.id]?.date || "";
            return `<div class="p-2 border rounded bg-green-50">‚úîÔ∏è ${ms.label} ¬∑ ${d} ¬∑ +${ms.reward} Punkte</div>`;
          }).join("")}
        </div>
      </div>`:""}
  `;
  box.appendChild(wrap);
}

/* ====================== Hooks ====================== */
// Dashboard-Hook einrichten
const ___old_renderDashboard_milestones = renderDashboard;
renderDashboard = function(){
  ___old_renderDashboard_milestones();
  renderMilestonesCard();
};

// Nach jedem Log-Eintrag neu bewerten (falls addLog existiert, hooken)
if(typeof addLog === "function" && !addLog.__milestoneHooked){
  const __oldAddLogMilestones = addLog;
  addLog = function(){
    __oldAddLogMilestones();
    // nach Log neu rendern ‚Üí Milestones pr√ºfen
    renderMilestonesCard();
  };
  addLog.__milestoneHooked = true;
}

// Falls du eine zentrale addLogEntry nutzt, hooken wir ebenfalls
if(typeof addLogEntry === "function" && !addLogEntry.__milestoneHooked){
  const __oldAddLogEntryMilestones = addLogEntry;
  addLogEntry = function(dateISO, quest, basePoints){
    __oldAddLogEntryMilestones(dateISO, quest, basePoints);
    renderMilestonesCard();
  };
  addLogEntry.__milestoneHooked = true;
}

// Initial
renderMilestonesCard();
</script>
<!-- ===== End Part 4 ===== -->
<!-- ===== Part 5: Kategorien, Verkn√ºpfungen, Negative Kategorien ===== -->
<script>
// ====== State & Defaults ======
state.categories = state.categories || [
  {id:"cat_sport", name:"Sport", negative:false, penaltyRatio:0.0},
  {id:"cat_handwerk", name:"Handwerk", negative:false, penaltyRatio:0.0},
  {id:"cat_bad", name:"Schlechter Lebensstil", negative:true, penaltyRatio:2.0} // z.B. 2x Strafe
];
state.categoryOfQuest = state.categoryOfQuest || {};         // { "Questname": "cat_id" }
state.categoryStats   = state.categoryStats   || {};         // { cat_id: {points:0, count:0} }
state.categoryLinks   = state.categoryLinks   || [];         // [{fromId,toId,mode:'bonus'|'penalty',ratio:0.2}]
state.categoryPenaltyNames = state.categoryPenaltyNames || {};// { "Sport": true } -> n√§chstes Cat-Milestone nur 0.1x

// Hilfen
function catById(id){ return (state.categories||[]).find(c=>c.id===id); }
function catIdByName(name){ const c=(state.categories||[]).find(c=>c.name===name); return c?c.id:null; }
function ensureCatStats(id){ if(!state.categoryStats[id]) state.categoryStats[id]={points:0,count:0}; return state.categoryStats[id]; }
function isSystemEntry(e){
  const q=(e.quest||"").toLowerCase();
  return (
    q.startsWith("reward") ||
    q.startsWith("milestone") ||
    q.startsWith("event-") ||
    q.startsWith("tagesziel bonus") ||
    q.startsWith("timed quest verpasst")
  );
}

// ====== Kern: Log-Integrationen f√ºr Kategorien ======
function processCategoryOnLogEntry(e){
  // Nur echte Eintr√§ge bewerten
  if(!e || typeof e.points!=="number" || !e.quest || e._sys) return;

  const questName = e.quest;
  const catId = state.categoryOfQuest[questName];
  if(!catId) return; // keine Kategorie zugewiesen

  const cat = catById(catId);
  ensureCatStats(catId);
  const base = (typeof e.base==="number" && e.base>0) ? e.base : Math.abs(e.points);

  if(cat && cat.negative){
    // Negative Kategorie:
    // - Gesamtpunkte: sollen negativ sein (Strafe). Wenn positiv, korrigieren:
    if(e.points>0){
      const penaltyRatio = Math.max(0, Number(cat.penaltyRatio)||2.0);
      e.points = -Math.round(base*penaltyRatio);
    }
    // - Kategorie-Konto bekommt trotzdem positive Punkte (base)
    state.categoryStats[catId].points += base;
    state.categoryStats[catId].count  += 1;
  }else{
    // Normale Kategorie: Kategorie-Konto sammelt die tats√§chlich erhaltenen Punkte, aber nicht unter 0
    const add = Math.max(0, e.points);
    state.categoryStats[catId].points += add;
    state.categoryStats[catId].count  += (add>0?1:0);
  }

  // Kategorie-Verkn√ºpfungen anwenden (nur Kategoriensummen, kein Einfluss auf Gesamtpunkte)
  (state.categoryLinks||[]).forEach(link=>{
    if(link.fromId!==catId) return;
    const tgt = ensureCatStats(link.toId);
    const ratio = Math.max(0, Number(link.ratio)||0);
    const delta = Math.round(base*ratio);
    const toName = (catById(link.toId)||{}).name || "";

    if(link.mode==="bonus"){
      tgt.points += delta;
      if(delta>0) tgt.count += 1;
    }else if(link.mode==="penalty"){
      // Penalty: Kategoriensumme senken, nie unter 0, und n√§chstes Cat-Milestone dieser Zielkategorie nur 0.1x belohnen
      tgt.points = Math.max(0, tgt.points - delta);
      if(toName) state.categoryPenaltyNames[toName] = true;
    }
  });

  save();
}

// Hook: addLog ‚Üí Kategorien verarbeiten (nur einmal hooken)
if(typeof addLog==="function" && !addLog.__catHooked){
  const __oldAddLogCat = addLog;
  addLog = function(){
    const before = state.log.length;
    __oldAddLogCat();
    const after = state.log.length;
    if(after>before){
      const entry = state.log[after-1];
      processCategoryOnLogEntry(entry);
    }
    renderCategoriesDashboardCard(); // live updaten
    if(typeof renderMilestonesCard==="function") renderMilestonesCard();
  };
  addLog.__catHooked = true;
}

// Sicherheitsnetz: state.log.push abfangen, damit auch Chat/Auto-Logs erfasst werden
(function wrapLogPush(){
  if(state.__wrappedCatPush) return;
  const orig = state.log.push;
  state.log.push = function(...args){
    const r = Array.prototype.push.apply(this, args);
    // alle neuen Eintr√§ge prozessieren
    args.forEach(e=>processCategoryOnLogEntry(e));
    // UI refresh
    renderCategoriesDashboardCard();
    if(typeof renderMilestonesCard==="function") renderMilestonesCard();
    return r;
  };
  state.__wrappedCatPush = true;
})();

// ====== Part 4 Integration: Kategorien wirklich an Milestones melden ======
// 1) Liefere echte Kategorie-Map (√ºberschreibt Platzhalter aus Part 4)
function getCategoryPointMap(){
  const out = {};
  (state.categories||[]).forEach(c=>{
    const st = ensureCatStats(c.id);
    out[c.name] = {points: st.points, count: st.count};
  });
  return out;
}
// 2) Milestone-Claim mit 0.1x-Logik bei gesetzter Penalty-Flag f√ºr betroffene Kategorie
//    Wir ersetzen tryClaimMilestone kontrolliert (nur wenn vorhanden).
if(typeof tryClaimMilestone === "function" && !tryClaimMilestone.__catWrapped){
  const __origTry = tryClaimMilestone;
  tryClaimMilestone = function(ms, progress){
    // Wenn Kategorie-Milestone: ggf. 0.1x anwenden
    if(ms && ms.type==="category"){
      const name = ms.category;
      const reached = (progress.category[name]?.points||0) >= ms.threshold;
      if(!reached) return false;
      if(state.milestonesClaims[ms.id]?.claimed) return false;

      let reward = ms.reward;
      if(state.categoryPenaltyNames[name]){
        reward = Math.max(1, Math.round(reward*0.1)); // 1/10 der Belohnung
        delete state.categoryPenaltyNames[name];
      }
      state.milestonesClaims[ms.id] = {claimed:true, date: todayISO()};
      state.log.push({date:todayISO(), quest:`Milestone erreicht: ${ms.label}`, points: reward});
      save();
      return true;
    }
    // Sonst Standardverhalten
    return __origTry(ms, progress);
  };
  tryClaimMilestone.__catWrapped = true;
}

// ====== UI: Dashboard-Karte ‚ÄûKategorien‚Äú ======
function renderCategoriesDashboardCard(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;
  let box = document.getElementById("categoriesBox");
  if(!box){
    box = document.createElement("div");
    box.id = "categoriesBox";
    host.appendChild(box);
  }
  // Inhalt
  const rows = (state.categories||[]).map(c=>{
    const st = ensureCatStats(c.id);
    return `
      <div class="p-2 border rounded bg-white flex items-center justify-between">
        <div>${c.negative?"‚ö†Ô∏è ":""}<b>${c.name}</b></div>
        <div class="text-sm text-slate-600">${st.points.toLocaleString()} Punkte</div>
      </div>
    `;
  }).join("");
  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-indigo-50">
      <h3 class="font-bold">üè∑Ô∏è Kategorien</h3>
      <div class="grid gap-2 mt-2">${rows || `<div class="text-sm text-slate-500">Noch keine Kategorien</div>`}</div>
    </div>
  `;
}

// ====== UI: Manager im Katalog-Tab (Kategorien, Links, Zuweisungen) ======
function renderCategoriesManager(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;
  let wrap = document.getElementById("categoriesManager");
  if(!wrap){
    wrap = document.createElement("div");
    wrap.id = "categoriesManager";
    host.appendChild(wrap);
  }

  // Kategorienliste + Add-Form
  const list = (state.categories||[]).map(c=>{
    const st = ensureCatStats(c.id);
    return `
      <div class="p-2 border rounded flex items-center justify-between bg-white">
        <div>
          <b>${c.name}</b> ${c.negative?`<span class="text-xs text-red-600 ml-1">(negativ)</span>`:""}
          <div class="text-xs text-slate-500">Punkte: ${st.points.toLocaleString()}</div>
        </div>
        <div class="flex items-center gap-2">
          <label class="text-xs">Straf-Faktor
            <input data-cat="${c.id}" data-k="penaltyRatio" type="number" step="0.1" class="input w-20" value="${Number(c.penaltyRatio||0).toFixed(1)}">
          </label>
          <button class="btn text-sm" data-delcat="${c.id}">L√∂schen</button>
        </div>
      </div>
    `;
  }).join("");

  // Links
  const catOptions = (state.categories||[]).map(c=>`<option value="${c.id}">${c.name}</option>`).join("");
  const links = (state.categoryLinks||[]).map((l,i)=>{
    const from = catById(l.fromId)?.name || "‚Äì";
    const to   = catById(l.toId)?.name   || "‚Äì";
    const badge = l.mode==="bonus" ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700";
    return `
      <div class="p-2 border rounded bg-white flex items-center justify-between">
        <div>
          <span class="px-2 py-0.5 rounded text-xs ${badge}">${l.mode}</span>
          <b class="ml-2">${from}</b> ‚Üí <b>${to}</b>
          <span class="text-xs text-slate-500 ml-2">${Math.round((l.ratio||0)*100)}%</span>
        </div>
        <button class="btn text-sm" data-dellink="${i}">Entfernen</button>
      </div>
    `;
  }).join("");

  // Quest-Zuweisungen
  const assignRows = (state.catalog||[]).map(q=>{
    const cur = state.categoryOfQuest[q.name] || "";
    return `
      <div class="p-2 border rounded bg-white flex items-center justify-between">
        <div>üìå ${q.boss?"üëë ":""}${q.name} <span class="text-xs text-slate-500">(+${q.points})</span></div>
        <select class="input w-44" data-qcat="${q.name}">
          <option value="">‚Äî keine Kategorie ‚Äî</option>
          ${catOptions.replaceAll(`value="${cur}"`,`value="${cur}" selected`)}
        </select>
      </div>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-amber-50">
      <h3 class="font-bold">üóÇÔ∏è Kategorien verwalten</h3>

      <div class="mt-2 grid gap-2">${list || `<div class="text-sm text-slate-500">Noch keine Kategorien</div>`}</div>

      <div class="mt-3 p-2 border rounded bg-white grid md:grid-cols-4 gap-2 items-end">
        <input id="newCatName" class="input" placeholder="Neue Kategorie (z. B. Sport)">
        <label class="text-sm"><input type="checkbox" id="newCatNeg"> negativ</label>
        <label class="text-sm">Straf-Faktor <input id="newCatPenalty" type="number" step="0.1" class="input" value="2.0"></label>
        <button id="btnAddCategory" class="btn bg-blue-600 text-white">+ Kategorie</button>
      </div>

      <h4 class="font-bold mt-4">üîó Verkn√ºpfungen (nur Kategoriensummen)</h4>
      <div class="text-xs text-slate-600 mb-1">z. B. ‚ÄûSchlechter Lebensstil (penalty) ‚Üí Sport (-)‚Äú oder ‚ÄûHandwerk (bonus) ‚Üí Sport (+)‚Äú</div>
      <div class="p-2 border rounded bg-white grid md:grid-cols-5 gap-2 items-end">
        <select id="linkFrom" class="input">${catOptions}</select>
        <select id="linkMode" class="input">
          <option value="bonus">bonus</option>
          <option value="penalty">penalty</option>
        </select>
        <select id="linkTo" class="input">${catOptions}</select>
        <label class="text-sm">% (vom Basiswert)
          <input id="linkRatio" type="number" step="0.05" class="input" value="0.2">
        </label>
        <button id="btnAddLink" class="btn">+ Verkn√ºpfung</button>
      </div>
      <div class="mt-2 grid gap-2" id="linksList">${links || `<div class="text-sm text-slate-500">Noch keine Verkn√ºpfungen</div>`}</div>

      <h4 class="font-bold mt-4">üìé Quests ‚Üí Kategorien</h4>
      <div class="grid gap-2">${assignRows || `<div class="text-sm text-slate-500">Noch keine Quests im Katalog</div>`}</div>
    </div>
  `;

  // Events: Kategorie-L√∂schen / Straf-Faktor √§ndern
  wrap.querySelectorAll("[data-delcat]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const id = btn.getAttribute("data-delcat");
      // Schutz: wenn zugewiesen, erst entfernen
      Object.keys(state.categoryOfQuest).forEach(q=>{
        if(state.categoryOfQuest[q]===id) delete state.categoryOfQuest[q];
      });
      state.categories = state.categories.filter(c=>c.id!==id);
      save(); renderCategoriesManager(); renderCategoriesDashboardCard();
      if(typeof renderMilestonesCard==="function") renderMilestonesCard();
    });
  });
  wrap.querySelectorAll("[data-cat]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const id = inp.getAttribute("data-cat");
      const k  = inp.getAttribute("data-k");
      const cat= catById(id);
      if(!cat) return;
      if(k==="penaltyRatio") cat.penaltyRatio = Number(inp.value)||0;
      save();
    });
  });

  // Events: Neue Kategorie
  wrap.querySelector("#btnAddCategory").addEventListener("click",()=>{
    const name = (document.getElementById("newCatName").value||"").trim();
    if(!name) return alert("Bitte Namen eingeben");
    const negative = document.getElementById("newCatNeg").checked;
    const ratio = Number(document.getElementById("newCatPenalty").value||0);
    const id = "cat_"+Math.random().toString(36).slice(2,9);
    state.categories.push({id, name, negative, penaltyRatio: ratio});
    save(); renderCategoriesManager(); renderCategoriesDashboardCard();
    if(typeof renderMilestonesCard==="function") renderMilestonesCard();
  });

  // Events: Verkn√ºpfungen
  wrap.querySelector("#btnAddLink").addEventListener("click",()=>{
    const fromId = document.getElementById("linkFrom").value;
    const toId   = document.getElementById("linkTo").value;
    const mode   = document.getElementById("linkMode").value; // bonus|penalty
    const ratio  = Number(document.getElementById("linkRatio").value||0);
    if(!fromId || !toId) return;
    if(fromId===toId) return alert("Von und Nach d√ºrfen nicht identisch sein.");
    state.categoryLinks.push({fromId,toId,mode,ratio});
    save(); renderCategoriesManager();
  });
  wrap.querySelectorAll("[data-dellink]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const i = Number(btn.getAttribute("data-dellink"));
      state.categoryLinks.splice(i,1);
      save(); renderCategoriesManager();
    });
  });

  // Events: Quest ‚Üí Kategorie
  wrap.querySelectorAll("[data-qcat]").forEach(sel=>{
    sel.addEventListener("change",()=>{
      const qname = sel.getAttribute("data-qcat");
      const id = sel.value || undefined;
      if(id) state.categoryOfQuest[qname]=id;
      else delete state.categoryOfQuest[qname];
      save();
    });
  });
}

// Hook in bestehende Renderer (ohne zu √ºberschreiben)
(function hookCatalogAndDashboard(){
  // Nach jedem renderAll() erneut darstellen
  if(typeof renderAll==="function" && !renderAll.__catHooked){
    const __old = renderAll;
    renderAll = function(){
      __old();
      renderCategoriesDashboardCard();
      renderCategoriesManager();
    };
    renderAll.__catHooked = true;
  }else{
    // Falls nicht vorhanden, zumindest einmal initial rendern
    renderCategoriesDashboardCard();
    renderCategoriesManager();
  }
})();

// Nachladen: Nach Part 5 ist getCategoryPointMap echt ‚Üí Milestones aktualisieren
if(typeof renderMilestonesCard==="function") renderMilestonesCard();

</script>
<!-- ===== End Part 5 ===== -->
<!-- ===== Part 6: Per-Quest Levelsystem ===== -->
<script>
// ====== State ======
state.questProgress   = state.questProgress   || {}; // { "Questname": {xp:0, level:1} }
state.questLastDone   = state.questLastDone   || {}; // { "Questname": "YYYY-MM-DD" }
state.__lastDecayRunDate = state.__lastDecayRunDate || ""; // global: wann Verfall zuletzt angewendet

// ====== Helpers ======
function questXPNeeded(level){
  // Zus√§tzliche XP bis zum n√§chsten Level:
  // Lvl2: 100, Lvl3: 110, Lvl4: 120, ...
  return 100 + Math.max(0, (level-1)) * 10;
}
function getAllQuestNames(){
  const set = new Set();
  // aus Katalog
  (state.catalog||[]).forEach(q=>set.add(q.name));
  // aus Log
  (state.log||[]).forEach(e=>{ if(e && e.quest) set.add(e.quest); });
  // aus bereits existierenden Progress-Eintr√§gen
  Object.keys(state.questProgress||{}).forEach(n=>set.add(n));
  return [...set];
}
function isSystemEntryForQuestLevel(e){
  if(!e || !e.quest) return true;
  const q = e.quest.toLowerCase();
  return (
    q.startsWith("reward") ||
    q.startsWith("milestone") ||
    q.startsWith("event-") ||
    q.startsWith("tagesziel bonus") ||
    q.startsWith("timed quest verpasst")
  );
}
function yesterdayISO(){
  const d=new Date(); d.setDate(d.getDate()-1);
  return d.toISOString().slice(0,10);
}

// ====== Core: XP add / remove ======
function ensureQuestProg(name){
  if(!state.questProgress[name]) state.questProgress[name] = {xp:0, level:1};
  return state.questProgress[name];
}

function questAddXP(name, addXP){
  if(!name || !Number.isFinite(addXP) || addXP<=0) return {levelUp:false};
  const qp = ensureQuestProg(name);
  qp.xp += Math.round(addXP);

  let levelUpCount = 0;
  // Mehrfach-Level-Ups erlauben
  while(qp.xp >= questXPNeeded(qp.level)){
    qp.xp -= questXPNeeded(qp.level);
    qp.level++;
    levelUpCount++;
  }
  save();
  return {levelUp: levelUpCount>0, up: levelUpCount};
}

function questDecayOneStep(name, dec=15){
  const qp = ensureQuestProg(name);
  qp.xp -= dec;
  // Level-Down, wenn XP < 0
  while(qp.xp < 0 && qp.level > 1){
    qp.level--;
    qp.xp += questXPNeeded(qp.level);
  }
  if(qp.xp < 0) qp.xp = 0;
}

function applyDailyQuestDecay(){
  const today = todayISO();
  if(state.__lastDecayRunDate === today) return; // schon erledigt

  const yISO = yesterdayISO();
  const names = getAllQuestNames();
  names.forEach(name=>{
    // Nur f√ºr "normale" Quests sinnvoll ‚Äì wir wenden es prinzipiell auf alle an, die Punkte sammeln
    // Check: gab es gestern einen positiven Eintrag f√ºr diese Quest?
    const doneYesterday = (state.log||[]).some(e=>{
      return e && e.date===yISO && e.quest===name && Number(e.points)>0 && !isSystemEntryForQuestLevel(e);
    });
    if(!doneYesterday){
      questDecayOneStep(name, 15);
    }
  });

  state.__lastDecayRunDate = today;
  save();
}

// ====== Hook: auf neue Log-Eintr√§ge reagieren ======
function processQuestLevelOnLogEntry(e){
  if(!e || !e.quest) return;
  if(isSystemEntryForQuestLevel(e)) return;

  const pts = Number(e.points)||0;
  if(pts>0){
    // XP +, Level-Up ggf. Feedback
    const res = questAddXP(e.quest, pts);
    state.questLastDone[e.quest] = e.date || todayISO();
    save();

    if(res.levelUp){
      // kleinem akustischen & visuellen Feedback (optional, wenn vorhanden)
      try{ if(window.FX) FX.burst(); }catch(_){}
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        const ctx = new AC();
        const now = ctx.currentTime;
        [440,554,659].forEach((f,i)=>{
          const o=ctx.createOscillator(), g=ctx.createGain();
          o.type="triangle"; o.frequency.value=f;
          g.gain.value=0.06; o.connect(g).connect(ctx.destination);
          o.start(now+i*0.12); o.stop(now+i*0.12+0.18);
        });
      }catch(_){}
      // kleiner Toast
      const t=document.createElement("div");
      t.textContent=`üèÖ Quest-Level Up: ${e.quest}`;
      t.className="fixed bottom-24 left-1/2 -translate-x-1/2 bg-emerald-600 text-white px-4 py-2 rounded shadow-lg";
      document.body.appendChild(t);
      setTimeout(()=>t.remove(),1600);
    }
  }
}

// Wrapper um state.log.push (kettet sich hinter fr√ºhere Wrapper)
(function wrapLogPushForQuestLevels(){
  if(state.__wrappedQuestPush) return;
  const orig = state.log.push;
  state.log.push = function(...args){
    const r = Array.prototype.push.apply(this, args);
    // neue Eintr√§ge verarbeiten
    args.forEach(e=> processQuestLevelOnLogEntry(e));
    // UI updaten
    renderQuestLevelsDashboardCard();
    renderQuestLevelsPanel();
    return r;
  };
  state.__wrappedQuestPush = true;
})();

// ====== UI: Dashboard (kompakte √úbersicht) ======
function renderQuestLevelsDashboardCard(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;
  let box = document.getElementById("questLevelsBox");
  if(!box){
    box = document.createElement("div");
    box.id = "questLevelsBox";
    host.appendChild(box);
  }

  // sortiere Quests nach Level, dann nach verbleibendem Fortschritt
  const rows = getAllQuestNames()
    .filter(n=>state.questProgress[n]) 
    .map(n=>{
      const qp = state.questProgress[n];
      const need = questXPNeeded(qp.level);
      const pct = Math.max(0, Math.min(100, Math.round((qp.xp/need)*100)));
      return {name:n, level:qp.level, xp:qp.xp, need, pct};
    })
    .sort((a,b)=> b.level - a.level || b.pct - a.pct)
    .slice(0,8) // kompakt
    .map(r=>`
      <div class="p-2 border rounded bg-white">
        <div class="flex justify-between text-sm"><b>${r.name}</b><span>Lvl ${r.level}</span></div>
        <div class="w-full bg-gray-200 rounded h-2 mt-1">
          <div class="h-2 rounded" style="width:${r.pct}%; background:#10b981;"></div>
        </div>
        <div class="text-[10px] mt-1 text-slate-600">${r.xp}/${r.need} XP</div>
      </div>
    `).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-emerald-50">
      <h3 class="font-bold">üß© Quest-Level (Top)</h3>
      <div class="grid gap-2 mt-2">
        ${rows || `<div class="text-sm text-slate-500">Noch keine Quest-Level vorhanden</div>`}
      </div>
    </div>
  `;
}

// ====== UI: Katalog-Panel (vollst√§ndige Liste) ======
function renderQuestLevelsPanel(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;
  let wrap = document.getElementById("questLevelsPanel");
  if(!wrap){
    wrap = document.createElement("div");
    wrap.id = "questLevelsPanel";
    host.appendChild(wrap);
  }

  const names = getAllQuestNames().sort((a,b)=> (a.toLowerCase()<b.toLowerCase()?-1:1));
  const rows = names.map(n=>{
    const qp = ensureQuestProg(n);
    const need = questXPNeeded(qp.level);
    const pct = Math.max(0, Math.min(100, Math.round((qp.xp/need)*100)));
    return `
      <div class="p-2 border rounded bg-white">
        <div class="flex justify-between text-sm"><b>${n}</b><span>Lvl ${qp.level}</span></div>
        <div class="w-full bg-gray-200 rounded h-2 mt-1">
          <div class="h-2 rounded" style="width:${pct}%; background:#10b981;"></div>
        </div>
        <div class="text-[10px] mt-1 text-slate-600">${qp.xp}/${need} XP</div>
      </div>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-emerald-50">
      <h3 class="font-bold">üìò Quest-Level √úbersicht</h3>
      <div class="grid gap-2 mt-2">${rows || `<div class="text-sm text-slate-500">Keine Quests gefunden</div>`}</div>
    </div>
  `;
}

// ====== Hook in renderAll: daily decay + UI refresh ======
(function hookRenderAllForQuestLevels(){
  if(typeof renderAll==="function" && !renderAll.__questHooked){
    const __old = renderAll;
    renderAll = function(){
      // 1) t√§glichen Verfall einmal/Tag anwenden
      applyDailyQuestDecay();
      // 2) Normal rendern
      __old();
      // 3) Level-UI aktualisieren
      renderQuestLevelsDashboardCard();
      renderQuestLevelsPanel();
    };
    renderAll.__questHooked = true;
  }else{
    // Fallback beim ersten Laden
    applyDailyQuestDecay();
    renderQuestLevelsDashboardCard();
    renderQuestLevelsPanel();
  }
})();
</script>
<!-- ===== End Part 6 ===== -->
<!-- ===== Part 7: Kategorien (Zuweisung, Totals, Editor) ===== -->
<script>
// ===== State / Defaults =====
state.categories = state.categories || [
  {id:"sport",     name:"Sport",                 type:"normal"},
  {id:"handwerk",  name:"Handwerk",              type:"normal"},
  {id:"haushalt",  name:"Haushalt",              type:"normal"},
  {id:"ernaehrung",name:"Ern√§hrung",             type:"normal"},
  {id:"lernen",    name:"Lernen",                type:"normal"},
  {id:"neg",       name:"Schlechter Lebensstil", type:"negative", penaltyMultiplier:2}
];
state.questCategories = state.questCategories || {}; // { "Questname": "categoryId" }

// ===== Utils =====
function catById(id){ return (state.categories||[]).find(c=>c.id===id); }
function slugId(s){
  return (s||"").toLowerCase()
    .replace(/[√§]/g,"ae").replace(/[√∂]/g,"oe").replace(/[√º]/g,"ue").replace(/[√ü]/g,"ss")
    .replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"").slice(0,24) || ("cat"+Math.random().toString(36).slice(2,7));
}

// Beim Log-Eintrag Kategorie-Infos anheften (catId, catPoints)
function annotateLogCategory(e){
  if(!e || !e.quest) return;
  const catId = state.questCategories[e.quest] || null;
  if(catId){
    e.catId = catId;
    // catPoints = Basis-Punkte (f√ºr Kategorien-Summen immer positiv z√§hlen)
    const base = (typeof e.base === "number" ? e.base : Math.max(0, Number(e.points)||0));
    e.catPoints = Math.max(0, base|0);
  }
}

// processMessage/Level-Hook schon vorhanden ‚Üí davor cat annotieren
if(typeof processQuestLevelOnLogEntry === "function"){
  const __oldPQL = processQuestLevelOnLogEntry;
  processQuestLevelOnLogEntry = function(e){
    annotateLogCategory(e);
    __oldPQL(e);
  };
}

// Fallback: falls keine Hook-Kette existiert (sehr unwahrscheinlich nach Part 6)
if(!state.__wrapCatPush){
  state.__wrapCatPush = true;
  const origPush = state.log.push;
  state.log.push = function(...args){
    args.forEach(annotateLogCategory);
    const r = origPush.apply(this,args);
    renderCategoriesCard();
    renderCatalogWithCategories(); // sichert, dass Zuweisungen sichtbar bleiben
    return r;
  };
}

// ===== Category Totals (live aus Log) =====
function getCategoryTotals(){
  const totals = {};
  (state.log||[]).forEach(e=>{
    if(e && e.catId){
      totals[e.catId] = (totals[e.catId]||0) + (Number(e.catPoints)||0);
    }
  });
  // sichere, dass alle Kategorien vorkommen (0 anzeigen)
  (state.categories||[]).forEach(c=>{
    if(!(c.id in totals)) totals[c.id]=0;
  });
  return totals;
}

// ===== Dashboard-Karte: Kategorien =====
function renderCategoriesCard(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let box = document.getElementById("categoriesCard");
  if(!box){
    box = document.createElement("div");
    box.id = "categoriesCard";
    host.appendChild(box);
  }

  const totals = getCategoryTotals();
  const order = [...state.categories].sort((a,b)=> (totals[b.id]||0) - (totals[a.id]||0));

  const rows = order.map(c=>{
    const sum = totals[c.id]||0;
    return `
      <div class="p-2 border rounded bg-white flex items-center justify-between">
        <div class="flex items-center gap-2">
          <span class="text-sm ${c.type==="negative"?"text-red-600":""}">${c.name}</span>
          <span class="text-[10px] px-2 py-[2px] rounded border ${c.type==="negative"?"border-red-300 text-red-700 bg-red-50":"border-slate-300 text-slate-600 bg-slate-50"}">
            ${c.type==="negative"?"Negativ":"Normal"}
          </span>
        </div>
        <div class="text-sm font-semibold ${c.type==="negative"?"text-red-700":"text-emerald-700"}">${sum} Pkt</div>
      </div>`;
  }).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded ${order.length?"bg-sky-50":"bg-slate-50"}">
      <h3 class="font-bold">üóÇÔ∏è Kategorien</h3>
      <div class="grid gap-2 mt-2">
        ${rows || `<div class="text-sm text-slate-500">Noch keine Kategoriendaten</div>`}
      </div>
    </div>
  `;
}

// ===== Katalog: Zeilen mit Kategorie-Dropdown rendern =====
// Wir √ºbernehmen das Rendern der Listeneintr√§ge und behalten ‚ÄûL√∂schen‚Äú & ‚Äû+ Timed Quest‚Äú-Button bei.
function renderCatalogWithCategories(){
  const list = document.getElementById("catalogList");
  if(!list) return;

  // (1) Zeilen mit Kategorie-Dropdown
  const rows = (state.catalog||[]).map((q,i)=>{
    const catId = state.questCategories[q.name] || "";
    const opts = [`<option value="">‚Äì Kategorie ‚Äì</option>`]
      .concat(state.categories.map(c=>`<option value="${c.id}" ${c.id===catId?"selected":""}>${c.name}</option>`))
      .join("");
    return `
      <div class="p-2 border rounded flex flex-col gap-2 ${q.boss?'bg-yellow-50':'bg-white'}" data-row="${i}">
        <div class="flex items-center justify-between">
          <span>${q.boss?'üëë':''} ${q.name} (+${q.points} Punkte)</span>
          <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
        </div>
        <div class="flex items-center gap-2">
          <label class="text-[12px] text-slate-600">Kategorie:</label>
          <select class="input text-xs py-1 px-2 h-8" data-cat="${i}">
            ${opts}
          </select>
        </div>
      </div>`;
  }).join("");

  // (2) + Timed Quest Button behalten
  const timedBtn = `
    <button id="catTimedBtn" class="btn w-full bg-purple-600 text-white mt-2">+ Timed Quest</button>
  `;

  list.innerHTML = rows + timedBtn;

  // Events: L√∂schen
  list.querySelectorAll("[data-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const idx = Number(btn.getAttribute("data-del"));
      state.catalog.splice(idx,1);
      save(); renderAll();
    });
  });

  // Events: Kategorie w√§hlen
  list.querySelectorAll("[data-cat]").forEach(sel=>{
    sel.addEventListener("change",()=>{
      const idx = Number(sel.getAttribute("data-cat"));
      const q = state.catalog[idx];
      const val = sel.value || "";
      if(q){
        if(val) state.questCategories[q.name] = val;
        else delete state.questCategories[q.name];
        save();
        renderCategoriesCard();
      }
    });
  });

  // Timed Quest
  const addBtn = document.getElementById("catTimedBtn");
  if(addBtn && typeof addTimedQuest === "function"){
    addBtn.addEventListener("click", addTimedQuest);
  }
}

// ===== Settings: einfacher Kategorie-Editor anh√§ngen =====
(function hookSettingsForCategories(){
  if(typeof renderSettings === "function" && !renderSettings.__catHooked){
    const __old = renderSettings;
    renderSettings = function(){
      __old();

      const host = document.getElementById("tab-settings");
      if(!host) return;

      let box = document.getElementById("catManager");
      if(!box){
        box = document.createElement("div");
        box.id = "catManager";
        host.appendChild(box);
      }

      const rows = (state.categories||[]).map((c,i)=>`
        <div class="grid grid-cols-4 gap-2 items-center">
          <input class="input text-sm" data-ck="name" data-ci="${i}" value="${c.name}">
          <select class="input text-sm" data-ck="type" data-ci="${i}">
            <option value="normal"   ${c.type==="normal"?"selected":""}>Normal</option>
            <option value="negative" ${c.type==="negative"?"selected":""}>Negativ</option>
          </select>
          <input class="input text-sm" data-ck="id" data-ci="${i}" value="${c.id}">
          <button class="btn text-sm" data-cdel="${i}">Entfernen</button>
        </div>
      `).join("");

      box.innerHTML = `
        <div class="space-y-2 mt-4 p-3 border rounded bg-slate-50">
          <h3 class="font-bold">Kategorien verwalten</h3>
          <div class="space-y-2">${rows || `<div class="text-sm text-slate-500">Noch keine Kategorien</div>`}</div>
          <div class="grid grid-cols-4 gap-2 items-center mt-2">
            <input id="catNewName" class="input text-sm" placeholder="Neue Kategorie">
            <select id="catNewType" class="input text-sm">
              <option value="normal">Normal</option>
              <option value="negative">Negativ</option>
            </select>
            <button id="catAddBtn" class="btn">+ Hinzuf√ºgen</button>
          </div>
        </div>
      `;

      // Change Handler
      box.querySelectorAll("[data-ck]").forEach(inp=>{
        inp.addEventListener("change",()=>{
          const i  = Number(inp.getAttribute("data-ci"));
          const ck = inp.getAttribute("data-ck");
          let  v   = inp.value;
          if(!state.categories[i]) return;
          state.categories[i][ck] = v;
          save();
          renderCategoriesCard();
          renderCatalogWithCategories();
        });
      });

      // Entfernen
      box.querySelectorAll("[data-cdel]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i = Number(btn.getAttribute("data-cdel"));
          const removed = state.categories.splice(i,1)[0];
          // Zuweisungen, die auf diese ID zeigen, entfernen
          if(removed){
            Object.keys(state.questCategories||{}).forEach(q=>{
              if(state.questCategories[q] === removed.id) delete state.questCategories[q];
            });
          }
          save();
          renderAll();
        });
      });

      // Hinzuf√ºgen
      const addBtn = document.getElementById("catAddBtn");
      const nameIn = document.getElementById("catNewName");
      const typeIn = document.getElementById("catNewType");
      if(addBtn){
        addBtn.addEventListener("click",()=>{
          const nm = (nameIn.value||"").trim();
          if(!nm) return;
          const tp = typeIn.value==="negative" ? "negative" : "normal";
          const id = slugId(nm);
          if(state.categories.find(c=>c.id===id)){
            alert("ID existiert bereits, bitte anderen Namen w√§hlen.");
            return;
          }
          state.categories.push({id,name:nm,type:tp});
          nameIn.value="";
          save(); renderAll();
        });
      }
    };
    renderSettings.__catHooked = true;
  }
})();

// ===== Hook in renderAll: Kategorien-Karte + Katalog-Controls sicher rendern =====
(function hookRenderAllForCategories(){
  if(typeof renderAll==="function" && !renderAll.__catCardHooked){
    const __old = renderAll;
    renderAll = function(){
      __old();
      renderCategoriesCard();
      renderCatalogWithCategories();
    };
    renderAll.__catCardHooked = true;
  }else{
    // Fallback falls renderAll noch nicht existiert
    renderCategoriesCard();
    renderCatalogWithCategories();
  }
})();
</script>
<!-- ===== End Part 7 ===== -->
<!-- ===== Part 8: Negative Kategorien + Kategorie-Verkn√ºpfungen ===== -->
<script>
// Defaults erg√§nzen (keine √úberschreibung vorhandener Werte)
state.categories = state.categories || [
  {id:"sport",     name:"Sport",                 type:"normal"},
  {id:"handwerk",  name:"Handwerk",              type:"normal"},
  {id:"haushalt",  name:"Haushalt",              type:"normal"},
  {id:"ernaehrung",name:"Ern√§hrung",             type:"normal"},
  {id:"lernen",    name:"Lernen",                type:"normal"},
  {id:"neg",       name:"Schlechter Lebensstil", type:"negative", penaltyMultiplier:2}
];
state.questCategories = state.questCategories || {};
// Beispiel-Verkn√ºpfung (nur Kategoriepunkte, kein globaler Bonus)
state.categoryLinks = state.categoryLinks || [
  // +20% von Handwerk z√§hlen zus√§tzlich bei Sport
  {from:"handwerk", to:"sport", kind:"percent", value:0.2}
];

// ===== Hilfen =====
function catById8(id){ return (state.categories||[]).find(c=>c.id===id); }
function todayISO8(){ return (typeof todayISO==="function") ? todayISO() : new Date().toISOString().slice(0,10); }

// ===== Negative Kategorien: globale Strafe automatisch buchen =====
// Wir h√§ngen uns an state.log.push, erzeugen f√ºr negative Eintr√§ge einen separaten Malus
if(!state.__negWrapInstalled){
  state.__negWrapInstalled = true;
  const __origPush = state.log.push;
  state.log.push = function(...entries){
    // 1) Vor dem eigentlichen Push: nichts
    const res = __origPush.apply(this, entries);

    // 2) F√ºr alle frisch hinzugef√ºgten Eintr√§ge: ggf. Malus buchen
    entries.forEach(e=>{
      if(!e || e.__isAutoPenalty) return;
      const catId = e.catId || (state.questCategories && state.questCategories[e.quest]);
      if(!catId) return;
      const cat = catById8(catId);
      if(!cat || cat.type!=="negative") return;

      // Basis f√ºr die Strafe = catPoints (falls vorhanden), sonst Basis/Points positiv
      const base = (typeof e.catPoints==="number")
        ? e.catPoints
        : (typeof e.base==="number" ? Math.max(0,e.base|0) : Math.max(0,Number(e.points)||0));
      const mult = Number(cat.penaltyMultiplier||2);
      const penalty = -Math.round(base * mult);
      if(!penalty) return;

      // separaten Malus-Eintrag anh√§ngen (ohne weitere Penalty-Kaskade)
      const malus = {
        date: e.date || todayISO8(),
        quest: "Negativ: "+e.quest,
        points: penalty,
        __isAutoPenalty: true // Marker, damit wir nicht erneut strafen
      };
      __origPush.call(this, malus);
    });

    // 3) UI auffrischen (leichtgewichtig)
    try{
      if(typeof renderCategoriesCard==="function") renderCategoriesCard();
    }catch(_){}
    try{
      if(typeof renderAll==="function") renderAll();
    }catch(_){}

    return res;
  };
}

// ===== Kategorie-Summen inkl. Verkn√ºpfungen =====
// Wir √ºberschreiben getCategoryTotals aus Part 7, damit Links einflie√üen.
const __getCategoryTotalsOld = (typeof getCategoryTotals==="function") ? getCategoryTotals : null;
function getCategoryTotals(){
  // Basissummen pro Kategorie (nur catPoints)
  const totals = {};
  (state.categories||[]).forEach(c=>totals[c.id]=0);

  (state.log||[]).forEach(e=>{
    if(e && e.catId){
      const baseCatPoints = Number(e.catPoints||0);
      totals[e.catId] = (totals[e.catId]||0) + baseCatPoints;
    }
  });

  // Links anwenden: f√ºr jeden Log mit catId==from ‚Üí addiere Zuschlag bei to
  const links = state.categoryLinks||[];
  if(links.length){
    (state.log||[]).forEach(e=>{
      if(!e || !e.catId) return;
      const baseCatPoints = Number(e.catPoints||0);
      if(!baseCatPoints) return;

      links.forEach(l=>{
        if(l && l.from===e.catId && l.to && l.to!==l.from){
          const kind  = l.kind||"percent";
          const value = Number(l.value||0);
          let add = 0;
          if(kind==="percent"){
            add = Math.round(baseCatPoints * value);
          }else if(kind==="fixed"){
            add = Math.round(value);
          }
          if(add>0){
            totals[l.to] = (totals[l.to]||0) + add;
          }
        }
      });
    });
  }

  return totals;
}

// ===== Dashboard-Karte aktualisieren (Titelzeile + kleine Link-Info) =====
const __renderCategoriesCardOld = (typeof renderCategoriesCard==="function") ? renderCategoriesCard : null;
function renderCategoriesCard(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let box = document.getElementById("categoriesCard");
  if(!box){
    box = document.createElement("div");
    box.id = "categoriesCard";
    host.appendChild(box);
  }

  const totals = getCategoryTotals();
  const order = [...(state.categories||[])].sort((a,b)=> (totals[b.id]||0) - (totals[a.id]||0));

  const rows = order.map(c=>{
    const sum = totals[c.id]||0;
    return `
      <div class="p-2 border rounded bg-white flex items-center justify-between">
        <div class="flex items-center gap-2">
          <span class="text-sm ${c.type==="negative"?"text-red-600":""}">${c.name}</span>
          <span class="text-[10px] px-2 py-[2px] rounded border ${c.type==="negative"?"border-red-300 text-red-700 bg-red-50":"border-slate-300 text-slate-600 bg-slate-50"}">
            ${c.type==="negative"?"Negativ":"Normal"}
          </span>
        </div>
        <div class="text-sm font-semibold ${c.type==="negative"?"text-red-700":"text-emerald-700"}">${sum} Pkt</div>
      </div>`;
  }).join("");

  // kleine Link-Info
  const linkInfo = (state.categoryLinks && state.categoryLinks.length)
    ? `<div class="text-[11px] text-slate-600 mt-2">
         Verkn√ºpfungen aktiv: ${
           state.categoryLinks.map(l=>{
             const cf = catById8(l.from)?.name || l.from;
             const ct = catById8(l.to)?.name   || l.to;
             const val = (l.kind==="percent") ? Math.round((Number(l.value||0))*100)+"%" : Math.round(Number(l.value||0))+" Pkt";
             return `${cf} ‚Üí ${ct} (+${val} nur Kategorie)`;
           }).join("; ")
         }
       </div>`
    : "";

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-sky-50">
      <h3 class="font-bold">üóÇÔ∏è Kategorien</h3>
      <div class="grid gap-2 mt-2">
        ${rows || `<div class="text-sm text-slate-500">Noch keine Kategoriendaten</div>`}
      </div>
      ${linkInfo}
    </div>
  `;
}

// ===== Einstellungen: Editor f√ºr Kategorie-Verkn√ºpfungen =====
(function hookSettingsForLinks(){
  if(typeof renderSettings==="function" && !renderSettings.__catLinksHooked){
    const __old = renderSettings;
    renderSettings = function(){
      __old();

      const host = document.getElementById("tab-settings");
      if(!host) return;

      let box = document.getElementById("catLinkManager");
      if(!box){
        box = document.createElement("div");
        box.id = "catLinkManager";
        host.appendChild(box);
      }

      const cats = state.categories||[];
      const opts = (sel, val)=> cats.map(c=>`<option value="${c.id}" ${c.id===val?"selected":""}>${c.name}</option>`).join("");

      const rows = (state.categoryLinks||[]).map((l,i)=>`
        <div class="grid grid-cols-7 gap-2 items-center">
          <div class="text-xs text-slate-600">Von</div>
          <select class="input text-sm" data-lk="from" data-li="${i}">${opts("from",l.from)}</select>
          <div class="text-xs text-slate-600">‚Üí</div>
          <select class="input text-sm" data-lk="to" data-li="${i}">${opts("to",l.to)}</select>
          <select class="input text-sm" data-lk="kind" data-li="${i}">
            <option value="percent" ${l.kind==="percent"?"selected":""}>% von Basis</option>
            <option value="fixed"   ${l.kind==="fixed"?"selected":""}>Fixpunkte</option>
          </select>
          <input class="input text-sm" data-lk="value" data-li="${i}" value="${l.value}">
          <button class="btn text-sm" data-ldel="${i}">Entfernen</button>
        </div>
      `).join("");

      box.innerHTML = `
        <div class="space-y-2 mt-4 p-3 border rounded bg-slate-50">
          <h3 class="font-bold">Kategorie-Verkn√ºpfungen</h3>
          <div class="text-xs text-slate-600">Zuschl√§ge wirken <b>nur</b> auf Kategorien-Summen (kein globaler Bonus).</div>
          <div class="space-y-2 mt-2">${rows || `<div class="text-sm text-slate-500">Noch keine Verkn√ºpfungen</div>`}</div>
          <div class="grid grid-cols-7 gap-2 items-center mt-3">
            <div class="text-xs text-slate-600">Von</div>
            <select id="clFrom" class="input text-sm">${opts()}</select>
            <div class="text-xs text-slate-600">‚Üí</div>
            <select id="clTo" class="input text-sm">${opts()}</select>
            <select id="clKind" class="input text-sm">
              <option value="percent" selected>% von Basis</option>
              <option value="fixed">Fixpunkte</option>
            </select>
            <input id="clValue" class="input text-sm" placeholder="z. B. 0.2 oder 5">
            <button id="clAdd" class="btn">+ Hinzuf√ºgen</button>
          </div>
        </div>
      `;

      // √Ñnderungen an bestehenden Links
      box.querySelectorAll("[data-lk]").forEach(el=>{
        el.addEventListener("change",()=>{
          const i = Number(el.getAttribute("data-li"));
          const k = el.getAttribute("data-lk");
          let v = el.value;
          if(!state.categoryLinks[i]) return;
          if(k==="value") v = Number(v);
          state.categoryLinks[i][k] = v;
          save();
          renderCategoriesCard();
        });
      });

      // Entfernen
      box.querySelectorAll("[data-ldel]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i = Number(btn.getAttribute("data-ldel"));
          state.categoryLinks.splice(i,1);
          save(); renderSettings(); renderCategoriesCard();
        });
      });

      // Hinzuf√ºgen
      const addBtn = document.getElementById("clAdd");
      if(addBtn){
        addBtn.addEventListener("click",()=>{
          const from = document.getElementById("clFrom").value;
          const to   = document.getElementById("clTo").value;
          const kind = document.getElementById("clKind").value;
          const val  = Number(document.getElementById("clValue").value||0);
          if(!from || !to || from===to) return alert("Bitte unterschiedliche Kategorien w√§hlen.");
          if(kind==="percent" && (val<=0 || val>2)) return alert("Bitte Prozentwert >0 und ‚â§2 (z. B. 0.2 f√ºr 20%)");
          if(kind==="fixed" && (val<=0 || val>1000)) return alert("Bitte sinnvollen Fixwert >0 angeben.");

          state.categoryLinks.push({from,to,kind,value:val});
          save(); renderSettings(); renderCategoriesCard();
        });
      }
    };
    renderSettings.__catLinksHooked = true;
  }
})();

// ===== RenderAll-Hook sicherstellen =====
(function ensureCatRefreshInRenderAll(){
  if(typeof renderAll==="function" && !renderAll.__catLinksHooked){
    const __old = renderAll;
    renderAll = function(){
      __old();
      if(typeof renderCategoriesCard==="function") renderCategoriesCard();
    };
    renderAll.__catLinksHooked = true;
  }else{
    // Fallback einmalig zeichnen
    if(typeof renderCategoriesCard==="function") renderCategoriesCard();
  }
})();
</script>
<!-- ===== End Part 8 ===== -->
<!-- ===== Part 9: Dynamische Meilensteine ===== -->
<script>
// --- State / Migration ---
state.milestoneState = state.milestoneState || {
  quests: { awarded:{} },         // z.B. {"100":true}
  boss:   { awarded:{} },         // thresholds 10,20,50,100,200...
  missions:{ awarded:{} },        // wird genutzt wenn state.missions vorhanden
  categories:{}                   // {catId:{awarded:{threshold:true}}}
};

// --- Z√§hlfunktionen ---
function ms_countQuests(){
  // z√§hle positive, ‚Äûechte‚Äú Eintr√§ge (keine Auto-Penalties)
  return (state.log||[]).filter(e=>e && !e.__isAutoPenalty && Number(e.points)>0).length;
}
function ms_countBossQuests(){
  const namesBoss = new Set((state.catalog||[]).filter(q=>q.boss).map(q=>q.name));
  return (state.log||[]).filter(e=>e && !e.__isAutoPenalty && namesBoss.has(e.quest)).length;
}
function ms_countMissionsCompleted(){
  // wird aktiv, sobald du Missions-Objekte einf√ºhrst: state.missions=[{... , completed:true}, ...]
  if(!state.missions) return 0;
  return state.missions.filter(m=>m && m.completed).length;
}
function ms_categoryCounts(){
  // z√§hle pro Kategorie die catPoints (als Anzahl-‚ÄûEvents‚Äú, nicht Summe)
  const counts={};
  (state.categories||[]).forEach(c=>counts[c.id]=0);
  (state.log||[]).forEach(e=>{
    if(e && e.catId){
      const inc = (Number(e.catPoints||0)>0) ? 1 : 0; // Ereignis z√§hlen
      counts[e.catId]=(counts[e.catId]||0)+inc;
    }
  });
  return counts;
}

// --- Tier-Definitionen (Schwellen) ---
const MS_TIERS = {
  quests:    [100,200,500,1000,2000,5000,10000],
  boss:      [10,20,50,100,200,500],
  missions:  [5,10,20,50,100,200],
  category:  [50,100,200,500,1000,2000]
};

// --- Rewards ---
function ms_reward(type, threshold, catObj=null){
  // Gro√üe Motivation:
  // - missions/boss:  threshold^2
  // - quests/category: threshold^2 / 100
  // - negative category: gleicher Betrag als Abzug (negativ)
  if(type==="missions" || type==="boss"){
    return Math.round(threshold*threshold);
  }
  if(type==="category"){
    const base = Math.round((threshold*threshold)/100);
    if(catObj && catObj.type==="negative") return -base;
    return base;
  }
  // quests
  return Math.round((threshold*threshold)/100);
}

// --- Helfer: n√§chste(s) Ziel(e) + Fortschritt berechnen ---
function ms_nextTierInfo(current, tiers, awardedMap){
  // gib das ‚Äûn√§chste‚Äú noch nicht vergebene Tier zur√ºck + Fortschritt
  const remaining = tiers.filter(t=>!awardedMap[t]);
  if(remaining.length===0){
    // falls alles vergeben, erweitere dynamisch (verdopple das Gr√∂√üte)
    const maxT = tiers[tiers.length-1]||100;
    const next = maxT*2;
    return {threshold:next, progress: Math.min(1, current/next)};
  }
  const thr = remaining[0];
  return {threshold:thr, progress: Math.min(1, current/thr)};
}

// --- Verleihung pr√ºfen & buchen ---
function ms_award(type, threshold, reward, label){
  // Schon vergeben?
  if(type==="category"){
    // label enth√§lt catId
    const catId = label;
    state.milestoneState.categories[catId] = state.milestoneState.categories[catId] || {awarded:{}};
    if(state.milestoneState.categories[catId].awarded[threshold]) return false;
    state.milestoneState.categories[catId].awarded[threshold]=true;
  }else{
    if(state.milestoneState[type].awarded[threshold]) return false;
    state.milestoneState[type].awarded[threshold]=true;
  }
  // Log schreiben
  state.log.push({
    date: todayISO(),
    quest: (type==="category")
      ? `Meilenstein (Kategorie ${catById(label)?.name||label}): ${threshold}`
      : `Meilenstein (${type}): ${threshold}`,
    points: reward
  });
  save();
  return true;
}

function ms_checkAndAwardAll(){
  if(state.__msAwardLock) return;
  state.__msAwardLock = true;

  try{
    // 1) Quests
    const cq = ms_countQuests();
    const nq = ms_nextTierInfo(cq, MS_TIERS.quests, state.milestoneState.quests.awarded);
    if(cq>=nq.threshold){
      const rw = ms_reward("quests", nq.threshold);
      ms_award("quests", nq.threshold, rw);
    }

    // 2) Boss
    const cb = ms_countBossQuests();
    const nb = ms_nextTierInfo(cb, MS_TIERS.boss, state.milestoneState.boss.awarded);
    if(cb>=nb.threshold){
      const rw = ms_reward("boss", nb.threshold);
      ms_award("boss", nb.threshold, rw);
    }

    // 3) Missionen (nur wenn vorhanden)
    const cm = ms_countMissionsCompleted();
    const nm = ms_nextTierInfo(cm, MS_TIERS.missions, state.milestoneState.missions.awarded);
    if(cm>=nm.threshold){
      const rw = ms_reward("missions", nm.threshold);
      ms_award("missions", nm.threshold, rw);
    }

    // 4) Kategorien
    const kc = ms_categoryCounts();
    (state.categories||[]).forEach(cat=>{
      state.milestoneState.categories[cat.id]=state.milestoneState.categories[cat.id]||{awarded:{}};
      const awarded = state.milestoneState.categories[cat.id].awarded;
      const ni = ms_nextTierInfo(kc[cat.id]||0, MS_TIERS.category, awarded);
      if((kc[cat.id]||0)>=ni.threshold){
        const rw = ms_reward("category", ni.threshold, cat);
        ms_award("category", ni.threshold, rw, cat.id);
      }
    });

    save();
  }finally{
    state.__msAwardLock = false;
  }
}

// --- Dashboard Renderer (ersetzt altes renderMilestones) ---
function ms_progressBar(p){
  const pct = Math.round((p||0)*100);
  return `
    <div class="w-full h-2 bg-slate-200 rounded">
      <div class="h-2 bg-blue-500 rounded" style="width:${pct}%"></div>
    </div>
    <div class="text-[11px] text-slate-600 mt-1">${pct}%</div>
  `;
}

function renderMilestones(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  // Auto-vergabe vor Anzeige
  ms_checkAndAwardAll();

  // Daten
  const cq = ms_countQuests();
  const cb = ms_countBossQuests();
  const cm = ms_countMissionsCompleted();
  const kc = ms_categoryCounts();

  const nq = ms_nextTierInfo(cq, MS_TIERS.quests, state.milestoneState.quests.awarded);
  const nb = ms_nextTierInfo(cb, MS_TIERS.boss,   state.milestoneState.boss.awarded);
  const nm = ms_nextTierInfo(cm, MS_TIERS.missions,state.milestoneState.missions.awarded);

  // Kategorien: sortiere nach (Fortschritt zum n√§chsten Threshold)
  const catRows = (state.categories||[]).map(cat=>{
    const count = kc[cat.id]||0;
    const awarded = (state.milestoneState.categories[cat.id]||{awarded:{}}).awarded;
    const ni = ms_nextTierInfo(count, MS_TIERS.category, awarded);
    const reward = ms_reward("category", ni.threshold, cat);
    return {
      cat,
      count,
      next: ni.threshold,
      progress: Math.min(1, count/ni.threshold),
      reward
    };
  }).sort((a,b)=> (b.progress - a.progress)).slice(0,4);

  // Box erstellen/aktualisieren
  let box = document.getElementById("milestonesCard");
  if(!box){
    box = document.createElement("div");
    box.id = "milestonesCard";
    host.appendChild(box);
  }

  const questsBlock = `
    <div class="p-3 border rounded bg-white">
      <div class="flex items-center justify-between">
        <h4 class="font-semibold">Quests</h4>
        <div class="text-xs text-slate-600">N√§chster: ${nq.threshold} (Reward: ${ms_reward("quests",nq.threshold)} Pkt)</div>
      </div>
      <div class="mt-1 text-sm">${cq} / ${nq.threshold}</div>
      ${ms_progressBar(Math.min(1,cq/nq.threshold))}
    </div>
  `;
  const bossBlock = `
    <div class="p-3 border rounded bg-white">
      <div class="flex items-center justify-between">
        <h4 class="font-semibold">Bossquests</h4>
        <div class="text-xs text-slate-600">N√§chster: ${nb.threshold} (Reward: ${ms_reward("boss",nb.threshold)} Pkt)</div>
      </div>
      <div class="mt-1 text-sm">${cb} / ${nb.threshold}</div>
      ${ms_progressBar(Math.min(1,cb/nb.threshold))}
    </div>
  `;
  const missBlock = `
    <div class="p-3 border rounded bg-white">
      <div class="flex items-center justify-between">
        <h4 class="font-semibold">Missionen</h4>
        <div class="text-xs text-slate-600">N√§chster: ${nm.threshold} (Reward: ${ms_reward("missions",nm.threshold)} Pkt)</div>
      </div>
      <div class="mt-1 text-sm">${cm} / ${nm.threshold}</div>
      ${ms_progressBar(Math.min(1,cm/nm.threshold))}
      ${!state.missions?`<div class="text-[11px] text-slate-500 mt-1">Hinweis: Missionen sind noch nicht aktiviert.</div>`:""}
    </div>
  `;

  const catsBlock = `
    <div class="p-3 border rounded bg-white">
      <h4 class="font-semibold">Kategorien</h4>
      <div class="grid gap-2 mt-2">
        ${
          catRows.map(r=>`
            <div class="p-2 border rounded ${r.cat.type==="negative"?"bg-red-50":"bg-emerald-50"}">
              <div class="flex items-center justify-between">
                <div class="text-sm">
                  ${r.cat.name}
                  <span class="text-[10px] ml-2 px-2 py-[2px] rounded border ${r.cat.type==="negative"?"border-red-300 text-red-700 bg-red-50":"border-emerald-300 text-emerald-700 bg-emerald-50"}">
                    ${r.cat.type==="negative"?"Negativ":"Normal"}
                  </span>
                </div>
                <div class="text-xs ${r.cat.type==="negative"?"text-red-700":"text-emerald-700"}">
                  N√§chster: ${r.next} (${r.cat.type==="negative"?"Abzug":"Reward"}: ${r.reward} Pkt)
                </div>
              </div>
              <div class="mt-1 text-sm">${r.count} / ${r.next}</div>
              ${ms_progressBar(r.progress)}
            </div>
          `).join("")
        }
      </div>
    </div>
  `;

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-orange-50">
      <h3 class="font-bold">üéØ Meilensteine</h3>
      <div class="grid gap-3 mt-2">
        ${questsBlock}
        ${bossBlock}
        ${missBlock}
        ${catsBlock}
      </div>
    </div>
  `;
}

// --- Hook ins Dashboard (ersetzt evtl. √§ltere Hook-Versionen) ---
(function hookMilestonesIntoDashboard(){
  if(!renderDashboard.__msHooked){
    const __old = renderDashboard;
    renderDashboard = function(){
      __old();
      renderMilestones();
    };
    renderDashboard.__msHooked = true;
  }
})();

// --- Nach jedem Render/Push pr√ºfen ---
(function hookAfterRenderAll(){
  if(typeof renderAll==="function" && !renderAll.__msHooked){
    const __old = renderAll;
    renderAll = function(){
      __old();
      ms_checkAndAwardAll();
      renderMilestones();
    };
    renderAll.__msHooked = true;
  }else{
    // Fallback beim Laden
    ms_checkAndAwardAll();
  }
})();
</script>
<!-- ===== End Part 9 ===== -->
/* ===== Part 10: Mission-Chains mit Alternativen & 4√ó Bonus ===== */

/* ‚Äî Helpers / Migration ‚Äî */
if(!state.categories){
  // Sanfte Defaults, falls Kategorien noch nicht existieren
  state.categories = [
    {id:"sport",     name:"Sport",              type:"normal"},
    {id:"handwerk",  name:"Handwerk",           type:"normal"},
    {id:"lifestyle-",name:"Schlechter Lebensstil", type:"negative"}
  ];
  save();
}
if(!window.catById){
  window.catById = function(id){
    return (state.categories||[]).find(c=>c.id===id) || null;
  };
}

/* Missions-Struktur:
  {
    id: "m1",
    name: "Wohnzimmer fertig machen",
    steps: [
      {id:"1",   title:"Leisten anbringen", points:20, catId:"handwerk", prereqAll:[], prereqAny:[]},
      {id:"2.0", title:"Wand streichen",    points:20, catId:"handwerk", prereqAll:["1"]},
      {id:"2.1", title:"Lampen anbringen",  points:20, catId:"handwerk", prereqAll:["1"]},
      {id:"3",   title:"Finales Putzen",    points:10, catId:"handwerk", prereqAny:["2.0","2.1"]}
    ],
    requiredSets: [["1"],["2.0","2.1"],["3"]], // in jedem Set muss mind. 1 erledigt sein
    done: [],               // Array von Step-IDs
    completed: false,
    bonusGiven: false
  }
*/
state.missions = state.missions || [];

// Beispielmission automatisch einmalig anlegen (falls noch nichts existiert)
(function ensureSampleMission(){
  if(state.missions.length>0) return;
  state.missions.push({
    id:"m_wohnzimmer",
    name:"Wohnzimmer fertig machen",
    steps:[
      {id:"1",   title:"Leisten an die Wand bringen", points:20, catId:"handwerk", prereqAll:[]},
      {id:"2.0", title:"Wand streichen",              points:20, catId:"handwerk", prereqAll:["1"]},
      {id:"2.1", title:"Lampen anbringen",            points:20, catId:"handwerk", prereqAll:["1"]},
      {id:"3",   title:"Finales Putzen",              points:10, catId:"handwerk", prereqAny:["2.0","2.1"]}
    ],
    requiredSets:[["1"],["2.0","2.1"],["3"]],
    done:[],
    completed:false,
    bonusGiven:false
  });
  save();
})();

/* ‚Äî Mission-Logik ‚Äî */
function msn_getMission(mid){ return (state.missions||[]).find(m=>m.id===mid); }
function msn_isStepDone(m,sid){ return (m.done||[]).includes(sid); }
function msn_stepById(m,sid){ return (m.steps||[]).find(s=>s.id===sid); }

function msn_stepUnlocked(m, step){
  const done = new Set(m.done||[]);
  const all = step.prereqAll||[];
  const any = step.prereqAny||[];
  // alle aus prereqAll m√ºssen erledigt sein
  if(all.length>0 && !all.every(id=>done.has(id))) return false;
  // mind. eins aus prereqAny (falls definiert)
  if(any && any.length>0 && !any.some(id=>done.has(id))) return false;
  return true;
}

function msn_requiredSetsSatisfied(m){
  const done = new Set(m.done||[]);
  const sets = m.requiredSets||[];
  if(sets.length===0) return false;
  return sets.every(group => group.some(id=>done.has(id)));
}

function msn_sumBasePoints(m){
  return (m.steps||[])
    .filter(s=>m.done.includes(s.id))
    .reduce((sum,s)=>sum + Number(s.points||0), 0);
}

function msn_completeStep(mid, sid){
  const m = msn_getMission(mid);
  if(!m) return;
  if(msn_isStepDone(m,sid)) return;

  const st = msn_stepById(m,sid);
  if(!st) return;
  if(!msn_stepUnlocked(m, st)) return;

  // Log f√ºr den Schritt
  const d = todayISO();
  const base = Number(st.points||0);
  const pts = computePoints(base, d);  // greift deine gesamte Punkte-Logik inkl. Streak/Perks
  const logEntry = {
    date:d,
    quest:`Mission ${m.name}: ${st.title}`,
    points:pts
  };
  // Kategorie-Felder setzen, damit Kategorien/Meilensteine mitlaufen
  if(st.catId){
    logEntry.catId = st.catId;
    logEntry.catPoints = base; // Basiswert f√ºr Kategorie-Z√§hler
  }

  state.log.push(logEntry);
  m.done.push(sid);
  save();
  renderAll();

  // Abschluss pr√ºfen
  if(!m.completed && msn_requiredSetsSatisfied(m)){
    m.completed = true;
    if(!m.bonusGiven){
      const bonusBase = msn_sumBasePoints(m);
      const bonus = Math.round(bonusBase * 4); // 4√ó Mission-Bonus (wie gefordert)
      state.log.push({
        date: todayISO(),
        quest:`Mission abgeschlossen: ${m.name}`,
        points: bonus
      });
      m.bonusGiven = true;
      save();
      renderAll();
    }
  }
}

/* ‚Äî Dashboard-Renderer ‚Äî */
function msn_progressSets(m){
  const sets = m.requiredSets||[];
  const done = new Set(m.done||[]);
  const doneSets = sets.filter(group => group.some(id=>done.has(id))).length;
  return {done:doneSets, total:sets.length, pct: sets.length? Math.min(1, doneSets/sets.length) : 0};
}

function msn_unlockedOpenSteps(m){
  return (m.steps||[]).filter(s => !msn_isStepDone(m,s.id) && msn_stepUnlocked(m,s));
}

function msn_progressBar(p){
  const pct = Math.round(p*100);
  return `
    <div class="w-full h-2 bg-slate-200 rounded">
      <div class="h-2 bg-indigo-500 rounded" style="width:${pct}%"></div>
    </div>
    <div class="text-[11px] text-slate-600 mt-1">${pct}%</div>
  `;
}

function renderMissions(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  // Box erzeugen/holen
  let box = document.getElementById("missionsCard");
  if(!box){
    box = document.createElement("div");
    box.id = "missionsCard";
    host.appendChild(box);
  }

  if(!state.missions || state.missions.length===0){
    box.innerHTML = `
      <div class="mt-4 p-3 border rounded bg-white">
        <h3 class="font-bold">üó∫Ô∏è Missionen</h3>
        <div class="text-sm text-slate-500 mt-1">Noch keine Missionen angelegt.</div>
      </div>
    `;
    return;
  }

  // Sortierung: unvollendete zuerst, dann nach Fortschritt
  const missionsSorted = [...state.missions].sort((a,b)=>{
    if(a.completed!==b.completed) return a.completed?1:-1;
    const pa = msn_progressSets(a).pct, pb = msn_progressSets(b).pct;
    return pb - pa;
  });

  const items = missionsSorted.map(m=>{
    const pr = msn_progressSets(m);
    const unlocked = msn_unlockedOpenSteps(m);

    const stepsHtml = unlocked.length>0
      ? `<div class="mt-2 grid gap-2">
          ${unlocked.map(s=>`
            <button class="btn text-left" data-msn="${m.id}" data-step="${s.id}">
              ‚ûï ${s.title} (+${s.points} Pkt) ${s.catId?`<span class="text-[10px] ml-1 px-2 py-[1px] rounded border border-slate-300">Kategorie: ${catById(s.catId)?.name||s.catId}</span>`:""}
            </button>
          `).join("")}
        </div>`
      : `<div class="mt-2 text-[12px] text-slate-500">${m.completed?"‚úÖ Mission abgeschlossen":"Keine Schritte verf√ºgbar ‚Äì erf√ºlle Voraussetzungen."}</div>`;

    return `
      <div class="p-3 border rounded bg-white">
        <div class="flex items-center justify-between">
          <div class="font-semibold">${m.name}</div>
          <div class="text-xs ${m.completed?"text-green-700":"text-slate-600"}">
            ${m.completed?"Fertig":"Fortschritt"}: ${pr.done}/${pr.total}
          </div>
        </div>
        <div class="mt-1">${msn_progressBar(pr.pct)}</div>
        ${stepsHtml}
        ${m.completed && m.bonusGiven ? `<div class="mt-2 text-[12px] text-emerald-700">üéâ Abschlussbonus verbucht (4√ó Summe der Schritte)</div>`:""}
      </div>
    `;
  }).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-indigo-50">
      <h3 class="font-bold">üó∫Ô∏è Missionen</h3>
      <div class="grid gap-3 mt-2">
        ${items}
      </div>
    </div>
  `;

  // Click-Handler f√ºr ‚ÄûSchritt erledigen‚Äú
  box.querySelectorAll("[data-msn][data-step]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      msn_completeStep(btn.getAttribute("data-msn"), btn.getAttribute("data-step"));
    });
  });
}

/* ‚Äî Hooks (sanft, nur 1√ó anh√§ngen) ‚Äî */
(function hookMissionsIntoDashboard(){
  if(!renderDashboard.__msnHooked){
    const __old = renderDashboard;
    renderDashboard = function(){
      __old();
      renderMissions();
    };
    renderDashboard.__msnHooked = true;
  }
})();
(function hookMissionsIntoRenderAll(){
  if(typeof renderAll==="function" && !renderAll.__msnHooked){
    const __old = renderAll;
    renderAll = function(){
      __old();
      renderMissions();
    };
    renderAll.__msnHooked = true;
  }else{
    // Fallback beim Laden
    renderMissions();
  }
})();

/* ===== End Part 10 ===== */
/* ===== Part 11: Kategorien-Overview, Umkategorisieren & Links ===== */

/* --- Basismigration / Defaults (sanft) --- */
state.categories = state.categories || [
  {id:"sport",    name:"Sport",               type:"normal"},
  {id:"handwerk", name:"Handwerk",            type:"normal"},
  {id:"lifestyle-", name:"Schlechter Lebensstil", type:"negative"}
];
state.catLinks = state.catLinks || []; // {from,to,factor}
(function ensureDefaultLink(){
  // Nur setzen, wenn sinnvoll und noch nicht vorhanden
  const has = state.catLinks.some(l=>l.from==="handwerk" && l.to==="sport");
  const hasCats = state.categories.find(c=>c.id==="handwerk") && state.categories.find(c=>c.id==="sport");
  if(!has && hasCats){
    state.catLinks.push({from:"handwerk", to:"sport", factor:0.25}); // nur Kategorie-Punkte, keine globalen Punkte
    save();
  }
})();

window.catById = window.catById || function(id){
  return (state.categories||[]).find(c=>c.id===id) || null;
};

/* --- Katalog-Felder sicherstellen --- */
(function normalizeCatalog(){
  state.catalog = state.catalog || [];
  state.catalog.forEach(q=>{
    if(q.catId===undefined) q.catId=null;
    if(q.negPenalty===undefined) q.negPenalty=null; // nur relevant, falls Kategorie 'negative'
  });
  save();
})();

/* --- Helfer --- */
function catalogByName(name){
  return (state.catalog||[]).find(q=>q.name===name) || null;
}
function catOfQuest(name){
  const q = catalogByName(name);
  return q && q.catId ? q.catId : null;
}
function isNegativeCat(catId){
  const c = catById(catId);
  return !!(c && c.type==="negative");
}

/* --- Kategorie-Zusatzpunkte (nur Kategorie, nicht global) √ºber Links verbuchen --- */
function applyCategoryLinks(srcCatId, baseCatPoints){
  if(!srcCatId || !baseCatPoints) return;
  (state.catLinks||[]).forEach(link=>{
    if(link.from===srcCatId){
      const add = Math.max(0, Math.round(baseCatPoints * (Number(link.factor)||0)));
      if(add>0){
        state.log.push({
          date: todayISO(),
          quest: `[CatLink] ${link.from} ‚Üí ${link.to}`,
          points: 0,          // kein globaler Einfluss
          catId: link.to,     // wirkt nur auf Zielkategorie
          catPoints: add,     // reine Kategorie-Punkte
          hidden: true        // in der Log-Liste ausblenden
        });
      }
    }
  });
}

/* --- Letzten Log-Eintrag kategorisieren / negative Logik anwenden --- */
function categorizeLastLogEntry(){
  if(!state.log.length) return;
  const e = state.log[state.log.length-1];

  // schon kategorisiert? dann nur Links pr√ºfen
  if(e.catId){
    const baseCatPts = Number(e.catPoints || e.base || (e.points>0?e.points:0));
    applyCategoryLinks(e.catId, baseCatPts);
    return;
  }

  // Mission-Schritte haben catId bereits im Part 10 gesetzt -> nichts tun
  if(e.quest && e.quest.startsWith("Mission ")) {
    return; // Missions-Logs aus Part 10 sind schon korrekt annotiert
  }

  // Katalog-Match versuchen
  const q = catalogByName(e.quest);
  const cid = q && q.catId ? q.catId : null;
  if(!cid) return; // keine Kategorie zugeordnet

  // Basispunkte der Kategorie bestimmen (immer ohne Streak/Perks), bevorzugt aus Katalog
  const baseCatPts = Number(
    (q && q.points) ||
    e.base ||
    (e.points>0 ? e.points : 0)
  ) || 0;

  // Negative Kategorie: globale Punkte ggf. negativ √ºberschreiben
  if(isNegativeCat(cid)){
    const penalty = q && q.negPenalty ? Number(q.negPenalty) : Math.max(0, baseCatPts*2); // Default: 2√ó
    e.points = -Math.abs(penalty); // globaler Abzug
    e.quest = e.quest.includes("(Negativ)") ? e.quest : e.quest+" (Negativ)";
    e.catId = cid;
    e.catPoints = Math.abs(baseCatPts); // Kategorie z√§hlt positiv
    save();
    applyCategoryLinks(cid, e.catPoints);
    return;
  }

  // Normale Kategorie
  e.catId = cid;
  e.catPoints = Math.max(0, baseCatPts);
  save();
  applyCategoryLinks(cid, e.catPoints);
}

/* --- addLog final hooken (nach allen bestehenden Wraps) --- */
(function hookAddLogForCategories(){
  if(addLog && !addLog.__catHooked){
    const __old = addLog;
    addLog = function(){
      const before = state.log.length;
      __old();
      if(state.log.length>before){
        categorizeLastLogEntry();
      }
    };
    addLog.__catHooked = true;
  }
})();

/* --- Log-Renderer √ºberschreiben: versteckte Eintr√§ge ausblenden + Kategorie-Badges --- */
(function hookRenderLogHideHidden(){
  if(renderLog && !renderLog.__catHooked){
    const __old = renderLog;
    renderLog = function(){
      // Eigene Darstellung baut Liste vollst√§ndig (inkl. Malus-/Negativ-Markierung)
      const host = document.getElementById("tab-log");
      if(!host){ __old(); return; }

      // Kopfbereich (Form) nach Original lassen ‚Äì durch __old initialisiert
      __old();

      // Danach eigene Liste setzen
      const list = document.getElementById("logList");
      if(!list) return;
      const visible = (state.log||[]).filter(e=>!e.hidden);
      list.innerHTML = visible.length
        ? visible.map(e=>{
            const neg = e.points<0;
            const badge = e.catId ? `<span class="ml-2 text-[10px] px-2 py-[1px] rounded border ${isNegativeCat(e.catId)?'border-red-300 text-red-700':'border-slate-300 text-slate-700'}">Kategorie: ${catById(e.catId)?.name||e.catId}${e.catPoints?` ‚Ä¢ +${e.catPoints}`:""}</span>` : "";
            return `<div class="p-2 border rounded mb-1 ${neg?'bg-red-50':''}">
              ${e.date} ‚Ä¢ ${e.quest} <b>${neg?e.points:`+${e.points}`}</b> ${badge}
            </div>`;
          }).join("")
        : "Noch keine Eintr√§ge.";
    };
    renderLog.__catHooked = true;
  }
})();

/* --- Kategorien-√úbersicht im Dashboard --- */
function catTotals(){
  const totals = {};
  (state.categories||[]).forEach(c=>totals[c.id]={sum:0, today:0, name:c.name, type:c.type});
  (state.log||[]).forEach(e=>{
    if(e.catId && e.catPoints){
      if(!totals[e.catId]) totals[e.catId]={sum:0,today:0,name:e.catId,type:"normal"};
      totals[e.catId].sum += Number(e.catPoints)||0;
      if(e.date===todayISO()) totals[e.catId].today += Number(e.catPoints)||0;
    }
  });
  return totals;
}

function renderCategoryOverview(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let box = document.getElementById("catOverviewCard");
  if(!box){
    box = document.createElement("div");
    box.id = "catOverviewCard";
    host.appendChild(box);
  }

  const totals = catTotals();
  const rows = Object.keys(totals).map(id=>{
    const t = totals[id];
    const tag = t.type==="negative" ? "‚ö†Ô∏è Negativ" : "‚úì";
    return `<div class="p-2 border rounded bg-white">
      <div class="flex items-center justify-between">
        <div class="font-semibold">${t.name} <span class="text-[10px] ml-2 px-2 py-[1px] rounded border ${t.type==='negative'?'border-red-300 text-red-700':'border-slate-300 text-slate-600'}">${tag}</span></div>
        <div class="text-sm">Summe: <b>${t.sum}</b> ‚Ä¢ Heute: <b>${t.today}</b></div>
      </div>
    </div>`;
  }).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üìö Kategorien & Summen</h3>
      <div class="grid gap-2 mt-2">${rows||"<div class='text-sm text-slate-500'>Keine Daten</div>"}</div>
    </div>
  `;
}

/* --- Settings: Kategorie-Editor, Quest-Umsortierung & Links --- */
function renderCategoryEditor(){
  const host = document.getElementById("tab-settings");
  if(!host) return;

  // Box erstellen/ersetzen
  let box = document.getElementById("catEditorBlock");
  if(!box){
    box = document.createElement("div");
    box.id = "catEditorBlock";
    host.appendChild(box);
  }

  const catOptions = (selected)=> (state.categories||[]).map(c=>{
    const sel = c.id===selected ? "selected" : "";
    return `<option value="${c.id}" ${sel}>${c.name}${c.type==="negative"?" (negativ)":""}</option>`;
  }).join("");

  const catRows = (state.catalog||[]).map((q,i)=>`
    <div class="grid grid-cols-5 gap-2 items-center">
      <div class="col-span-2 truncate" title="${q.name}">${q.name}</div>
      <div>${q.points??0} Pkt</div>
      <div>
        <select class="input text-sm" data-q="${i}" data-k="catId">
          <option value="">‚Äî keine ‚Äî</option>
          ${catOptions(q.catId||"")}
        </select>
      </div>
      <div>
        ${isNegativeCat(q.catId) ? `<input class="input text-sm" type="number" step="1" placeholder="Penalty (z. B. 30)" value="${q.negPenalty??''}" data-q="${i}" data-k="negPenalty" />`
                                  : `<input class="input text-sm opacity-60" disabled placeholder="nur f√ºr negativ" />`}
      </div>
    </div>
  `).join("");

  const catList = (state.categories||[]).map((c,i)=>`
    <div class="grid grid-cols-4 gap-2 items-center">
      <input class="input text-sm" value="${c.name}" data-cat="${i}" data-k="name" />
      <input class="input text-sm" value="${c.id}" data-cat="${i}" data-k="id" />
      <select class="input text-sm" data-cat="${i}" data-k="type">
        <option value="normal" ${c.type==="normal"?"selected":""}>normal</option>
        <option value="negative" ${c.type==="negative"?"selected":""}>negativ</option>
      </select>
      <button class="btn text-sm" data-cat-del="${i}">L√∂schen</button>
    </div>
  `).join("");

  const linkRows = (state.catLinks||[]).map((l,i)=>`
    <div class="grid grid-cols-5 gap-2 items-center">
      <div>${catById(l.from)?.name||l.from}</div>
      <div>‚Üí</div>
      <div>${catById(l.to)?.name||l.to}</div>
      <div>Faktor: ${l.factor}</div>
      <button class="btn text-sm" data-link-del="${i}">Entfernen</button>
    </div>
  `).join("");

  box.innerHTML = `
    <div class="mt-6 p-3 border rounded bg-white">
      <h3 class="font-bold">üìö Kategorien verwalten</h3>
      <div class="mt-2 space-y-2">
        ${catList||"<div class='text-sm text-slate-500'>Keine Kategorien</div>"}
        <button id="btnAddCat" class="btn">+ Kategorie</button>
      </div>

      <h4 class="font-bold mt-4">üîó Kategorie-Verkn√ºpfungen (nur Kategorie-Punkte)</h4>
      <div class="mt-2 space-y-2">
        ${linkRows||"<div class='text-sm text-slate-500'>Keine Verkn√ºpfungen</div>"}
        <div class="grid grid-cols-5 gap-2 items-center">
          <select id="catLinkFrom" class="input text-sm">
            ${(state.categories||[]).map(c=>`<option value="${c.id}">${c.name}</option>`).join("")}
          </select>
          <div class="text-center">‚Üí</div>
          <select id="catLinkTo" class="input text-sm">
            ${(state.categories||[]).map(c=>`<option value="${c.id}">${c.name}</option>`).join("")}
          </select>
          <input id="catLinkFactor" class="input text-sm" type="number" step="0.01" min="0" max="1" value="0.25" />
          <button id="btnAddCatLink" class="btn">+ Link</button>
        </div>
      </div>

      <h4 class="font-bold mt-4">üóÇÔ∏è Quests einer Kategorie zuordnen / √§ndern</h4>
      <div class="mt-2 space-y-2">
        <div class="grid grid-cols-5 gap-2 text-xs text-slate-500">
          <div class="col-span-2">Quest</div><div>Punkte</div><div>Kategorie</div><div>Negativ-Penalty</div>
        </div>
        ${catRows||"<div class='text-sm text-slate-500'>Keine Quests im Katalog</div>"}
        <div class="flex gap-2 mt-3">
          <button id="btnReclassify" class="btn">Historie reklassifizieren</button>
          <button id="btnSaveCats" class="btn">Speichern</button>
        </div>
      </div>
    </div>
  `;

  // Bind: Kategorien Felder
  box.querySelectorAll("[data-cat][data-k]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const i = Number(inp.getAttribute("data-cat"));
      const k = inp.getAttribute("data-k");
      let v = inp.value;
      if(k==="type") state.categories[i].type = v;
      else state.categories[i][k] = v.trim();
      save(); renderAll();
    });
  });
  box.querySelectorAll("[data-cat-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const i = Number(btn.getAttribute("data-cat-del"));
      state.categories.splice(i,1); save(); renderAll();
    });
  });
  box.querySelector("#btnAddCat").addEventListener("click",()=>{
    state.categories.push({id:`cat${Date.now()}`, name:"Neue Kategorie", type:"normal"});
    save(); renderAll();
  });

  // Bind: Links
  const btnAddLink = box.querySelector("#btnAddCatLink");
  if(btnAddLink){
    btnAddLink.addEventListener("click",()=>{
      const from = box.querySelector("#catLinkFrom").value;
      const to   = box.querySelector("#catLinkTo").value;
      const f    = Number(box.querySelector("#catLinkFactor").value||0);
      if(!from || !to || from===to) return alert("Bitte unterschiedliche Kategorien w√§hlen.");
      if(state.catLinks.some(l=>l.from===from && l.to===to)) return alert("Link existiert bereits.");
      state.catLinks.push({from,to,factor:f});
      save(); renderAll();
    });
  }
  box.querySelectorAll("[data-link-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const i = Number(btn.getAttribute("data-link-del"));
      state.catLinks.splice(i,1); save(); renderAll();
    });
  });

  // Bind: Katalog-Quest-Kategorie/Negativ-Panelty
  box.querySelectorAll("[data-q][data-k]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const i = Number(inp.getAttribute("data-q"));
      const k = inp.getAttribute("data-k");
      let v = inp.value;
      if(k==="negPenalty") v = v===""?null:Number(v);
      state.catalog[i][k] = v===""?null:v;
      save();
      renderAll(); // damit Negativ-Feld (enable/disable) sofort korrekt ist
    });
  });

  // Speichern (rein formal ‚Äì √Ñnderungen passieren bereits onChange)
  box.querySelector("#btnSaveCats").addEventListener("click",()=>{ save(); alert("Gespeichert."); });

  // Historie reklassifizieren (setzt catId/catPoints, √§ndert global nicht, au√üer bei negativen Kategorien -> wendet Penalty an)
  box.querySelector("#btnReclassify").addEventListener("click",()=>{
    let changed=0;
    (state.log||[]).forEach(e=>{
      const q = catalogByName(e.quest);
      if(!q) return;
      if(!e.catId || e.catId!==q.catId || (isNegativeCat(q.catId) && e.points>=0)){
        // neu etikettieren
        const baseCatPts = Number(q.points || e.base || (e.points>0?e.points:0))||0;
        e.catId = q.catId || null;
        if(e.catId){
          if(isNegativeCat(e.catId)){
            const penalty = q && q.negPenalty ? Number(q.negPenalty) : Math.max(0, baseCatPts*2);
            e.points = -Math.abs(penalty); // global anpassen
            e.catPoints = Math.abs(baseCatPts);
            e.quest = e.quest.includes("(Negativ)")?e.quest:(e.quest+" (Negativ)");
          }else{
            e.catPoints = Math.max(0, baseCatPts);
          }
          changed++;
        }
      }
    });
    save();
    // Links erneut anwenden: wir f√ºgen keine Duplikate hinzu, daher nur beim zuk√ºnftigen Log ‚Äì hier informativ
    alert(`Reklassifikation abgeschlossen. ${changed} Eintr√§ge angepasst.`);
    renderAll();
  });
}

/* --- Hooks in Dashboard & Settings (sanft) --- */
(function hookCategoriesIntoDashboard(){
  if(!renderDashboard.__catOverviewHooked){
    const __old = renderDashboard;
    renderDashboard = function(){
      __old();
      renderCategoryOverview();
    };
    renderDashboard.__catOverviewHooked = true;
  }
})();
(function hookCategoriesIntoSettings(){
  if(!renderSettings.__catEditorHooked){
    const __old = renderSettings;
    renderSettings = function(){
      __old();
      renderCategoryEditor();
    };
    renderSettings.__catEditorHooked = true;
  }else{
    // Fallback, falls Settings bereits gerendert wurde
    renderCategoryEditor();
  }
})();

/* ===== End Part 11 ===== */
/* ===== Part 12: Auto-Milestones (scaling, unlimited) ===== */

/* --- State init (sanft) --- */
state.milestonesAuto = state.milestonesAuto || {
  achieved: {},   // id -> ISO date when awarded
  lost: {},       // id -> ISO date when lost (nur f√ºr ‚Äûloseable‚Äú)
  reduced: {}     // id -> true (wenn nach Verlust mit 1/10 erneut vergeben)
};

/* --- Grund-Helfer --- */
const isoToday = ()=> todayISO();

/* Z√§hle ‚Äûerledigte Quests‚Äú (sichtbar, >0 Punkte, kein Hidden/Tech-Log) */
function countCompletedQuests(){
  return (state.log||[]).filter(e=>{
    if(e.hidden) return false;
    if(e.points<=0) return false;
    const q = (e.quest||"").toLowerCase();
    // Milestone-/System-/Reward-/Event-Logs sollen NICHT z√§hlen
    if(q.startsWith("milestone")) return false;
    if(q.startsWith("[catlink]")) return false;
    if(q.startsWith("event-bonus")) return false;
    if(q.startsWith("reward ")) return false;
    if(q.startsWith("reward-")) return false;
    return true;
  }).length;
}

/* Z√§hle ‚ÄûBossquests erledigt‚Äú */
function countBossQuests(){
  const bossNames = new Set((state.catalog||[]).filter(q=>q.boss).map(q=>q.name));
  return (state.log||[]).filter(e=>{
    if(e.hidden) return false;
    if(e.points<=0) return false;
    return bossNames.has(e.quest);
  }).length;
}

/* Z√§hle ‚ÄûMissionen abgeschlossen‚Äú (robust: √ºber state.missions ODER Log-Text) */
function countMissionsDone(){
  let n=0;
  if(Array.isArray(state.missions)){
    n += state.missions.filter(m=>m.status==="done"||m.done===true||m.completed===true).length;
  }
  // Fallback/erg√§nzend: Log-Eintr√§ge erkennen
  n += (state.log||[]).filter(e=>(e.quest||"").toLowerCase().startsWith("mission abgeschlossen:")).length;
  return n;
}

/* Kategorie-Punkte-Summen (aus Part 11) */
function categoryTotals(){
  const t = {};
  (state.categories||[]).forEach(c=>t[c.id]={sum:0,name:c.name,type:c.type});
  (state.log||[]).forEach(e=>{
    if(e.catId && e.catPoints){
      if(!t[e.catId]) t[e.catId]={sum:0,name:e.catId,type:"normal"};
      t[e.catId].sum += Number(e.catPoints)||0;
    }
  });
  return t;
}

/* --- Skalen / Rewards (gem√§√ü deinen Beispielen) --- */
/* Generiert aufsteigende Schwellen ‚Äûendlos‚Äú */
function seq(...arr){ return arr; }
function growSeq(head, factor, rounds){
  const out=[...head];
  let last = head[head.length-1];
  for(let i=0;i<rounds;i++){
    last = Math.round(last*factor);
    out.push(last);
  }
  return out;
}

/* Beispiele aus deiner Spezifikation abgebildet: 
   - Quests: 100‚Üí100, 200‚Üí400, 500‚Üí2500  ‚áí reward = (thr^2)/100
   - Boss:   10‚Üí100, 20‚Üí400, 50‚Üí2500     ‚áí reward = (thr^2)
   - Mission: 10‚Üí100, 20‚Üí400, 50‚Üí2500    ‚áí reward = (thr^2)  (5 hat dann 25)
   - Kategorien: analog Quests ‚áí reward = (thr^2)/100
   - Streak: z. B. 5,10,20,30,50,100‚Ä¶ ‚áí flacher Reward (z. B. 5*thr), aber ‚Äûloseable‚Äú mit 1/10 beim Wiedererreichen
*/

/* Threshold-Generatoren */
const THR_QUESTS   = [100,200,500,1000,2000,5000,10000,20000,50000];
const THR_BOSS     = [10,20,50,100,200,500,1000,2000];
const THR_MISSIONS = [5,10,20,50,100,200,500,1000];
const THR_STREAK   = [5,10,20,30,50,75,100,150,200];

function rewardQuests(thr){   return Math.round((thr*thr)/100); }   // 100->100, 200->400, 500->2500
function rewardBoss(thr){     return thr*thr; }                     // 10->100, 20->400, 50->2500
function rewardMissions(thr){ return thr*thr; }                     // 5->25, 10->100, 20->400...
function rewardCategory(thr){ return Math.round((thr*thr)/100); }   // analog Quests
function rewardStreak(thr){   return Math.max(10, Math.round(thr*5)); } // moderat

/* --- Meilensteine generieren --- */
function buildMilestonesSnapshot(){
  const nowIso = isoToday();

  const totalQuests   = countCompletedQuests();
  const totalBoss     = countBossQuests();
  const totalMission  = countMissionsDone();
  const totalsByCat   = categoryTotals();
  const streak        = typeof streakCount==="function" ? streakCount() : 0;

  const ms = [];

  // Quests (gesamt)
  THR_QUESTS.forEach(thr=>{
    ms.push({
      id:`q:${thr}`,
      label:`${thr} Quests erledigt`,
      group:"Quests",
      current: totalQuests,
      threshold: thr,
      reward: rewardQuests(thr),
      loseable: false
    });
  });

  // Bossquests
  THR_BOSS.forEach(thr=>{
    ms.push({
      id:`b:${thr}`,
      label:`${thr} Bossquests erledigt`,
      group:"Bossquests",
      current: totalBoss,
      threshold: thr,
      reward: rewardBoss(thr),
      loseable: false
    });
  });

  // Missionen
  THR_MISSIONS.forEach(thr=>{
    ms.push({
      id:`m:${thr}`,
      label:`${thr} Missionen abgeschlossen`,
      group:"Missionen",
      current: totalMission,
      threshold: thr,
      reward: rewardMissions(thr),
      loseable: false
    });
  });

  // Streak (loseable + 1/10-Regel beim Wiedererreichen)
  THR_STREAK.forEach(thr=>{
    ms.push({
      id:`s:${thr}`,
      label:`${thr}-Tage-Streak`,
      group:"Streak",
      current: streak,
      threshold: thr,
      reward: rewardStreak(thr),
      loseable: true
    });
  });

  // Kategorien (jede einzeln)
  Object.keys(totalsByCat).forEach(catId=>{
    const c = totalsByCat[catId];
    // Skala √§hnlich Quests: 100,200,500,1000,2000...
    const CAT_THR = [100,200,500,1000,2000,5000,10000,20000];
    CAT_THR.forEach(thr=>{
      ms.push({
        id:`c:${catId}:${thr}`,
        label:`${c.name}: ${thr} Kategorie-Punkte`,
        group:`Kategorie ‚Ä¢ ${c.name}`,
        current: Math.round(c.sum),
        threshold: thr,
        reward: rewardCategory(thr),
        loseable: false
      });
    });
  });

  return ms;
}

/* --- Vergabe-Logik (inkl. Verlust / Wiedererreichen) --- */
function awardMilestone(m){
  const id = m.id;
  const date = isoToday();

  // Wiedererreichen nach Verlust ‚Üí 1/10 Reward
  let reward = m.reward;
  if(state.milestonesAuto.lost[id] && !state.milestonesAuto.reduced[id]){
    reward = Math.max(1, Math.round(m.reward*0.1));
    state.milestonesAuto.reduced[id] = true;
  }

  // Punkte gutschreiben
  state.log.push({
    date,
    quest:`Milestone: ${m.label}`,
    points: reward
  });

  // Status aktualisieren
  delete state.milestonesAuto.lost[id]; // nicht l√§nger verloren
  state.milestonesAuto.achieved[id]=date;
  save();
}

/* Nach jedem Render/Log pr√ºfen und ggf. belohnen */
function checkAndAwardMilestones(){
  const list = buildMilestonesSnapshot();

  // Verlust erkennen (nur loseable, z. B. Streak)
  list.filter(m=>m.loseable).forEach(m=>{
    const id=m.id;
    const had = !!state.milestonesAuto.achieved[id];
    const isBelow = m.current < m.threshold;
    if(had && isBelow){
      state.milestonesAuto.lost[id] = isoToday();
      save();
    }
  });

  // Neu erreichen (bei Erreichen oder Wiedererreichen)
  list.forEach(m=>{
    const id=m.id;
    const reached = m.current >= m.threshold;
    const already = !!state.milestonesAuto.achieved[id];

    // Erstvergabe
    if(reached && !already && !state.milestonesAuto.reduced[id]){
      awardMilestone(m);
    }
    // Wiedererreichen nach Verlust (mit 1/10)
    if(reached && state.milestonesAuto.lost[id]){
      awardMilestone(m);
    }
  });
}

/* --- Anzeige im Dashboard (ersetzt alte Meilensteine) --- */
function renderMilestonesAuto(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let card = document.getElementById("milestonesAutoCard");
  if(!card){
    card = document.createElement("div");
    card.id = "milestonesAutoCard";
    host.appendChild(card);
  }

  const ms = buildMilestonesSnapshot();

  // Ein paar Erreichte + N√§chste anzeigen, gruppiert
  const byGroup = {};
  ms.forEach(m=>{
    (byGroup[m.group] = byGroup[m.group] || []).push(m);
  });

  const groupsHtml = Object.keys(byGroup).map(g=>{
    const arr = byGroup[g].sort((a,b)=>a.threshold-b.threshold);
    const rows = arr.map(m=>{
      const done = (m.current>=m.threshold);
      const wasLost = !!state.milestonesAuto.lost[m.id];
      const reduced = !!state.milestonesAuto.reduced[m.id];
      const badge = done
        ? `<span class="text-green-700">‚úÖ</span>`
        : `<span class="text-slate-500">‚è≥</span>`;
      const sub = done
        ? (wasLost?`<span class="text-xs text-amber-700 ml-2">(verloren)</span>`:
           state.milestonesAuto.achieved[m.id]?`<span class="text-xs text-green-700 ml-2">(erreicht)</span>`:"")
        : `<span class="text-xs text-slate-500 ml-2">${m.current}/${m.threshold}</span>`;
      const rewardNote = reduced?`<span class="text-xs ml-2 text-amber-600">+${Math.max(1,Math.round(m.reward*0.1))} (1/10 nach Verlust)</span>`
                                :`<span class="text-xs ml-2 text-slate-600">+${m.reward}</span>`;
      return `<div class="flex justify-between items-center p-2 border rounded bg-white">
        <div>${badge} ${m.label} ${sub}</div>
        <div class="text-sm">${rewardNote}</div>
      </div>`;
    }).join("");

    return `<div class="mt-3">
      <h4 class="font-semibold">${g}</h4>
      <div class="mt-1 grid gap-2">${rows}</div>
    </div>`;
  }).join("");

  card.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üéØ Meilensteine</h3>
      ${groupsHtml||"<div class='text-sm text-slate-500'>Noch keine Meilensteine definiert.</div>"}
    </div>
  `;
}

/* --- Hooks: in addLog einh√§ngen & in Dashboard einblenden --- */
(function hookMilestonesAddLog(){
  if(addLog && !addLog.__msHooked){
    const __old = addLog;
    addLog = function(){
      const before = state.log.length;
      __old();
      if(state.log.length>before){
        // nach jedem erfolgreichen Log: pr√ºfen & ggf. belohnen
        checkAndAwardMilestones();
      }
    };
    addLog.__msHooked = true;
  }
})();

(function hookMilestonesRenderDashboard(){
  if(!renderDashboard.__msHooked){
    const __old = renderDashboard;
    renderDashboard = function(){
      __old();
      checkAndAwardMilestones();
      renderMilestonesAuto();
    };
    renderDashboard.__msHooked = true;
  }else{
    // Falls bereits gerendert wurde
    checkAndAwardMilestones();
    renderMilestonesAuto();
  }
})();

/* ===== End Part 12 ===== */
/* ===== Part 13: Per-Quest Levelsystem ===== */

/* --- State (sanft initialisieren) --- */
state.questLevels = state.questLevels || {}; // name -> { xp, level, lastDoneDate, lastDecayDate }
state.__qlLastLen = typeof state.__qlLastLen==="number" ? state.__qlLastLen : (state.log?.length||0);
state.__qlMigrated = state.__qlMigrated || false;

/* --- Datum/Mathe Helfer --- */
function ql_today(){ return todayISO(); }
function ql_daysBetween(aISO,bISO){
  const a=new Date(aISO+"T00:00:00"); const b=new Date(bISO+"T00:00:00");
  return Math.max(0, Math.round((b-a)/(1000*60*60*24)));
}

/* --- Levelkurve: 100 -> +110 -> +120 ... --- */
/* Gesamt-XP f√ºr Level L (L>=0, L=0 bedeutet noch kein Level):
   Summe_{k=0..L-1} (100 + 10*k) = 5L^2 + 95L */
function ql_totalXpForLevel(L){ return 5*L*L + 95*L; }
function ql_levelFromXp(xp){
  if(xp<=0) return 0;
  let L=0;
  // schneller Sprung: grobe Obergrenze
  while(ql_totalXpForLevel(L+10) <= xp) L+=10;
  while(ql_totalXpForLevel(L+1) <= xp) L++;
  return L;
}
function ql_nextReq(L){ return 100 + 10*L; } // n√§chste Stufe ben√∂tigt + (100 + 10*L)

/* --- Record holen/erzeugen --- */
function ql_get(name){
  if(!state.questLevels[name]){
    state.questLevels[name] = {xp:0,level:0,lastDoneDate:null,lastDecayDate:ql_today()};
  }
  return state.questLevels[name];
}

/* --- Migration: bestehende Logs in XP je Quest √ºberf√ºhren (einmalig) --- */
function ql_migrateFromLogsOnce(){
  if(state.__qlMigrated) return;
  const logs = state.log||[];
  logs.forEach(e=>{
    if(!e || e.hidden) return;
    const q=(e.quest||"").trim();
    if(!q) return;
    // System-/Kauf-/Milestone-/Event-Logs ignorieren
    const low=q.toLowerCase();
    if(low.startsWith("milestone")) return;
    if(low.startsWith("reward")) return;
    if(low.startsWith("event-bonus")) return;
    if(e.points<=0) return;

    const base = (typeof e.base==="number" && e.base>0) ? e.base : (e.points>0? e.points : 0);
    if(base<=0) return;

    const rec=ql_get(q);
    rec.xp += base;
    if(!rec.lastDoneDate || e.date>rec.lastDoneDate) rec.lastDoneDate=e.date;
    // lastDecayDate auf mindestens lastDoneDate setzen, um initiale Strafabz√ºge zu vermeiden
    if(!rec.lastDecayDate || rec.lastDecayDate<rec.lastDoneDate) rec.lastDecayDate=rec.lastDoneDate;
  });
  // Level aus XP berechnen
  Object.keys(state.questLevels).forEach(name=>{
    const r=state.questLevels[name];
    r.level = ql_levelFromXp(r.xp);
  });
  state.__qlMigrated = true;
  save();
}

/* --- Verfall anwenden: -15 XP pro fehlendem Tag seit letztem Decay/Erledigung --- */
function ql_applyDecayAll(toISO=ql_today()){
  let changed=false;
  Object.entries(state.questLevels).forEach(([name,r])=>{
    const anchorISO = r.lastDoneDate && r.lastDoneDate> (r.lastDecayDate||"") ? r.lastDoneDate : (r.lastDecayDate||toISO);
    const daysMissed = Math.max(0, ql_daysBetween(anchorISO, toISO)); // Tage seit letztem Done/Decay bis heute
    if(daysMissed>0){
      const dec = 15*daysMissed;
      const oldXP = r.xp;
      r.xp = Math.max(0, r.xp - dec);
      r.level = ql_levelFromXp(r.xp);
      r.lastDecayDate = toISO;
      if(r.xp!==oldXP) changed=true;
    }else{
      // gleicher Tag ‚Üí nur Decay-Anker aktualisieren, falls noch nie gesetzt
      if(!r.lastDecayDate) r.lastDecayDate=toISO;
    }
  });
  if(changed) save();
}

/* --- Neue Log-Eintr√§ge in Quest-XP √ºberf√ºhren (auch wenn au√üerhalb addLog gepusht) --- */
function ql_ingestNewLogs(){
  const logs=state.log||[];
  const oldLen=state.__qlLastLen||0;
  if(logs.length<=oldLen) return;
  for(let i=oldLen;i<logs.length;i++){
    const e=logs[i];
    if(!e || e.hidden) continue;
    const name=(e.quest||"").trim();
    if(!name) continue;
    const low=name.toLowerCase();
    if(low.startsWith("milestone")||low.startsWith("reward")||low.startsWith("event-bonus")) continue;
    if(e.points<=0) continue;

    const base = (typeof e.base==="number" && e.base>0) ? e.base : (e.points>0? e.points : 0);
    if(base<=0) continue;

    const rec=ql_get(name);
    // Vor dem Add decay bis zum Eintrags-Datum anwenden
    ql_applyDecayAll(e.date);
    rec.xp += base;
    rec.lastDoneDate = e.date;
    rec.lastDecayDate = e.date; // Anker auf Erledigungstag
    rec.level = ql_levelFromXp(rec.xp);
  }
  state.__qlLastLen = logs.length;
  save();
}

/* --- AddLog hooken (falls vorhanden), sonst nur √ºber Log-Ingestion gehen --- */
(function ql_hookAddLog(){
  if(typeof addLog==="function" && !addLog.__qlHooked){
    const old = addLog;
    addLog = function(){
      const before = (state.log||[]).length;
      old();
      const after = (state.log||[]).length;
      if(after>before){
        // Decay bis heute + neue Logs aufnehmen
        ql_applyDecayAll(ql_today());
        ql_ingestNewLogs();
      }
    };
    addLog.__qlHooked=true;
  }
})();

/* --- Dashboard Panel --- */
function ql_renderPanel(){
  const host=document.getElementById("tab-dashboard");
  if(!host) return;
  // Decay einmal pro Render auf heutigen Stand
  ql_applyDecayAll(ql_today());
  // ggf. neue Logs einarbeiten
  ql_ingestNewLogs();

  let card=document.getElementById("questLevelsCard");
  if(!card){
    card=document.createElement("div");
    card.id="questLevelsCard";
    host.appendChild(card);
  }

  const entries = Object.entries(state.questLevels)
    .map(([name,r])=>{
      const L = r.level||0;
      const totalForL = ql_totalXpForLevel(L);
      const nextReq = ql_nextReq(L); // XP bis zum n√§chsten Level (inkrementell)
      const inLevel = r.xp - totalForL;
      const remain = Math.max(0, nextReq - inLevel);
      const pct = Math.max(0, Math.min(100, Math.round((inLevel/nextReq)*100)));
      return {name, xp:r.xp, level:L, inLevel, nextReq, remain, pct, last:r.lastDoneDate||"‚Äì"};
    })
    // zeige Top 6 nach XP
    .sort((a,b)=>b.xp-a.xp)
    .slice(0,6);

  const rows = entries.length? entries.map(e=>`
    <div class="p-2 border rounded bg-white">
      <div class="flex justify-between">
        <div class="font-medium">${e.name}</div>
        <div>Lv ${e.level}</div>
      </div>
      <div class="w-full bg-gray-200 rounded h-2 mt-2">
        <div class="bg-blue-500 h-2 rounded" style="width:${e.pct}%"></div>
      </div>
      <div class="text-xs text-slate-600 mt-1">
        ${e.inLevel}/${e.nextReq} XP ¬∑ noch ${e.remain} ¬∑ zuletzt: ${e.last}
      </div>
    </div>
  `).join("") : `<div class="text-sm text-slate-500">Noch keine Quest-Level vorhanden.</div>`;

  card.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üè∑Ô∏è Quest-Level</h3>
      <div class="mt-2 grid gap-2">
        ${rows}
      </div>
    </div>
  `;
}

/* --- Dashboard hooken --- */
(function ql_hookDashboard(){
  if(!renderDashboard.__qlHooked2){
    const old=renderDashboard;
    renderDashboard=function(){
      old();
      ql_migrateFromLogsOnce();
      ql_renderPanel();
    };
    renderDashboard.__qlHooked2=true;
  }else{
    // falls bereits gerendert
    ql_migrateFromLogsOnce();
    ql_renderPanel();
  }
})();
/* ===== Part 14: Missionen mit Abh√§ngigkeiten (inkl. 4√ó Abschluss-Bonus) ===== */

/* ---------- State ---------- */
state.missions = state.missions || []; // [{id,name,tasks:[{id,title,points,prereq:[]}] , repeatable?}]
state.missionProgress = state.missionProgress || {}; // mid -> {done: Set/Array, bonusGranted:bool}

/* kleine Helfer */
function ms_uid(p="m"){ return p + Math.random().toString(36).slice(2,8); }
function ms_getProgress(mid){
  if(!state.missionProgress[mid]){
    state.missionProgress[mid] = {done:[], bonusGranted:false};
  }
  // normalisieren zu Set-Logik
  if(Array.isArray(state.missionProgress[mid].done)){
    // ok
  }else if(state.missionProgress[mid].done && typeof state.missionProgress[mid].done.size==="number"){
    state.missionProgress[mid].done = Array.from(state.missionProgress[mid].done);
  }else{
    state.missionProgress[mid].done=[];
  }
  return state.missionProgress[mid];
}
function ms_isTaskUnlocked(mission, doneArr, task){
  if(!task.prereq || task.prereq.length===0) return true;
  return task.prereq.every(tid => doneArr.includes(tid));
}
function ms_sumTaskPoints(m){ return m.tasks.reduce((s,t)=>s+(Number(t.points)||0),0); }

/* ---------- Engine: Task abschlie√üen & Bonus ---------- */
function ms_completeTask(missionId, taskId){
  const m = state.missions.find(x=>x.id===missionId);
  if(!m) return alert("Mission nicht gefunden.");
  const prog = ms_getProgress(missionId);
  const done = prog.done;

  if(done.includes(taskId)) return; // schon erledigt

  const task = m.tasks.find(t=>t.id===taskId);
  if(!task) return alert("Task nicht gefunden.");
  if(!ms_isTaskUnlocked(m, done, task)) return alert("Task noch gesperrt (Voraussetzungen fehlen).");

  // Eintragen in Log
  const today = todayISO();
  const base = Number(task.points)||0;
  const pts = computePoints(base, today);
  state.log.push({
    date: today,
    quest: `Mission: ${m.name} ‚Äì ${task.title}`,
    points: pts,
    base: base
  });

  // Fortschritt updaten
  done.push(taskId);
  save(); renderAll();

  // Abschluss-Bonus pr√ºfen
  const allDone = m.tasks.length>0 && m.tasks.every(t=>done.includes(t.id));
  if(allDone && !prog.bonusGranted){
    const bonusBase = ms_sumTaskPoints(m) * 4; // 4√ó Summe
    const bonusPts = computePoints(bonusBase, today);
    state.log.push({
      date: today,
      quest: `Mission abgeschlossen: ${m.name} (Bonus)`,
      points: bonusPts,
      base: bonusBase
    });
    prog.bonusGranted = true;
    save(); renderAll();
    try{ Sound.level?.(); }catch{}
  }
}

/* ---------- Dashboard: Missionspanel ---------- */
function ms_renderDashboardPanel(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  // Container finden/erzeugen
  let box = document.getElementById("missionsPanel");
  if(!box){
    box = document.createElement("div");
    box.id = "missionsPanel";
    host.appendChild(box);
  }

  if(state.missions.length===0){
    box.innerHTML = `
      <div class="mt-4 p-3 border rounded bg-white">
        <h3 class="font-bold">üó∫Ô∏è Missionen</h3>
        <div class="text-sm text-slate-500 mt-1">Noch keine Missionen angelegt.</div>
      </div>`;
    return;
  }

  // Missionskarten bauen
  const cards = state.missions.map(m=>{
    const prog = ms_getProgress(m.id);
    const done = prog.done;
    const total = m.tasks.length;
    const doneCount = m.tasks.filter(t=>done.includes(t.id)).length;
    const pct = total>0 ? Math.round((doneCount/total)*100) : 0;

    // verf√ºgbare Tasks (freigeschaltet & nicht erledigt)
    const available = m.tasks.filter(t=>!done.includes(t.id) && ms_isTaskUnlocked(m, done, t)).slice(0,3);

    const availBtns = available.map(t=>`
      <button class="btn w-full text-left" data-ms-do="${m.id}::${t.id}">
        ‚ûï ${t.title} (+${t.points})
      </button>`).join("");

    return `
      <div class="p-3 border rounded bg-white">
        <div class="flex justify-between items-center">
          <div class="font-bold">${m.name}</div>
          <div class="text-sm">${doneCount}/${total}</div>
        </div>
        <div class="w-full bg-gray-200 rounded h-2 mt-2">
          <div class="bg-emerald-500 h-2 rounded" style="width:${pct}%"></div>
        </div>
        ${available.length>0
          ? `<div class="mt-2 space-y-2">${availBtns}</div>`
          : `<div class="mt-2 text-xs text-slate-500">${doneCount===total && total>0 ? "‚úÖ Mission abgeschlossen" : "‚è≥ Keine freigeschalteten Tasks verf√ºgbar"}</div>`
        }
        ${prog.bonusGranted ? `<div class="text-xs text-green-700 mt-1">Bonus vergeben ‚úì</div>` : ``}
      </div>
    `;
  }).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üó∫Ô∏è Missionen</h3>
      <div class="mt-2 grid gap-2">${cards}</div>
    </div>
  `;

  // Button-Handler
  box.querySelectorAll("[data-ms-do]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const [mid,tid] = btn.getAttribute("data-ms-do").split("::");
      ms_completeTask(mid,tid);
    });
  });
}

/* Hook ins Dashboard */
(function ms_hookDashboard(){
  if(!renderDashboard.__msHooked){
    const old = renderDashboard;
    renderDashboard = function(){
      old();
      ms_renderDashboardPanel();
    };
    renderDashboard.__msHooked = true;
  }else{
    ms_renderDashboardPanel();
  }
})();

/* ---------- Katalog: Mission-Builder & Liste ---------- */
function ms_renderCatalogUI(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;

  // Container finden/erzeugen
  let wrap = document.getElementById("missionsCatalog");
  if(!wrap){
    wrap = document.createElement("div");
    wrap.id = "missionsCatalog";
    host.appendChild(wrap);
  }

  // Draft im window (lebensdauer pro Render)
  if(!window.__msDraft){
    window.__msDraft = {name:"", tasks:[]}; // tasks: {id:'t1', title, points, prereq:[]}
  }
  const draft = window.__msDraft;

  // HTML Builder
  const taskRows = draft.tasks.map(t=>{
    const pre = (t.prereq||[]).length ? ("‚Üí " + t.prereq.join(", ")) : "";
    return `<div class="p-2 border rounded bg-white flex justify-between items-center">
      <div>
        <div class="font-medium">${t.id}: ${t.title}</div>
        <div class="text-xs text-slate-600">+${t.points} ${pre}</div>
      </div>
      <button class="text-red-600 text-sm" data-ms-del="${t.id}">L√∂schen</button>
    </div>`;
  }).join("");

  const allMissions = state.missions.map(m=>{
    const prog = ms_getProgress(m.id);
    const total = m.tasks.length;
    const done = prog.done.length;
    const pct = total? Math.round(done/total*100):0;
    return `
      <div class="p-2 border rounded bg-white">
        <div class="flex justify-between">
          <div class="font-medium">${m.name}</div>
          <button class="text-red-600 text-sm" data-ms-remove="${m.id}">L√∂schen</button>
        </div>
        <div class="w-full bg-gray-200 rounded h-2 mt-2">
          <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
        </div>
        <div class="text-xs text-slate-600 mt-1">${done}/${total} erledigt</div>
      </div>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üß≠ Missionen (Builder)</h3>

      <div class="mt-2 grid gap-2">
        <label class="text-sm">Missionsname
          <input id="msName" class="input" placeholder="z. B. Wohnzimmer fertig machen" value="${draft.name||""}">
        </label>

        <div class="p-2 border rounded bg-gray-50">
          <div class="font-medium mb-2">Task hinzuf√ºgen</div>
          <div class="grid gap-2 md:grid-cols-3">
            <input id="msTaskTitle" class="input" placeholder="Task-Titel (z. B. Leisten anbringen)">
            <input id="msTaskPoints" type="number" class="input" placeholder="Punkte (z. B. 30)">
            <select id="msTaskPrereq" class="input">
              <option value="">‚Äî Voraussetzung (optional) ‚Äî</option>
              ${draft.tasks.map(t=>`<option value="${t.id}">${t.id}: ${t.title}</option>`).join("")}
            </select>
          </div>
          <button id="msAddTask" class="btn mt-2">+ Task</button>

          <div class="mt-2 grid gap-2" id="msTaskList">
            ${taskRows || `<div class="text-xs text-slate-500">Noch keine Tasks hinzugef√ºgt.</div>`}
          </div>
        </div>

        <div class="flex gap-2">
          <button id="msSave" class="btn bg-blue-600 text-white">Mission speichern</button>
          <button id="msReset" class="btn">Entwurf leeren</button>
        </div>
      </div>
    </div>

    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üìö Missionen (Liste)</h3>
      <div class="mt-2 grid gap-2" id="msList">
        ${allMissions || `<div class="text-xs text-slate-500">Noch keine Missionen vorhanden.</div>`}
      </div>
    </div>
  `;

  // Handlers: Name
  wrap.querySelector("#msName").addEventListener("input",(e)=>{
    draft.name = e.target.value;
  });

  // Task hinzuf√ºgen
  wrap.querySelector("#msAddTask").addEventListener("click",()=>{
    const title = wrap.querySelector("#msTaskTitle").value.trim();
    const points = Number(wrap.querySelector("#msTaskPoints").value||0);
    const pr = wrap.querySelector("#msTaskPrereq").value;
    if(!title || !points) return alert("Titel und Punkte angeben.");
    const id = "t"+(draft.tasks.length+1);
    const prereq = pr ? [pr] : [];
    draft.tasks.push({id,title,points,prereq});
    // Felder leeren
    wrap.querySelector("#msTaskTitle").value="";
    wrap.querySelector("#msTaskPoints").value="";
    wrap.querySelector("#msTaskPrereq").value="";
    ms_renderCatalogUI(); // re-render
  });

  // Task l√∂schen
  wrap.querySelectorAll("[data-ms-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const tid = btn.getAttribute("data-ms-del");
      draft.tasks = draft.tasks.filter(t=>t.id!==tid);
      // auch aus prereqs entfernen
      draft.tasks.forEach(t=>{
        if(Array.isArray(t.prereq)) t.prereq = t.prereq.filter(x=>x!==tid);
      });
      ms_renderCatalogUI();
    });
  });

  // Entwurf zur√ºcksetzen
  wrap.querySelector("#msReset").addEventListener("click",()=>{
    window.__msDraft = {name:"",tasks:[]};
    ms_renderCatalogUI();
  });

  // Mission speichern
  wrap.querySelector("#msSave").addEventListener("click",()=>{
    const name = (draft.name||"").trim();
    if(!name) return alert("Bitte Missionsname angeben.");
    if(draft.tasks.length===0) return alert("Bitte mindestens einen Task anlegen.");
    const mid = ms_uid("m");
    const mission = {
      id: mid,
      name,
      tasks: JSON.parse(JSON.stringify(draft.tasks))
    };
    state.missions.push(mission);
    state.missionProgress[mid] = {done:[], bonusGranted:false};
    save();
    // Entwurf zur√ºcksetzen
    window.__msDraft = {name:"",tasks:[]};
    ms_renderCatalogUI();
    renderAll();
  });

  // Mission l√∂schen
  wrap.querySelectorAll("[data-ms-remove]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const mid = btn.getAttribute("data-ms-remove");
      if(!confirm("Mission wirklich l√∂schen?")) return;
      state.missions = state.missions.filter(m=>m.id!==mid);
      delete state.missionProgress[mid];
      save();
      ms_renderCatalogUI();
      renderAll();
    });
  });
}

/* Hook in renderCatalog */
(function ms_hookCatalog(){
  if(!renderCatalog.__msHooked){
    const old = renderCatalog;
    renderCatalog = function(){
      old();
      ms_renderCatalogUI();
    };
    renderCatalog.__msHooked = true;
  }else{
    ms_renderCatalogUI();
  }
})();
/* ===== Part 15: Kategorien, Verkn√ºpfungen & Auto-Meilensteine ===== */

/* -------------------- State & Defaults -------------------- */
state.categories = state.categories || [
  { id:"cat0", name:"Allgemein", negative:false },
  { id:"catBad", name:"Schlechter Lebensstil", negative:true }
];
// Verkn√ºpfungen: wenn in "from" Kategorie Punkte gesammelt werden, werden *nur auf Kategorie-Ebene*
// zus√§tzlich ratio*Punkte zur "to" Kategorie addiert (kein globaler Bonus).
state.catLinks = state.catLinks || []; // [{from:"catHandwerk", to:"catSport", ratio:0.2}]

// pro Quest eine Kategorie (nachtr√§glich √§nderbar)
// bestehende Eintr√§ge bleiben erhalten; neue ohne Kategorie fallen auf "cat0"
state.catalog.forEach(q=>{
  if(!q.hasOwnProperty("category")) q.category="cat0";
  // optionale Overrides f√ºr negative Kategorien
  if(!q.hasOwnProperty("negGlobal")) q.negGlobal=-30;     // z.B. global -30
  if(!q.hasOwnProperty("negCategory")) q.negCategory=+15; // z.B. Kategorie +15
});

// Auto-Meilensteine: was wurde schon vergeben?
state.autoMilestones = state.autoMilestones || { awarded:[] }; // string-IDs


/* -------------------- Helpers -------------------- */
function catById(id){ return state.categories.find(c=>c.id===id); }
function ensureId(prefix="id"){ return prefix + Math.random().toString(36).slice(2,8); }

function isSystemEntry(e){
  const n=(e.quest||"").toLowerCase();
  return n.startsWith("reward") || n.includes("bonus") || n.startsWith("milestone") || n.includes("event");
}

// Quest nach Name (exakt) suchen
function findQuestByName(name){
  return state.catalog.find(q=>q.name === name);
}

/* Kategoriepunkte f√ºr einen Logeintrag berechnen (on-the-fly, kein Rewrite n√∂tig) */
function cat_pointsForLogEntry(entry){
  // 1) Versuche, den Katalog-Quest zu finden
  const q = findQuestByName(entry.quest);
  if(!q){
    // Missionen/sonstige: erstmal nicht kategorisieren
    return null; 
  }
  const cat = catById(q.category)||catById("cat0");
  // 2) Kategoriepunkte vs. global
  if(cat.negative){
    // z.B. "Joint": global bereits in entry.points (negativ),
    // Kategorie aber +X f√ºr Statistik/√úbersicht:
    const cp = typeof q.negCategory==="number" ? q.negCategory : Math.max(0, (entry.base||q.points||0));
    return { catId:cat.id, catPoints: cp };
  }else{
    // normale Kategorie: Kategoriepunkte = "Basis" ohne Streak/Perks
    const base = (typeof entry.base==="number" ? entry.base : (q.points||0));
    return { catId:cat.id, catPoints: base };
  }
}

/* Summe je Kategorie inkl. Verkn√ºpfungen (nur Kategorie-Ebene!) */
function cat_computeTotals(){
  const raw = Object.fromEntries(state.categories.map(c=>[c.id,0]));

  // aus state.log ableiten (Migration: alte Eintr√§ge werden abgebildet)
  state.log.forEach(e=>{
    if(isSystemEntry(e)) return;
    const mapped = cat_pointsForLogEntry(e);
    if(mapped){
      raw[mapped.catId] = (raw[mapped.catId]||0) + (mapped.catPoints||0);
    }
  });

  // Verkn√ºpfungen anwenden (ohne globale Boni!)
  const tot = {...raw};
  state.catLinks.forEach(link=>{
    const fromVal = raw[link.from]||0;
    const add = Math.round(fromVal * (Number(link.ratio)||0));
    if(add>0){
      tot[link.to] = (tot[link.to]||0) + add;
    }
  });

  return {raw, totals:tot};
}

/* Anzahl erledigter (vollst√§ndig) Missionen */
function countCompletedMissions(){
  let n=0;
  Object.entries(state.missionProgress||{}).forEach(([mid,pr])=>{
    const m=state.missions.find(x=>x.id===mid);
    if(!m) return;
    const doneArr=pr.done||[];
    if(m.tasks.length>0 && m.tasks.every(t=>doneArr.includes(t.id))) n++;
  });
  return n;
}

/* Quests/Bossquests-Z√§hlung (auf Basis von Katalog-Match) */
function countQuestStats(){
  let quests=0, boss=0;
  state.log.forEach(e=>{
    if(isSystemEntry(e)) return;
    const q = findQuestByName(e.quest);
    if(!q) return;
    if(q.boss) boss++;
    else quests++;
  });
  return {quests,boss};
}


/* -------------------- Auto-Meilensteine -------------------- */
/* Regeln (aus deinen Vorgaben) */
const MS_RULES = {
  missions: {
    thresholds: [5,10,20,50,100,200,500,1000],
    rewards:    [50,100,400,2500,6000,15000,40000,100000], // ‚Äûeher h√∂her‚Äú motivierend
    id: x => `ms:missions:${x}`,
    label: x => `Meilenstein: ${x} Missionen erledigt`
  },
  quests: {
    thresholds: [100,200,500,1000,2000],
    rewards:    [100,400,2500,6000,15000],
    id: x => `ms:quests:${x}`,
    label: x => `Meilenstein: ${x} Quests erledigt`
  },
  boss: {
    thresholds: [10,20,50,100],
    rewards:    [100,200,2500,6000],
    id: x => `ms:boss:${x}`,
    label: x => `Meilenstein: ${x} Bossquests erledigt`
  },
  // pro Kategorie:
  // du bekommst f√ºr jede Kategorie eigene Stufen (nur Kategorie-Punkte, keine globalen Boni!)
  categories: {
    thresholds: [100,200,500,1000,2000,5000],
    rewards:    [50,150,800,2000,4500,12000],
    id: (cat,x) => `ms:cat:${cat}:${x}`,
    label: (name,x) => `Meilenstein: ${x} Punkte in Kategorie ‚Äû${name}‚Äú`
  }
};

function awardMilestone(id, label, pts){
  if(state.autoMilestones.awarded.includes(id)) return;
  state.autoMilestones.awarded.push(id);
  state.log.push({date:todayISO(), quest: label, points: pts});
  save(); renderAll();
}

function autoMilestones_checkAll(){
  // Missionen
  const mDone = countCompletedMissions();
  MS_RULES.missions.thresholds.forEach((th,i)=>{
    if(mDone>=th) awardMilestone(
      MS_RULES.missions.id(th),
      MS_RULES.missions.label(th),
      MS_RULES.missions.rewards[i]||0
    );
  });

  // Quests / Bossquests
  const cs = countQuestStats();
  MS_RULES.quests.thresholds.forEach((th,i)=>{
    if(cs.quests>=th) awardMilestone(
      MS_RULES.quests.id(th),
      MS_RULES.quests.label(th),
      MS_RULES.quests.rewards[i]||0
    );
  });
  MS_RULES.boss.thresholds.forEach((th,i)=>{
    if(cs.boss>=th) awardMilestone(
      MS_RULES.boss.id(th),
      MS_RULES.boss.label(th),
      MS_RULES.boss.rewards[i]||0
    );
  });

  // Kategorien
  const {totals} = cat_computeTotals();
  state.categories.forEach(cat=>{
    const val = totals[cat.id]||0;
    MS_RULES.categories.thresholds.forEach((th,i)=>{
      if(val>=th) awardMilestone(
        MS_RULES.categories.id(cat.id, th),
        MS_RULES.categories.label(cat.name, th),
        MS_RULES.categories.rewards[i]||0
      );
    });
  });
}


/* -------------------- Dashboard: Kategorien-Panel -------------------- */
function cat_renderDashboardPanel(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let box = document.getElementById("catPanel");
  if(!box){
    box = document.createElement("div");
    box.id = "catPanel";
    host.appendChild(box);
  }

  const {raw, totals} = cat_computeTotals();

  const rows = state.categories.map(cat=>{
    const v = totals[cat.id]||0;
    const r = raw[cat.id]||0;
    const next = MS_RULES.categories.thresholds.find(t=>t>v);
    const pct = next ? Math.min(100, Math.round((v/next)*100)) : 100;
    const badge = cat.negative ? `<span class="ml-2 text-xs px-2 py-0.5 rounded bg-red-100 text-red-700">negativ</span>` : ``;
    return `
      <div class="p-2 border rounded bg-white">
        <div class="flex justify-between items-center">
          <div class="font-medium">${cat.name} ${badge}</div>
          <div class="text-sm">Summe: <b>${v}</b> <span class="text-xs text-slate-500">(roh: ${r})</span></div>
        </div>
        <div class="w-full bg-gray-200 rounded h-2 mt-2">
          <div class="bg-indigo-500 h-2 rounded" style="width:${pct}%"></div>
        </div>
        <div class="text-xs text-slate-600 mt-1">
          ${next ? `N√§chster Cat-Meilenstein: ${next} (Fortschritt ${pct}%)` : `Alle definierten Cat-Meilensteine erreicht üéâ`}
        </div>
      </div>
    `;
  }).join("");

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üè∑Ô∏è Kategorien</h3>
      <div class="text-xs text-slate-500 mt-1">Summen beinhalten ggf. Verkn√ºpfungs-Zuw√§chse (keine globalen Boni).</div>
      <div class="mt-2 grid gap-2">${rows}</div>
    </div>
  `;
}

/* Hook ins Dashboard */
(function cat_hookDashboard(){
  if(!renderDashboard.__catHooked){
    const old = renderDashboard;
    renderDashboard = function(){
      old();
      cat_renderDashboardPanel();
      autoMilestones_checkAll(); // Auto-MS pr√ºfen (wenn sichtbare Zahlen sich ge√§ndert haben)
    };
    renderDashboard.__catHooked = true;
  }else{
    cat_renderDashboardPanel();
    autoMilestones_checkAll();
  }
})();


/* -------------------- Catalog: Kategorie-Zuweisung & Add-Select -------------------- */
// erweitert den vorhandenen Katalog-Renderer um Kategorie-Select f√ºr:
// - Neu anlegen
// - Bestehende Quests (nachtr√§gliches Verschieben)
function cat_renderCatalogEnhancements(){
  const root = document.getElementById("tab-catalog");
  if(!root) return;

  /* --- Neu-Formular: Kategorie-Select sicherstellen --- */
  let formRow = root.querySelector("#catNewRow");
  if(!formRow){
    // Finde Formular-Container (erste .space-y-2)
    const cont = root.querySelector(".space-y-2");
    if(cont){
      formRow = document.createElement("div");
      formRow.id = "catNewRow";
      formRow.className = "grid grid-cols-1 gap-2";
      formRow.innerHTML = `
        <select id="qCategory" class="input"></select>
      `;
      cont.appendChild(formRow);
    }
  }
  const selNew = root.querySelector("#qCategory");
  if(selNew){
    selNew.innerHTML = state.categories.map(c=>`<option value="${c.id}">${c.name}${c.negative?' (negativ)':''}</option>`).join("");
  }

  // addQuest() abfangen, damit Kategorie gespeichert wird + negative Regeln greifen
  if(!window.__catAddQuestPatched && typeof addQuest==="function"){
    const oldAddQuest = addQuest;
    window.addQuest = function(){
      const beforeLen = state.catalog.length;
      oldAddQuest(); // nutzt qName/qPoints/qBoss aus deinem UI
      const catSel = document.getElementById("qCategory");
      if(catSel && state.catalog.length>beforeLen){
        // setze Kategorie auf das zuletzt hinzugef√ºgte
        const q = state.catalog[state.catalog.length-1];
        q.category = catSel.value || "cat0";
        save(); renderAll();
      }
    };
    window.__catAddQuestPatched = true;
  }

  /* --- Bestehende Liste: Kategorie-Dropdown je Quest --- */
  const list = document.getElementById("catalogList");
  if(!list) return;

  // komplette Liste neu rendern (mit Kategorie-Select + Boss-Badge + Delete)
  list.innerHTML = state.catalog.map((q,i)=>{
    const cat = catById(q.category)||catById("cat0");
    return `
      <div class="p-2 border rounded bg-white">
        <div class="flex flex-col gap-2">
          <div class="flex justify-between items-center">
            <span>${q.boss?'üëë ':''}${q.name} (+${q.points} Punkte)</span>
            <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
          </div>
          <div class="grid gap-2 md:grid-cols-3">
            <label class="text-sm">Kategorie
              <select class="input" data-cat-i="${i}">
                ${state.categories.map(c=>`<option value="${c.id}" ${c.id===cat.id?'selected':''}>${c.name}${c.negative?' (negativ)':''}</option>`).join("")}
              </select>
            </label>
            ${cat.negative ? `
              <label class="text-sm">Global (negativ)
                <input type="number" class="input" data-neg-global="${i}" value="${q.negGlobal}">
              </label>
              <label class="text-sm">Kategorie (+)
                <input type="number" class="input" data-neg-cat="${i}" value="${q.negCategory}">
              </label>` : `<div class="hidden md:block"></div><div class="hidden md:block"></div>`
            }
          </div>
        </div>
      </div>
    `;
  }).join("");

  // Events: l√∂schen (bestehende Handler aus deinem Render bleiben g√ºltig, aber wir h√§ngen sie hier nochmal an)
  list.querySelectorAll("[data-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      state.catalog.splice(Number(btn.getAttribute("data-del")),1);
      save(); renderAll();
    });
  });

  // Kategorie wechseln
  list.querySelectorAll("[data-cat-i]").forEach(sel=>{
    sel.addEventListener("change",()=>{
      const i=Number(sel.getAttribute("data-cat-i"));
      state.catalog[i].category = sel.value;
      save(); renderAll();
    });
  });

  // Negative Overrides bearbeiten
  list.querySelectorAll("[data-neg-global]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const i=Number(inp.getAttribute("data-neg-global"));
      state.catalog[i].negGlobal = Number(inp.value||0);
      save();
    });
  });
  list.querySelectorAll("[data-neg-cat]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const i=Number(inp.getAttribute("data-neg-cat"));
      state.catalog[i].negCategory = Number(inp.value||0);
      save();
    });
  });
}

/* Hook ins Catalog-Render */
(function cat_hookCatalog(){
  if(!renderCatalog.__catHooked2){
    const old = renderCatalog;
    renderCatalog = function(){
      old();
      cat_renderCatalogEnhancements();
    };
    renderCatalog.__catHooked2 = true;
  }else{
    cat_renderCatalogEnhancements();
  }
})();


/* -------------------- Settings: Kategorie-Manager & Verkn√ºpfungen -------------------- */
function cat_renderSettings(){
  const host = document.getElementById("tab-settings");
  if(!host) return;

  let wrap = document.getElementById("catSettings");
  if(!wrap){
    wrap = document.createElement("div");
    wrap.id = "catSettings";
    host.appendChild(wrap);
  }

  const catRows = state.categories.map(c=>`
    <div class="p-2 border rounded bg-white flex flex-wrap gap-2 items-center justify-between">
      <div class="flex items-center gap-2">
        <input class="input" style="width:14rem" data-cat-name="${c.id}" value="${c.name}">
        <label class="text-sm flex items-center gap-1"><input type="checkbox" ${c.negative?'checked':''} data-cat-neg="${c.id}"> negativ</label>
      </div>
      ${c.id==="cat0" ? `<span class="text-xs text-slate-500">Standard ‚Äì nicht l√∂schbar</span>` :
        `<button class="text-red-600 text-sm" data-cat-del="${c.id}">L√∂schen</button>`}
    </div>
  `).join("");

  const linkRows = (state.catLinks||[]).map((l,idx)=>`
    <div class="p-2 border rounded bg-white grid gap-2 md:grid-cols-4 items-center">
      <select class="input" data-link-from="${idx}">
        ${state.categories.map(c=>`<option value="${c.id}" ${c.id===l.from?'selected':''}>${c.name}</option>`).join("")}
      </select>
      <div class="text-center">‚Üí</div>
      <select class="input" data-link-to="${idx}">
        ${state.categories.map(c=>`<option value="${c.id}" ${c.id===l.to?'selected':''}>${c.name}</option>`).join("")}
      </select>
      <input type="number" step="0.01" class="input" data-link-ratio="${idx}" value="${l.ratio}">
      <button class="text-red-600 text-sm md:col-span-4" data-link-del="${idx}">Link entfernen</button>
    </div>
  `).join("");

  wrap.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üè∑Ô∏è Kategorien verwalten</h3>
      <div class="mt-2 grid gap-2">${catRows}</div>
      <button id="catAdd" class="btn mt-2">+ Kategorie</button>
    </div>

    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üîó Verkn√ºpfungen (nur Kategorie-Ebene)</h3>
      <div class="text-xs text-slate-500 mb-2">Beispiel: ‚ÄûHandwerk‚Äú ‚Üí ‚ÄûSport‚Äú mit 0.2 addiert 20% der Handwerk-Kategoriepunkte zus√§tzlich zur Sport-Kategorie (ohne globalen Bonus).</div>
      <div id="catLinksWrap" class="grid gap-2">${linkRows || `<div class="text-xs text-slate-500">Keine Links definiert.</div>`}</div>
      <div class="flex gap-2 mt-2">
        <select id="linkFrom" class="input">
          ${state.categories.map(c=>`<option value="${c.id}">${c.name}</option>`).join("")}
        </select>
        <span class="self-center">‚Üí</span>
        <select id="linkTo" class="input">
          ${state.categories.map(c=>`<option value="${c.id}">${c.name}</option>`).join("")}
        </select>
        <input id="linkRatio" type="number" step="0.01" class="input" placeholder="0.2" value="0.2">
        <button id="linkAdd" class="btn">+ Link</button>
      </div>
    </div>
  `;

  // Kategorie add
  wrap.querySelector("#catAdd").addEventListener("click",()=>{
    const id=ensureId("cat");
    state.categories.push({id, name:"Neue Kategorie", negative:false});
    save(); renderAll();
  });

  // Kategorie edit / delete
  wrap.querySelectorAll("[data-cat-name]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const id=inp.getAttribute("data-cat-name");
      const c=catById(id); if(!c) return;
      c.name = inp.value.trim()||c.name;
      save(); renderAll();
    });
  });
  wrap.querySelectorAll("[data-cat-neg]").forEach(chk=>{
    chk.addEventListener("change",()=>{
      const id=chk.getAttribute("data-cat-neg");
      const c=catById(id); if(!c) return;
      c.negative = chk.checked;
      save(); renderAll();
    });
  });
  wrap.querySelectorAll("[data-cat-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const id = btn.getAttribute("data-cat-del");
      if(!confirm("Kategorie wirklich l√∂schen?")) return;
      // Quests auf cat0 umh√§ngen
      state.catalog.forEach(q=>{ if(q.category===id) q.category="cat0"; });
      state.categories = state.categories.filter(c=>c.id!==id);
      // Links bereinigen
      state.catLinks = (state.catLinks||[]).filter(l=>l.from!==id && l.to!==id);
      save(); renderAll();
    });
  });

  // Links bearbeiten/entfernen
  wrap.querySelectorAll("[data-link-from]").forEach(sel=>{
    sel.addEventListener("change",()=>{
      const i=Number(sel.getAttribute("data-link-from"));
      state.catLinks[i].from = sel.value;
      save(); renderAll();
    });
  });
  wrap.querySelectorAll("[data-link-to]").forEach(sel=>{
    sel.addEventListener("change",()=>{
      const i=Number(sel.getAttribute("data-link-to"));
      state.catLinks[i].to = sel.value;
      save(); renderAll();
    });
  });
  wrap.querySelectorAll("[data-link-ratio]").forEach(inp=>{
    inp.addEventListener("change",()=>{
      const i=Number(inp.getAttribute("data-link-ratio"));
      state.catLinks[i].ratio = Number(inp.value||0);
      save(); renderAll();
    });
  });
  wrap.querySelectorAll("[data-link-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const i=Number(btn.getAttribute("data-link-del"));
      state.catLinks.splice(i,1);
      save(); renderAll();
    });
  });

  // Link hinzuf√ºgen
  wrap.querySelector("#linkAdd").addEventListener("click",()=>{
    const from = wrap.querySelector("#linkFrom").value;
    const to   = wrap.querySelector("#linkTo").value;
    const ratio= Number(wrap.querySelector("#linkRatio").value||0);
    if(!from || !to || from===to || ratio<=0) return alert("Bitte sinnvollen Link angeben.");
    state.catLinks.push({from,to,ratio});
    save(); renderAll();
  });
}

/* Hook ins Settings-Render */
(function cat_hookSettings(){
  if(!renderSettings.__catHooked){
    const old = renderSettings;
    renderSettings = function(){
      old();
      cat_renderSettings();
    };
    renderSettings.__catHooked = true;
  }else{
    cat_renderSettings();
  }
})();


/* -------------------- Negative Kategorien beim Loggen ber√ºcksichtigen -------------------- */
/* Wir √§ndern NICHT alle Log-Wege, sondern patchen an einer zentralen Stelle:
   Nach JEDEM renderAll() wird Dashboard/Kategorien aus log neu berechnet (oben).
   F√ºr *neue* Quests in negativer Kategorie sorgen wir daf√ºr, dass beim Eintragen
   die globalen Punkte ggf. √ºberschrieben werden. */
if(!window.__catLogPatched){
  // 1) Patch des addLog() ‚Äì falls der Nutzer manuell eintr√§gt:
  if(typeof addLog==="function"){
    const __oldAddLog_cat = addLog;
    addLog = function(){
      const before = state.log.length;
      __oldAddLog_cat(); // f√ºgt Eintrag hinzu
      const last = state.log[state.log.length-1];
      if(last && state.catalog){
        const q = findQuestByName(last.quest);
        if(q){
          const cat = catById(q.category)||catById("cat0");
          if(cat.negative){
            // setze globale Punkte auf negGlobal (z.B. -30), cat-Punkte nur Statistik (oben)
            last.points = Number(q.negGlobal||-30);
            save(); renderAll();
          }
        }
      }
    };
  }

  // 2) Chat/Missions/Buttons schreiben direkt in state.log ‚Äì das fangen wir nicht einzeln ab.
  //    Die Kategorie-Summen (und Links) werden trotzdem korrekt berechnet, weil sie aus log abgeleitet werden.

  window.__catLogPatched = true;
}
/* ===== Part 16: Quest-Level je einzelner Quest + t√§glicher R√ºckfall =====
   Idee:
   - Jede *normale* Quest hat eigenes XP/Level (Bossquests ausgenommen).
   - XP-Gewinn pro Eintrag = Basis-Punkte der Quest (ohne Multiplikator/Perks). Negative Quests geben 0 XP.
   - Levelschwellen: L1‚ÜíL2 = 100 XP, danach steigt die Schwelle um +10 je Level (100,110,120,130, ... unendlich).
   - R√ºckfall: F√ºr jeden Tag, an dem eine Quest *nicht mindestens 1x* geloggt wurde,
               werden **15 XP** von *ihrer* XP abgezogen (niemals unter 0).
   - R√ºckfall wird h√∂chstens 1x pro Kalendertag angewendet (global √ºber state.questLevelLastCheck).
   - Anzeige:
      ‚Ä¢ Katalog: pro Quest ‚ÄûQuest-Level: Lx ‚Äî a/b XP‚Äú
      ‚Ä¢ Dashboard: Top-5 Quests nach XP in eigenem Panel
========================================================================== */

/* ---------- State ---------- */
state.questProgress = state.questProgress || {};         // { [questName]: { xpTotal:number } }
state.questLevelLastCheck = state.questLevelLastCheck || todayISO();

/* ---------- Level-Formeln ---------- */
// XP, die f√ºr das n√§chste Level ben√∂tigt werden (abh√§ngig vom aktuellen Level, 1-basiert)
function questXpNeededAtLevel(level){
  // L1‚ÜíL2: 100, danach +10 pro Level
  return 100 + (level-1)*10;
}

// Level aus Gesamt-XP berechnen
function questLevelFromXp(xp){
  let level = 1;
  let need = questXpNeededAtLevel(level);
  let rest = Math.max(0, Math.floor(xp));

  while(rest >= need){
    rest -= need;
    level++;
    need = questXpNeededAtLevel(level);
    // (keine Obergrenze)
  }
  return { level, xpInto: rest, nextNeed: need };
}

/* ---------- Hilfen ---------- */
// Hole "Basis-Punkte" der Quest (ohne Streak/Perks). F√§llt zur√ºck auf entry.base / 0.
function questBasePointsForEntry(entry){
  const q = state.catalog.find(x=>x.name===entry.quest);
  if(!q) return (typeof entry.base === "number" ? entry.base : 0);
  return (typeof entry.base === "number" ? entry.base : (q.points||0));
}

// Ist die Quest negativ (Kategorie ‚ÄûSchlechter Lebensstil‚Äú o.√Ñ.)?
function isNegativeQuest(name){
  const q = state.catalog.find(x=>x.name===name);
  if(!q) return false;
  const cat = (state.categories||[]).find(c=>c.id===q.category);
  return !!(cat && cat.negative);
}

// Lern-/XP-Gewinn f√ºr eine Log-Zeile
function questXpGainFromLog(entry){
  if(isSystemEntry(entry)) return 0;            // Systemeintr√§ge z√§hlen nicht
  if(isNegativeQuest(entry.quest)) return 0;    // negative Kategorien geben kein Quest-XP
  const base = questBasePointsForEntry(entry);
  return Math.max(0, Math.floor(base));
}

// Vergewissere dich, dass ein Progress-Container f√ºr diese Quest existiert
function ensureQuestProgress(name){
  if(!state.questProgress[name]) state.questProgress[name] = { xpTotal:0 };
  return state.questProgress[name];
}

/* ---------- Aufruf beim Loggen: XP addieren ---------- */
function questLevels_onLogAppended(entry){
  // Nur *normale* Katalog-Quests bekommen Quest-Level (Bossquests ausgenommen)
  const q = state.catalog.find(x=>x.name===entry.quest);
  if(!q || q.boss) return;
  const gain = questXpGainFromLog(entry);
  if(gain<=0) return;

  const p = ensureQuestProgress(entry.quest);
  p.xpTotal = Math.max(0, (p.xpTotal||0) + gain);
  save();
}

/* ---------- T√§glicher R√ºckfall (Decay) ---------- */
function questLevels_applyDailyDecay(){
  const last = state.questLevelLastCheck || todayISO();
  const today = todayISO();
  if(last >= today) return; // Decay heute bereits gepr√ºft

  // gehe Tag f√ºr Tag vom (last+1) bis (heute-1)
  const d = new Date(last);
  d.setDate(d.getDate()+1);

  let changed=false;

  while(d.toISOString().slice(0,10) < today){
    const iso = d.toISOString().slice(0,10);

    // F√ºr *alle* bereits gestarteten Quests pr√ºfen, ob an iso geloggt wurde
    Object.keys(state.questProgress).forEach(name=>{
      const had = state.log.some(e=> e.quest===name && e.date===iso );
      if(!had){
        const p = state.questProgress[name];
        const before = p.xpTotal||0;
        p.xpTotal = Math.max(0, before - 15);
        if(p.xpTotal !== before) changed = true;
      }
    });

    d.setDate(d.getDate()+1);
  }

  state.questLevelLastCheck = today;
  if(changed) save();
}

/* ---------- UI: Dashboard Panel (Top 5) ---------- */
function questLevels_renderDashboardPanel(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;

  let box = document.getElementById("questLevelPanel");
  if(!box){
    box = document.createElement("div");
    box.id = "questLevelPanel";
    host.appendChild(box);
  }

  // Liste aller normalen Quests mit XP sortiert
  const list = state.catalog
    .filter(q=>!q.boss)
    .map(q=>{
      const xp = (state.questProgress[q.name]?.xpTotal)||0;
      const {level, xpInto, nextNeed} = questLevelFromXp(xp);
      return { name:q.name, points:q.points, xp, level, xpInto, nextNeed };
    })
    .sort((a,b)=> b.xp - a.xp)
    .slice(0,5);

  const rows = list.map(it=>{
    const pct = Math.min(100, Math.round((it.xpInto/it.nextNeed)*100));
    return `
      <div class="p-2 border rounded bg-white">
        <div class="flex justify-between text-sm">
          <div class="font-medium">${it.name}</div>
          <div>Lv ${it.level}</div>
        </div>
        <div class="w-full bg-gray-200 rounded h-2 mt-1">
          <div class="bg-emerald-500 h-2 rounded" style="width:${pct}%"></div>
        </div>
        <div class="text-xs text-slate-600 mt-1">${it.xpInto}/${it.nextNeed} XP</div>
      </div>
    `;
  }).join("") || `<div class="text-sm text-slate-500">Noch keine Quest mit XP-Fortschritt.</div>`;

  box.innerHTML = `
    <div class="mt-4 p-3 border rounded bg-white">
      <h3 class="font-bold">üèÜ Quest-Level (Top 5)</h3>
      <div class="mt-2 grid gap-2">${rows}</div>
      <div class="text-xs text-slate-500 mt-2">T√§glicher R√ºckfall: ‚àí15 XP, wenn eine Quest an einem Tag nicht geloggt wurde.</div>
    </div>
  `;
}

/* ---------- UI: Katalog-Badges pro Quest ---------- */
function questLevels_renderCatalogBadges(){
  const list = document.getElementById("catalogList");
  if(!list) return;

  // wir h√§ngen unter jeden Eintrag eine Zeile ‚ÄûQuest-Level ‚Ä¶‚Äú an / aktualisieren sie
  // dazu nutzen wir data-cat-i (aus Part 15) um Index‚ÜíQuest abzuleiten
  list.querySelectorAll("[data-cat-i]").forEach(sel=>{
    const i = Number(sel.getAttribute("data-cat-i"));
    const q = state.catalog[i];
    if(!q || q.boss) return; // Bossquests nicht leveln

    // Finde den Container des Eintrags (2 Ebenen hoch)
    const card = sel.closest(".p-2.border.rounded.bg-white");
    if(!card) return;

    let line = card.querySelector(".ql-line");
    const xp = (state.questProgress[q.name]?.xpTotal)||0;
    const info = questLevelFromXp(xp);
    const text = `Quest-Level: <b>Lv ${info.level}</b> ‚Äî ${info.xpInto}/${info.nextNeed} XP`;

    if(!line){
      line = document.createElement("div");
      line.className = "ql-line text-xs text-slate-600";
      line.innerHTML = text;
      card.appendChild(line);
    }else{
      line.innerHTML = text;
    }
  });
}

/* ---------- Hooks ---------- */
// 1) nach jedem Log-Eintrag XP f√ºr diese Quest addieren
if(!window.__questLevelLogPatched && typeof addLog==="function"){
  const _oldAddLog_ql = addLog;
  addLog = function(){
    const lenBefore = state.log.length;
    _oldAddLog_ql();
    const lenAfter = state.log.length;
    if(lenAfter>lenBefore){
      const last = state.log[lenAfter-1];
      // nur echten User-Log verarbeiten (kein System/Milestone/Event)
      if(last && !isSystemEntry(last)){
        questLevels_onLogAppended(last);
      }
    }
  };
  window.__questLevelLogPatched = true;
}

// 2) t√§glicher Decay + Panels beim Rendern
if(!window.__questLevelRenderPatched){
  const _oldRenderAll_ql = renderAll;
  renderAll = function(){
    _oldRenderAll_ql();
    questLevels_applyDailyDecay();
    questLevels_renderDashboardPanel();
    questLevels_renderCatalogBadges();
  };
  window.__questLevelRenderPatched = true;
}else{
  // Falls bereits gepatcht (Hot-Reload via Teileinf√ºgen)
  questLevels_applyDailyDecay();
  questLevels_renderDashboardPanel();
  questLevels_renderCatalogBadges();
}
/* ======================= Part 17: Missionen (mit Verzweigungen) =======================
   Features:
   - Mission = Sammlung von Aufgaben/Steps (Tasks).
   - Jede Task hat Punkte + Abh√§ngigkeiten:
       ‚Ä¢ reqAll: alle diese Task-IDs m√ºssen erledigt sein
       ‚Ä¢ reqAny: mindestens eine dieser Task-IDs muss erledigt sein (f√ºr Alternativen, z.B. 2.0 ODER 2.1)
   - Freischaltung: Nur Tasks, deren Abh√§ngigkeiten erf√ºllt sind und die noch nicht erledigt sind, sind "unlockt".
   - Abschluss: Wenn es keine "unlockten" Tasks mehr gibt, gilt die Mission als abgeschlossen.
   - Belohnung: Beim Missionsabschluss gibt es **Bonus = 4 √ó Summe der Basis-Punkte aller erledigten Tasks der Mission** (fix, ohne Streak/Perks).
   - UI:
       ‚Ä¢ Panel ‚Äûüß≠ Missionen‚Äú im Katalog-Tab: √úbersicht, Fortschritt, Buttons ‚Äû+ Mission‚Äú, ‚Äû+ Aufgabe‚Äú, ‚ÄûErledigen‚Äú
       ‚Ä¢ Demo-Mission ‚ÄûWohnzimmer‚Äú wird einmalig angelegt, falls noch keine vorhanden ist.
   - Kompatibel mit bestehendem Log/State, keine bestehenden Daten √ºberschrieben.
======================================================================================= */

/* ---------- Helper: Systemeintr√§ge erkennen (falls noch nicht vorhanden) ---------- */
if(typeof window.isSystemEntry !== "function"){
  window.isSystemEntry = function(e){
    const q = (e?.quest || "").toLowerCase();
    return q.startsWith("reward")
        || q.startsWith("milestone")
        || q.startsWith("event-")
        || q.startsWith("tagesziel bonus")
        || q.startsWith("mission abgeschlossen");
  };
}

/* ---------- State-Struktur ---------- */
state.missions = state.missions || [];           // [{id,name,bonusMultiplier,tasks:[{id,title,points,reqAll,reqAny}], archived?}]
state.missionProgress = state.missionProgress || {}; // { [missionId]: { doneTasks: string[], completed: boolean } }

/* ---------- Progress-Helfer ---------- */
function ensureMissionProgress(mid){
  if(!state.missionProgress[mid]){
    state.missionProgress[mid] = { doneTasks: [], completed:false };
  }
  return state.missionProgress[mid];
}

function taskIsDone(mid, tid){
  const pr = ensureMissionProgress(mid);
  return pr.doneTasks.includes(tid);
}

/* ---------- Freischalt-Logik ---------- */
function missionUnlockedTasks(m){
  const pr = ensureMissionProgress(m.id);
  return m.tasks.filter(t=>{
    if(taskIsDone(m.id, t.id)) return false;
    const allOk = (t.reqAll||[]).every(x => pr.doneTasks.includes(x));
    const anyOk = (t.reqAny && t.reqAny.length>0) ? t.reqAny.some(x => pr.doneTasks.includes(x)) : true;
    return allOk && anyOk;
  });
}

/* ---------- Bonus-Berechnung ---------- */
function missionBonusFor(m){
  const pr = ensureMissionProgress(m.id);
  const sumDoneBase = m.tasks
    .filter(t => pr.doneTasks.includes(t.id))
    .reduce((s,t)=> s + (t.points||0), 0);
  const mult = (typeof m.bonusMultiplier === "number" ? m.bonusMultiplier : 4);
  return Math.max(0, Math.floor(sumDoneBase * mult));
}

/* ---------- Abschluss pr√ºfen ---------- */
function missionCheckComplete(m){
  const pr = ensureMissionProgress(m.id);
  if(pr.completed) return; // bereits belohnt
  const unlocked = missionUnlockedTasks(m);
  if(unlocked.length === 0){
    // keine freigeschalteten Tasks mehr ‚Üí Mission durch (auch wenn alternative Branches unber√ºhrt & gelockt bleiben)
    pr.completed = true;
    const bonus = missionBonusFor(m);
    if(bonus>0){
      state.log.push({date: todayISO(), quest: "Mission abgeschlossen: "+m.name, points: bonus});
    }else{
      // trotzdem markieren, aber ohne Punkte
      state.log.push({date: todayISO(), quest: "Mission abgeschlossen: "+m.name, points: 0});
    }
    save();
  }
}

/* ---------- Task-Abschluss ---------- */
function completeMissionTask(missionId, taskId){
  const m = state.missions.find(x => x.id === missionId);
  if(!m) return;
  const t = m.tasks.find(x => x.id === taskId);
  if(!t) return;

  // Punkte loggen (mit Streak/Perks, weil es eine normale T√§tigkeit ist)
  const base = t.points||0;
  const pts = computePoints(base, todayISO());
  state.log.push({
    date: todayISO(),
    quest: `Mission: ${m.name} ‚Äì ${t.title}`,
    points: pts,
    base: base
  });

  // Fortschritt markieren
  const pr = ensureMissionProgress(m.id);
  if(!pr.doneTasks.includes(t.id)){
    pr.doneTasks.push(t.id);
  }

  save();
  missionCheckComplete(m);
  renderAll();
}

/* ---------- Missionen erstellen/bearbeiten (Prompt-basiert, schnell & simpel) ---------- */

function addMissionPrompt(){
  const name = prompt("Name der Mission?");
  if(!name) return;
  // id generieren
  const mid = "m"+Math.random().toString(36).slice(2,8);
  state.missions.push({
    id: mid,
    name,
    bonusMultiplier: 4,
    tasks: []
  });
  save(); renderAll();
  alert("Mission angelegt. F√ºge jetzt Aufgaben hinzu.");
}

function addTaskPrompt(mid){
  const m = state.missions.find(x=>x.id===mid);
  if(!m) return;

  const id = prompt("Aufgaben-ID (z.B. 1, 2.0, 2.1) ‚Äì muss eindeutig in der Mission sein:");
  if(!id) return;
  if(m.tasks.some(t=>t.id===id)){
    alert("Diese Aufgaben-ID existiert bereits.");
    return;
  }
  const title = prompt("Titel der Aufgabe:");
  if(!title) return;
  const points = Number(prompt("Punkte (Basis, ohne Multiplikator):")||0);
  const reqAllStr = prompt("reqAll (kommaseparierte Task-IDs; leer lassen wenn keine):")||"";
  const reqAnyStr = prompt("reqAny (kommaseparierte Task-IDs f√ºr Alternativen; leer lassen wenn keine):")||"";
  const reqAll = reqAllStr.split(",").map(s=>s.trim()).filter(Boolean);
  const reqAny = reqAnyStr.split(",").map(s=>s.trim()).filter(Boolean);

  m.tasks.push({id, title, points, reqAll, reqAny});
  save(); renderAll();
}

/* ---------- Demo-Mission (nur wenn noch leer) ---------- */
function ensureDemoMission(){
  if(state.missions.length>0) return;
  const demo = {
    id: "m-demo-wohnzimmer",
    name: "Wohnzimmer fertig machen",
    bonusMultiplier: 4,
    tasks: [
      { id:"1",   title:"Leisten an die Wand bringen", points: 30, reqAll:[], reqAny:[] },
      { id:"2.0", title:"Wand streichen",               points: 40, reqAll:["1"], reqAny:[] },
      { id:"2.1", title:"Lampen anbringen",             points: 40, reqAll:["1"], reqAny:[] },
      { id:"3",   title:"Finalisieren (Deko, Feinschliff)", points: 50, reqAll:[], reqAny:["2.0","2.1"] }
    ]
  };
  state.missions.push(demo);
  save();
}

/* ---------- UI-Render: Panel im Katalog-Tab ---------- */
function renderMissionsPanel(){
  const hostTab = document.getElementById("tab-catalog");
  if(!hostTab) return;

  let panel = document.getElementById("missionsPanel");
  if(!panel){
    panel = document.createElement("div");
    panel.id = "missionsPanel";
    hostTab.appendChild(panel);
  }

  // Sortierung: offene vor fertigen
  const cards = state.missions
    .filter(m => !m.archived)
    .map(m => {
      const pr = ensureMissionProgress(m.id);
      const total = m.tasks.length;
      const done = pr.doneTasks.length;
      const unlocked = missionUnlockedTasks(m);
      const pct = total>0 ? Math.round((done/total)*100) : 0;

      const tasksHTML = m.tasks.map(t=>{
        const isDone = taskIsDone(m.id, t.id);
        const canDo = unlocked.some(u=>u.id===t.id);
        const reqText = [
          (t.reqAll && t.reqAll.length>0) ? `ALL: ${t.reqAll.join(", ")}` : "",
          (t.reqAny && t.reqAny.length>0) ? `ANY: ${t.reqAny.join(", ")}` : ""
        ].filter(Boolean).join(" | ");

        return `
          <div class="p-2 border rounded ${isDone?'bg-green-50':(canDo?'bg-white':'bg-slate-50 opacity-70')}">
            <div class="flex justify-between items-center">
              <div>
                <div class="font-medium">${t.id} ‚Äî ${t.title}</div>
                <div class="text-xs text-slate-600">+${t.points} Punkte ${reqText?(' ‚Ä¢ '+reqText):''}</div>
              </div>
              <div>
                ${isDone?`<span class="text-green-700 text-sm">‚úîÔ∏è</span>`
                  : (canDo?`<button class="btn text-xs" data-mdo="${m.id}::${t.id}">Erledigen</button>`:`<span class="text-xs text-slate-400">üîí</span>`)}
              </div>
            </div>
          </div>
        `;
      }).join("");

      const header = `
        <div class="flex justify-between items-center">
          <div class="font-bold">${m.name}</div>
          <div class="text-sm">${done}/${total} ‚Ä¢ ${pct}%</div>
        </div>
        <div class="w-full bg-gray-200 rounded h-2 mt-1">
          <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
        </div>
      `;

      const footer = `
        <div class="flex gap-2 mt-2">
          <button class="btn text-xs" data-madd="${m.id}">+ Aufgabe</button>
          ${ensureMissionProgress(m.id).completed
            ? `<span class="text-xs text-emerald-700">üéâ Bonus: +${missionBonusFor(m)} (vergeben)</span>`
            : `<span class="text-xs text-slate-600">Bonus bei Abschluss: +${missionBonusFor(m)}</span>`}
        </div>
      `;

      return `
        <div class="p-3 border rounded bg-white">
          ${header}
          <div class="mt-2 grid gap-2">${tasksHTML || `<div class="text-sm text-slate-500">Noch keine Aufgaben.</div>`}</div>
          ${footer}
        </div>
      `;
    }).join("") || `<div class="text-sm text-slate-500">Noch keine Missionen. Lege eine neue an!</div>`;

  panel.innerHTML = `
    <div class="mt-6 p-3 border rounded bg-white">
      <div class="flex justify-between items-center">
        <h3 class="font-bold">üß≠ Missionen</h3>
        <div class="flex gap-2">
          <button id="btnAddMission" class="btn">+ Mission</button>
        </div>
      </div>
      <div class="mt-3 grid gap-3">${cards}</div>
    </div>
  `;

  // Events: Mission hinzuf√ºgen
  const addBtn = document.getElementById("btnAddMission");
  if(addBtn) addBtn.addEventListener("click", addMissionPrompt);

  // Events: Aufgabe hinzuf√ºgen
  panel.querySelectorAll("[data-madd]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const mid = b.getAttribute("data-madd");
      addTaskPrompt(mid);
    });
  });

  // Events: Aufgabe erledigen
  panel.querySelectorAll("[data-mdo]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const [mid, tid] = b.getAttribute("data-mdo").split("::");
      completeMissionTask(mid, tid);
    });
  });
}

/* ---------- Hook in renderCatalog (Panel integrieren) ---------- */
(function patchRenderCatalogForMissions(){
  if(window.__missionsCatalogPatched) { renderMissionsPanel(); return; }
  const prev = (typeof renderCatalog==="function") ? renderCatalog : null;
  renderCatalog = function(){
    if(prev) prev();
    ensureDemoMission();          // einmalig Demo anlegen (nur wenn keine vorhanden)
    renderMissionsPanel();        // Panel anh√§ngen
  };
  window.__missionsCatalogPatched = true;
})();

/* ---------- Sicherheitsnetz: Beim renderAll zus√§tzlich Missions-Panel sicherstellen ---------- */
(function patchRenderAllForMissions(){
  if(window.__missionsRenderAllPatched) { return; }
  const prevAll = (typeof renderAll==="function") ? renderAll : null;
  renderAll = function(){
    if(prevAll) prevAll();
    // Falls der Katalog gerade sichtbar/neu gerendert wurde, Panel aktualisieren:
    renderMissionsPanel();
  };
  window.__missionsRenderAllPatched = true;
})();
/* ======================= Part 18: Kategorien & Kategorie-Punkte =======================
   Was kommt dazu:
   - Kategorien-Verwaltung (positiv/negativ), Default: ‚ÄûAllgemein‚Äú, ‚ÄûSchlechter Lebensstil (negativ)‚Äú
   - Quests im Katalog lassen sich einer Kategorie zuordnen/umbuchen
   - Kategorie-Punkte (Summen aus dem Log) werden angezeigt:
       ‚Ä¢ Panel im Katalog-Tab
       ‚Ä¢ kleine √úbersicht im Dashboard
   - Bestehende Eintr√§ge werden NICHT gel√∂scht. Historische Logs ohne Kategorie
     werden bei jeder Darstellung automatisch nachgetaggt (per aktueller Quest-Kategorie).
   - Helper addLogEntry(): Zum einheitlichen Eintragen inkl. Kategorie
     (fix f√ºr alte Stellen, an denen addLogEntry bisher fehlte).
======================================================================================= */

/* ---------- State & Defaults ---------- */
state.categories = state.categories || {
  "Allgemein": {type:"positive"},
  "Schlechter Lebensstil": {type:"negative"}
};

// vorhandene Quests ohne Kategorie ‚Üí ‚ÄûAllgemein‚Äú
(state.catalog||[]).forEach(q=>{
  if(!q.category) q.category = "Allgemein";
});

/* ---------- Quest/Kategorie Utilities ---------- */
function getQuestByName(name){
  return (state.catalog||[]).find(q=>q.name===name) || null;
}

function categoryOfQuest(name){
  const q = getQuestByName(name);
  return q && q.category ? q.category : "Allgemein";
}

function isSystemEntry(e){
  const q = (e?.quest||"").toLowerCase();
  return q.startsWith("reward")
      || q.startsWith("milestone")
      || q.startsWith("event-")
      || q.startsWith("tagesziel bonus")
      || q.startsWith("mission abgeschlossen");
}

/* ---------- Log-Normalisierung: Kategorie an fehlende Eintr√§ge taggen ---------- */
function normalizeLogCategories(){
  // Aufgabenbezeichnung aus Missions-Tasks extrahieren: "Mission: <M>- <Titel>"
  const stripMissionPrefix = (txt)=> txt.replace(/^Mission:\s.*?‚Äì\s/,"");

  (state.log||[]).forEach(e=>{
    if(isSystemEntry(e)) return; // Systemeintr√§ge nicht taggen
    if(e.category) return;
    const plain = stripMissionPrefix(e.quest||"");
    e.category = categoryOfQuest(plain);
  });
}

/* ---------- Einheitlicher Log-Eintrag (inkl. Kategorie) ---------- */
function addLogEntry(dateISO, questName, noteOrReason=null, basePointsOverride=null){
  // Versuche Quest zu finden oder notfalls anlegen (Fallback +5)
  let q = getQuestByName(questName);
  if(!q){
    q = {name: questName, points: (basePointsOverride!=null?basePointsOverride:5), category:"Allgemein"};
    state.catalog.push(q);
  }
  const base = (basePointsOverride!=null?basePointsOverride:(q.points||0));
  const pts  = computePoints(base, dateISO);
  const entry = {
    date: dateISO,
    quest: questName + (noteOrReason?` (${noteOrReason})`:""),
    points: pts,
    base: base,
    category: q.category
  };
  state.log.push(entry);
  save(); renderAll();
  return entry;
}

/* ---------- Kategorie-Summen aus dem Log ---------- */
function computeCategoryTotals(){
  normalizeLogCategories();
  const totals = {};
  Object.keys(state.categories).forEach(k=>totals[k]={points:0, count:0});

  (state.log||[]).forEach(e=>{
    if(isSystemEntry(e)) return;
    const cat = e.category || "Allgemein";
    if(!totals[cat]) totals[cat] = {points:0, count:0};
    totals[cat].points += (e.points||0);
    totals[cat].count  += 1;
  });
  return totals;
}

/* ---------- Kategorien-Panel im Katalog ---------- */
function renderCategoriesPanel(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;

  let panel = document.getElementById("categoriesPanel");
  if(!panel){
    panel = document.createElement("div");
    panel.id = "categoriesPanel";
    host.appendChild(panel);
  }

  const totals = computeCategoryTotals();

  const catsHTML = Object.entries(state.categories).map(([name, meta])=>{
    const t = totals[name] || {points:0, count:0};
    const typSel = `
      <select data-ctype="${name}" class="input text-xs">
        <option value="positive" ${meta.type==="positive"?"selected":""}>positiv</option>
        <option value="negative" ${meta.type==="negative"?"selected":""}>negativ</option>
      </select>
    `;
    return `
      <div class="p-2 border rounded flex items-center justify-between">
        <div>
          <div class="font-medium">${name}</div>
          <div class="text-xs text-slate-600">Eintr√§ge: ${t.count} ‚Ä¢ Summe: ${t.points}</div>
        </div>
        <div class="flex items-center gap-2">
          ${typSel}
          ${name!=="Allgemein" ? `<button class="btn text-xs" data-delcat="${name}">L√∂schen</button>` : `<span class="text-xs text-slate-400">fix</span>`}
        </div>
      </div>
    `;
  }).join("");

  panel.innerHTML = `
    <div class="mt-6 p-3 border rounded bg-white">
      <div class="flex items-center justify-between">
        <h3 class="font-bold">üè∑Ô∏è Kategorien</h3>
        <div class="flex gap-2">
          <input id="newCatName" class="input text-sm" placeholder="Neue Kategorie" />
          <select id="newCatType" class="input text-sm">
            <option value="positive">positiv</option>
            <option value="negative">negativ</option>
          </select>
          <button id="btnAddCategory" class="btn">+</button>
        </div>
      </div>
      <div class="mt-3 grid gap-2">${catsHTML || `<div class="text-sm text-slate-500">Keine Kategorien.</div>`}</div>
    </div>
  `;

  // Add
  const btnAdd = document.getElementById("btnAddCategory");
  if(btnAdd) btnAdd.addEventListener("click", ()=>{
    const name = (document.getElementById("newCatName").value||"").trim();
    const type = document.getElementById("newCatType").value||"positive";
    if(!name) return;
    if(state.categories[name]){ alert("Kategorie existiert bereits."); return; }
    state.categories[name] = {type};
    save(); renderAll();
  });

  // Type change
  panel.querySelectorAll("[data-ctype]").forEach(sel=>{
    sel.addEventListener("change", ()=>{
      const name = sel.getAttribute("data-ctype");
      const val  = sel.value;
      if(state.categories[name]){
        state.categories[name].type = val;
        save();
      }
    });
  });

  // Delete
  panel.querySelectorAll("[data-delcat]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const name = btn.getAttribute("data-delcat");
      if(!state.categories[name]) return;
      if(!confirm(`Kategorie ‚Äû${name}‚Äú l√∂schen?\nQuests werden nach ‚ÄûAllgemein‚Äú verschoben.`)) return;

      // Quests umh√§ngen
      (state.catalog||[]).forEach(q=>{
        if(q.category===name) q.category="Allgemein";
      });
      // Logs umh√§ngen
      (state.log||[]).forEach(e=>{
        if(e.category===name) e.category="Allgemein";
      });
      delete state.categories[name];
      save(); renderAll();
    });
  });
}

/* ---------- Quest-Liste im Katalog: Kategorie-Zuweisung ---------- */
function renderQuestCategoryEditors(){
  const list = document.getElementById("catalogList");
  if(!list) return;

  const catOptions = Object.keys(state.categories).map(c=>`<option value="${c}">${c}</option>`).join("");

  list.innerHTML = (state.catalog||[]).map((q,i)=>`
    <div class="p-2 border rounded mb-1 flex flex-col sm:flex-row sm:items-center sm:justify-between ${q.boss?'bg-yellow-50':'bg-white'}">
      <div class="mb-2 sm:mb-0">
        <span>${q.boss?'üëë':''} ${q.name} (+${q.points} Punkte)</span>
      </div>
      <div class="flex items-center gap-2">
        <select class="input text-xs" data-qcat="${i}">
          ${catOptions}
        </select>
        <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
      </div>
    </div>
  `).join("") + `
    <button id="btnTimedQuestAddAgain" class="btn w-full bg-purple-600 text-white mt-2">+ Timed Quest</button>
  `;

  // Vorbelegen der Selects
  list.querySelectorAll("[data-qcat]").forEach(sel=>{
    const i = Number(sel.getAttribute("data-qcat"));
    sel.value = state.catalog[i].category || "Allgemein";
    sel.addEventListener("change", ()=>{
      state.catalog[i].category = sel.value || "Allgemein";
      save(); renderAll();
    });
  });

  // L√∂schen wie gehabt
  list.querySelectorAll("[data-del]").forEach(btn=>{
    btn.addEventListener("click",()=>{
      state.catalog.splice(Number(btn.getAttribute("data-del")),1);
      save(); renderAll();
    });
  });

  // Timed-Quest Button wieder anbinden (aus Part 17)
  const b2 = document.getElementById("btnTimedQuestAddAgain");
  if(b2 && typeof addTimedQuest==="function"){
    b2.addEventListener("click", addTimedQuest);
  }
}

/* ---------- Kategorien-Panel & Quest-Kategorie-Editor in den Katalog einh√§ngen ---------- */
(function patchCatalogForCategories(){
  if(window.__categoriesCatalogPatched) { renderCategoriesPanel(); renderQuestCategoryEditors(); return; }
  const prev = (typeof renderCatalog==="function") ? renderCatalog : null;
  renderCatalog = function(){
    if(prev) prev();               // bestehendes Rendering (inkl. Timed Button/Missionen)
    renderQuestCategoryEditors();  // ersetzt #catalogList mit Selects und Delete
    renderCategoriesPanel();       // zeigt Kategorie-Summen & Verwaltung
  };
  window.__categoriesCatalogPatched = true;
})();

/* ---------- Dashboard: Kategorien-√úbersicht (Top-Kategorien) ---------- */
function renderCategoryOverviewDashboard(){
  const host = document.getElementById("tab-dashboard");
  if(!host) return;
  const totals = computeCategoryTotals();
  // sortiert nach Punktesumme (abs oder echt? wir zeigen tats√§chliche Summe)
  const sorted = Object.entries(totals).sort((a,b)=> (b[1].points)-(a[1].points)).slice(0,6);

  const box = document.createElement("div");
  box.className = "mt-4 p-3 border rounded bg-white";
  box.innerHTML = `<h3 class="font-bold">üìö Kategorien (√úbersicht)</h3>
    <div class="mt-2 grid gap-1">
      ${
        sorted.map(([name, t])=>{
          const typeBadge = state.categories[name]?.type==="negative"
            ? `<span class="ml-2 text-xs px-1.5 py-0.5 border rounded bg-red-50 text-red-700">negativ</span>`
            : `<span class="ml-2 text-xs px-1.5 py-0.5 border rounded bg-green-50 text-green-700">positiv</span>`;
          return `<div class="flex justify-between">
            <span>${name} ${typeBadge}</span>
            <span class="text-slate-700">Summe: ${t.points}</span>
          </div>`;
        }).join("")
      }
    </div>`;
  host.appendChild(box);
}

/* ---------- Hook in renderAll & diverse Stellen, damit Kategorien stets gepflegt werden ---------- */
(function patchRenderAllForCategories(){
  if(window.__categoriesRenderAllPatched) return;
  const prevAll = (typeof renderAll==="function") ? renderAll : null;
  renderAll = function(){
    // zuerst Normalisieren, dann Standard-Render, dann Kategorien rendern
    normalizeLogCategories();
    if(prevAll) prevAll();
    renderCategoryOverviewDashboard();
    // Katalog-Panels werden im Katalog-Render gebaut (und dort auch normalizeLogCategories indirekt genutzt)
  };
  window.__categoriesRenderAllPatched = true;
})();

/* ---------- Fix: addLogEntry in anderen Teilen aufrufbar machen ---------- */
window.addLogEntry = addLogEntry;

/* ---------- Bonus: Wenn irgendwo direkt ins Log gepusht wurde, beim n√§chsten renderAll wird getaggt ---------- */
// (durch normalizeLogCategories() bereits abgedeckt)
/* ==================== Part 19: Kategorie-Links (lokal) + Gruppen je Quest ====================
   Ziel:
   - Quests k√∂nnen eine optionale "Gruppe" haben (z. B. ‚ÄûWohnzimmer‚Äú, ‚ÄûRenovierung‚Äú).
   - Kategorie-Verkn√ºpfungen (z. B. Handwerk ‚ûú Sport) wirken NICHT global,
     sondern nur, wenn innerhalb eines Zeitfensters eine passende Aufgabe aus der
     verkn√ºpften Kategorie im selben Gruppen-Kontext erledigt wurde.
   - Verkn√ºpfungen sind in Katalog verwaltbar (Quelle, Ziel, Art, Wert, Zeitraum, ‚Äûnur gleiche Gruppe‚Äú).
   - Beim Eintragen (addLogEntry) wird der Bonus auf den AKTUELLEN Eintrag addiert, wenn Bedingungen passen.

   Datenmodell:
   - state.categoryLinks: [{from, to, type: "flat"|"percent", amount, windowDays, groupOnly}]
   - Quest-Feld: q.group (optional String). Wird im Katalog pro Quest editierbar.
   - Keine globalen Multiplikatoren ‚Äî rein lokaler, kontextueller Bonus.
============================================================================================== */

/* ---------- Defaults ---------- */
state.categoryLinks = state.categoryLinks || []; // leer = keine Links

// Fallback: existierende Quests ohne .group Feld nachziehen
(state.catalog||[]).forEach(q=>{
  if(typeof q.group === "undefined") q.group = "";
});

/* ---------- Helfer: letzte passende Vorleistung f√ºr Link finden ---------- */
function findPriorEntryForLink(link, currentDateISO, currentGroup){
  // Vorfenster berechnen
  const wd = Math.max(0, Number(link.windowDays||1));
  const start = new Date(currentDateISO);
  start.setDate(start.getDate() - wd);
  const startISO = start.toISOString().slice(0,10);

  // durch Log r√ºckw√§rts (ohne den aktuellsten, der gleich geschrieben wurde)
  for(let i=state.log.length-2; i>=0; i--){
    const e = state.log[i];
    if(!e || !e.date) continue;
    if(isSystemEntry(e)) continue;
    if(e.date < startISO) break;

    const cat = e.category || categoryOfQuest(e.quest.replace(/\s*\(.*\)$/,""));
    if(cat !== link.from) continue;

    if(link.groupOnly){
      const prevQ = getQuestByName(e.quest.replace(/\s*\(.*\)$/,""));
      const prevGroup = prevQ?.group || "";
      if(!prevGroup || prevGroup !== currentGroup) continue;
    }
    return e; // Treffer
  }
  return null;
}

/* ---------- Patch: addLogEntry um lokale Verkn√ºpfungen erweitern ---------- */
(function patchAddLogEntryForLinks(){
  if(window.__linksAddLogEntryPatched) return;
  const prev = (typeof addLogEntry==="function") ? addLogEntry : null;

  addLogEntry = function(dateISO, questName, noteOrReason=null, basePointsOverride=null){
    // normalen Eintrag erzeugen
    const entry = prev ? prev(dateISO, questName, noteOrReason, basePointsOverride) : (()=>{
      // extrem seltener Fallback, falls prev nicht existiert
      let q = getQuestByName(questName);
      if(!q){
        q = {name: questName, points: (basePointsOverride!=null?basePointsOverride:5), category:"Allgemein", group:""};
        state.catalog.push(q);
      }
      const base = (basePointsOverride!=null?basePointsOverride:(q.points||0));
      const pts  = computePoints(base, dateISO);
      const e = {date:dateISO, quest:questName+(noteOrReason?` (${noteOrReason})`:""), points:pts, base:base, category:q.category};
      state.log.push(e); save(); renderAll();
      return e;
    })();

    // lokaler Link-Bonus pr√ºfen (kein global!)
    const q    = getQuestByName(questName);
    const cat  = entry.category || (q?.category || "Allgemein");
    const grp  = q?.group || "";

    let bonusTotal = 0;
    (state.categoryLinks||[]).forEach(link=>{
      if(!link || link.to !== cat) return;

      // wenn "groupOnly": es muss eine Gruppe geben
      if(link.groupOnly && !grp) return;

      const prior = findPriorEntryForLink(link, entry.date, grp);
      if(!prior) return;

      // Bonus bestimmen
      const basePts = entry.points;
      let bonus = 0;
      if(link.type==="percent"){
        bonus = Math.round(basePts * (Number(link.amount||0)/100));
      }else{
        bonus = Math.round(Number(link.amount||0));
      }
      if(!bonus) return;

      entry.points   += bonus;
      entry.linkBonus = (entry.linkBonus||0) + bonus;
      // optional Info f√ºr UI/Debug
      entry.linkInfo  = {from:link.from, to:link.to, type:link.type, amount:link.amount, groupOnly:!!link.groupOnly, windowDays:Number(link.windowDays||1)};

      bonusTotal += bonus;
    });

    if(bonusTotal){
      save(); renderAll();
    }
    return entry;
  };

  window.__linksAddLogEntryPatched = true;
})();

/* ---------- UI: ‚ÄûGruppe‚Äú pro Quest im Katalog editieren (override der Editor-Ansicht) ---------- */
(function overrideQuestCategoryEditorsWithGroup(){
  // Wir ersetzen die in Part 18 definierte Funktion renderQuestCategoryEditors vollst√§ndig,
  // damit zus√§tzlich ein ‚ÄûGruppe‚Äú-Feld vorhanden ist.
  renderQuestCategoryEditors = function(){
    const list = document.getElementById("catalogList");
    if(!list) return;

    const catOptions = Object.keys(state.categories).map(c=>`<option value="${c}">${c}</option>`).join("");

    list.innerHTML = (state.catalog||[]).map((q,i)=>`
      <div class="p-2 border rounded mb-1 flex flex-col sm:flex-row sm:items-center sm:justify-between ${q.boss?'bg-yellow-50':'bg-white'}">
        <div class="mb-2 sm:mb-0">
          <span>${q.boss?'üëë':''} ${q.name} (+${q.points} Punkte)</span>
        </div>
        <div class="flex flex-wrap items-center gap-2">
          <label class="text-xs">Kategorie:
            <select class="input text-xs" data-qcat="${i}">
              ${catOptions}
            </select>
          </label>
          <label class="text-xs">Gruppe:
            <input class="input text-xs" placeholder="z. B. Wohnzimmer" data-qgroup="${i}" value="${q.group||""}">
          </label>
          <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
        </div>
      </div>
    `).join("") + `
      <button id="btnTimedQuestAddAgain" class="btn w-full bg-purple-600 text-white mt-2">+ Timed Quest</button>
    `;

    // Kategorie-Selects vorbesetzen + speichern
    list.querySelectorAll("[data-qcat]").forEach(sel=>{
      const i = Number(sel.getAttribute("data-qcat"));
      sel.value = state.catalog[i].category || "Allgemein";
      sel.addEventListener("change", ()=>{
        state.catalog[i].category = sel.value || "Allgemein";
        save();
      });
    });

    // Gruppe-Felder binden
    list.querySelectorAll("[data-qgroup]").forEach(inp=>{
      const i = Number(inp.getAttribute("data-qgroup"));
      inp.addEventListener("change", ()=>{
        state.catalog[i].group = (inp.value||"").trim();
        save();
      });
    });

    // L√∂schen
    list.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        state.catalog.splice(Number(btn.getAttribute("data-del")),1);
        save(); renderAll();
      });
    });

    // Timed-Quest-Button (Rebind)
    const b2 = document.getElementById("btnTimedQuestAddAgain");
    if(b2 && typeof addTimedQuest==="function"){
      b2.addEventListener("click", addTimedQuest);
    }
  };
})();

/* ---------- UI: Panel f√ºr Kategorie-Verkn√ºpfungen im Katalog ---------- */
function renderCategoryLinksPanel(){
  const host = document.getElementById("tab-catalog");
  if(!host) return;

  let panel = document.getElementById("categoryLinksPanel");
  if(!panel){
    panel = document.createElement("div");
    panel.id = "categoryLinksPanel";
    host.appendChild(panel);
  }

  const catNames = Object.keys(state.categories);
  const catSel = (attr,val)=> `<select class="input text-xs" ${attr}>
    ${catNames.map(n=>`<option value="${n}" ${n===val?"selected":""}>${n}</option>`).join("")}
  </select>`;

  const rows = (state.categoryLinks||[]).map((ln,i)=>`
    <div class="p-2 border rounded flex flex-col sm:flex-row sm:items-center sm:justify-between">
      <div class="flex flex-wrap items-center gap-2 text-sm">
        Quelle: ${catSel(`data-l-from="${i}"`, ln.from||catNames[0])}
        <span>‚Üí</span>
        Ziel: ${catSel(`data-l-to="${i}"`, ln.to||catNames[0])}
        <select class="input text-xs" data-l-type="${i}">
          <option value="flat" ${ln.type==="flat"?"selected":""}>+Punkte</option>
          <option value="percent" ${ln.type==="percent"?"selected":""}>+% vom Ziel</option>
        </select>
        <input class="input text-xs w-20" data-l-amount="${i}" type="number" step="1" value="${Number(ln.amount||0)}" />
        <label class="text-xs flex items-center gap-1">
          <input type="checkbox" data-l-group="${i}" ${ln.groupOnly? "checked":""} />
          nur gleiche Gruppe
        </label>
        <label class="text-xs">Zeitraum (Tage):
          <input class="input text-xs w-16" data-l-window="${i}" type="number" step="1" value="${Number(ln.windowDays||1)}" />
        </label>
      </div>
      <div class="mt-2 sm:mt-0">
        <button class="btn text-xs" data-l-del="${i}">L√∂schen</button>
      </div>
    </div>
  `).join("");

  panel.innerHTML = `
    <div class="mt-6 p-3 border rounded bg-white">
      <div class="flex items-center justify-between">
        <h3 class="font-bold">üîó Kategorie-Verkn√ºpfungen (lokal)</h3>
        <button id="btnAddLink" class="btn">+ Link</button>
      </div>
      <div class="text-xs text-slate-600 mt-1">
        Wirkt nur, wenn im definierten Zeitraum zuvor eine Aufgabe aus ‚ÄûQuelle‚Äú erledigt wurde
        <b>und</b> (falls aktiviert) dieselbe <i>Gruppe</i> wie die aktuelle Aufgabe hat.
      </div>
      <div class="mt-3 grid gap-2" id="linksRows">${rows || `<div class="text-sm text-slate-500">Keine Verkn√ºpfungen.</div>`}</div>
    </div>
  `;

  // Add
  document.getElementById("btnAddLink").addEventListener("click", ()=>{
    const first = catNames[0] || "Allgemein";
    state.categoryLinks.push({from:first, to:first, type:"percent", amount:10, groupOnly:true, windowDays:1});
    save(); renderAll();
  });

  // Bind edits
  panel.querySelectorAll("[data-l-from]").forEach(sel=>{
    const i = Number(sel.getAttribute("data-l-from"));
    sel.addEventListener("change", ()=>{ state.categoryLinks[i].from = sel.value; save(); });
  });
  panel.querySelectorAll("[data-l-to]").forEach(sel=>{
    const i = Number(sel.getAttribute("data-l-to"));
    sel.addEventListener("change", ()=>{ state.categoryLinks[i].to = sel.value; save(); });
  });
  panel.querySelectorAll("[data-l-type]").forEach(sel=>{
    const i = Number(sel.getAttribute("data-l-type"));
    sel.addEventListener("change", ()=>{ state.categoryLinks[i].type = sel.value; save(); });
  });
  panel.querySelectorAll("[data-l-amount]").forEach(inp=>{
    const i = Number(inp.getAttribute("data-l-amount"));
    inp.addEventListener("change", ()=>{ state.categoryLinks[i].amount = Number(inp.value||0); save(); });
  });
  panel.querySelectorAll("[data-l-group]").forEach(chk=>{
    const i = Number(chk.getAttribute("data-l-group"));
    chk.addEventListener("change", ()=>{ state.categoryLinks[i].groupOnly = !!chk.checked; save(); });
  });
  panel.querySelectorAll("[data-l-window]").forEach(inp=>{
    const i = Number(inp.getAttribute("data-l-window"));
    inp.addEventListener("change", ()=>{ state.categoryLinks[i].windowDays = Math.max(0, Number(inp.value||1)); save(); });
  });
  panel.querySelectorAll("[data-l-del]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.getAttribute("data-l-del"));
      state.categoryLinks.splice(i,1);
      save(); renderAll();
    });
  });
}

/* ---------- Katalog-Render um Links-Panel erweitern ---------- */
(function patchCatalogToRenderLinks(){
  if(window.__categoryLinksCatalogPatched) { renderCategoryLinksPanel(); return; }
  const prev = (typeof renderCatalog==="function") ? renderCatalog : null;
  renderCatalog = function(){
    if(prev) prev();
    // unser Editor (Kategorie+Gruppe) wird in overrideQuestCategoryEditors bereits gesetzt
    renderCategoryLinksPanel();
  };
  window.__categoryLinksCatalogPatched = true;
})();

/* ---------- Dashboard: kleine Info bei Link-Boni am letzten Eintrag ---------- */
(function showLastLinkBonusOnDashboard(){
  if(window.__linkBadgeDashboardPatched) return;
  const prev = (typeof renderDashboard==="function") ? renderDashboard : null;
  renderDashboard = function(){
    if(prev) prev();
    try{
      const last = state.log[state.log.length-1];
      if(last && last.linkBonus){
        const host = document.getElementById("tab-dashboard");
        const info = document.createElement("div");
        info.className = "mt-2 p-2 border rounded bg-indigo-50 text-sm";
        info.textContent = `üîó Link-Bonus: +${last.linkBonus} Punkte auf "${last.quest}"`;
        host.appendChild(info);
      }
    }catch(e){}
  };
  window.__linkBadgeDashboardPatched = true;
})();
/* ==================== Part 20: Negative Kategorien + getrennte Kategoriepunkte ====================
   Ziel:
   - Quests k√∂nnen ‚Äûnegativ‚Äú sein (z. B. Kategorie ‚ÄûSchlechter Lebensstil‚Äú).
   - Bei negativen Quests:
       ‚Ä¢ Die Kategorie bekommt einen POSITIVEN Zuwachs (Kategorie-Score),
       ‚Ä¢ die Gesamtpunkte erhalten eine SEPARATE, NEGATIVE Wirkung (globaler Abzug).
     Beispiel ‚Äû1 Joint geraucht‚Äú: Kategorie +15, Global ‚àí30.
   - F√ºr normale Quests bleibt Kategorie-Score == tats√§chlich verbuchte Punkte (inkl. Boni).
   - √úbersicht der Kategorie-Summen auf dem Dashboard.
   - Katalog-Editor: pro Quest ‚ÄûGruppe‚Äú, ‚ÄûKategorie‚Äú, **und** ‚ÄûNegativ?‚Äú inkl. Felder
     ‚ÄûKategorie +‚Äú und ‚ÄûGlobal ‚àí‚Äú konfigurierbar (quest-spezifische Regeln).
   - KEINE globalen Boni ‚Äì Verkn√ºpfungen aus Part 19 bleiben lokal/pro kontext.
==================================================================================================== */

/* ---------- Sicherstellen von Basis-Strukturen & Helfern ---------- */
state.categories = state.categories || {"Allgemein":{negative:false}};

function getQuestByName(name){
  return (state.catalog||[]).find(q=>q.name===name) || null;
}
function categoryOfQuest(name){
  const q = getQuestByName(name);
  return (q && q.category) ? q.category : "Allgemein";
}
function isSystemEntry(e){
  const t = (e?.quest||"").toLowerCase();
  return (
    t.startsWith("reward") ||
    t.includes("event-bonus") ||
    t.includes("timed quest verpasst") ||
    t.startsWith("milestone") ||
    t.includes("tagesziel bonus") ||
    t.includes("reward-kauf")
  );
}

/* Alle vorhandenen Katalogeintr√§ge auf neue Felder normalisieren */
(state.catalog||[]).forEach(q=>{
  if(typeof q.category === "undefined") q.category = "Allgemein";
  if(typeof q.group === "undefined") q.group = "";
  // Negative-Defaults nur setzen, wenn markiert
  if(q.negative && (typeof q.negCatAdd === "undefined")) q.negCatAdd = Math.max(1, Number(q.points||1));
  if(q.negative && (typeof q.negGlobalMinus === "undefined")) q.negGlobalMinus = q.negCatAdd*2;
});

/* ---------- Kategorie-Summen (f√ºr Anzeige) ---------- */
function computeCategorySums(){
  const sums = {};
  (state.log||[]).forEach(e=>{
    // Kategorie ableiten
    const baseName = (e.quest||"").replace(/\s*\(.*\)$/,"");
    const cat = e.category || categoryOfQuest(baseName);
    if(!cat) return;

    // F√ºr die Kategorienutzung z√§hlt e.catDelta, wenn vorhanden; sonst e.points
    const delta = (typeof e.catDelta !== "undefined") ? Number(e.catDelta) : Number(e.points||0);
    sums[cat] = (sums[cat]||0) + delta;
  });
  return sums;
}
(function patchDashboardCategorySums(){
  if(window.__catSumsPatched) return;
  const prev = (typeof renderDashboard==="function") ? renderDashboard : null;
  renderDashboard = function(){
    if(prev) prev();
    try{
      const host = document.getElementById("tab-dashboard");
      if(!host) return;
      const box = document.createElement("div");
      box.className = "mt-4 p-3 border rounded bg-white";
      const sums = computeCategorySums();
      // Reihenfolge: bekannte Kategorien zuerst, dann ggf. weitere
      const catList = Object.keys(state.categories||{});
      const extra   = Object.keys(sums).filter(c=>!catList.includes(c));
      const ordered = catList.concat(extra);

      const rows = ordered.length
        ? ordered.map(c=>`
            <div class="flex justify-between text-sm">
              <span>${c}</span>
              <span class="font-medium">${(sums[c]||0)}</span>
            </div>`).join("")
        : `<div class="text-sm text-slate-500">Noch keine Kategorien vorhanden.</div>`;

      box.innerHTML = `<h3 class="font-bold">Kategorie-√úbersicht</h3>${rows}`;
      host.appendChild(box);
    }catch(e){}
  };
  window.__catSumsPatched = true;
})();

/* ---------- addLogEntry patchen: neg. Kategorie-Regeln anwenden ---------- */
(function patchAddLogEntryForNegatives(){
  if(window.__negPatchAddLogEntry) return;

  const prev = (typeof addLogEntry==="function") ? addLogEntry : null;

  addLogEntry = function(dateISO, questName, noteOrReason=null, basePointsOverride=null){
    // 1) normalen Eintrag (inkl. Streak/Perks/Links aus fr√ºheren Parts) erzeugen
    const entry = prev ? prev(dateISO, questName, noteOrReason, basePointsOverride) : (()=>{
      // Fallback (falls prev unerwartet fehlt)
      let q = getQuestByName(questName);
      if(!q){
        q = {name: questName, points: (basePointsOverride!=null?basePointsOverride:5), category:"Allgemein", group:""};
        state.catalog = state.catalog || [];
        state.catalog.push(q);
      }
      const base = (basePointsOverride!=null?basePointsOverride:(q.points||0));
      const pts  = computePoints(base, dateISO);
      const e = {date:dateISO, quest:questName+(noteOrReason?` (${noteOrReason})`:""), points:pts, base:base, category:q.category};
      state.log.push(e); save(); renderAll();
      return e;
    })();

    // 2) Negative-Logik anwenden (quest-spezifisch oder √ºber Kategorie)
    try{
      const q   = getQuestByName(questName);
      const cat = entry.category || (q?.category || "Allgemein");

      // Ist die Quest negativ? (Quest-Flag hat Vorrang; sonst Kategorie-Flag)
      const isNegQuest = !!(q && q.negative) || !!(state.categories?.[cat]?.negative);

      if(isNegQuest){
        // Quest-spezifische Werte haben Vorrang; sonst Default ableiten
        const catAdd      = Number(q?.negCatAdd ?? Math.max(1, Number(q?.points || entry.base || 1)));
        const globalMinus = Number(q?.negGlobalMinus ?? (catAdd * 2));

        // Kategorie-Zuwachs POSITIV separat f√ºhren:
        entry.catDelta = Math.max(0, catAdd);

        // Globale Punkte NEGATIV verbuchen (√ºberschreiben, damit Boni nicht ‚Äûversehentlich‚Äú positiv wirken)
        entry.points   = -Math.abs(globalMinus);

        entry.negApplied = true; // Markierung
        entry.category   = cat;
        save(); renderAll();
      }else{
        // Normale Quests: Kategorie-Zuwachs == verbuchte Punkte (inkl. Boni)
        entry.catDelta = Number(entry.points||0);
        save(); // keine Re-Render-Schleife forcieren ‚Äì das macht addLogEntry(prev) bereits
      }
    }catch(e){ /* still */ }

    return entry;
  };

  window.__negPatchAddLogEntry = true;
})();

/* ---------- Katalog-Editor: Kategorie, Gruppe, NEGATIV mit Feldern integrieren ----------
   Wir √ºberschreiben die in Part 19 ersetzte renderQuestCategoryEditors erneut,
   jetzt mit ‚ÄûNegativ?‚Äú, ‚ÄûKategorie +‚Äú, ‚ÄûGlobal ‚àí‚Äú.
*/
(function overrideQuestEditorsWithNegative(){
  renderQuestCategoryEditors = function(){
    const list = document.getElementById("catalogList");
    if(!list) return;

    const catOptions = Object.keys(state.categories||{"Allgemein":{}}).map(
      c=>`<option value="${c}">${c}</option>`
    ).join("");

    list.innerHTML = (state.catalog||[]).map((q,i)=>`
      <div class="p-2 border rounded mb-1 flex flex-col gap-2 ${q.boss?'bg-yellow-50':'bg-white'}">
        <div class="flex justify-between items-center">
          <div>
            <span>${q.boss?'üëë':''} <b>${q.name}</b> (+${q.points} Punkte)</span>
          </div>
          <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-4 gap-2 items-center">
          <label class="text-xs">Kategorie:
            <select class="input text-xs" data-qcat="${i}">
              ${catOptions}
            </select>
          </label>
          <label class="text-xs">Gruppe:
            <input class="input text-xs" placeholder="z. B. Wohnzimmer" data-qgroup="${i}" value="${q.group||""}">
          </label>

          <label class="text-xs flex items-center gap-2">
            <input type="checkbox" data-qneg="${i}" ${q.negative?"checked":""}>
            Negativ?
          </label>

          <div class="grid grid-cols-2 gap-2" data-qnegbox="${i}" style="${q.negative?'':'display:none'}">
            <label class="text-xs">Kategorie +
              <input class="input text-xs" data-qnegcadd="${i}" type="number" step="1" value="${Number(q.negCatAdd ?? Math.max(1, Number(q.points||1)))}">
            </label>
            <label class="text-xs">Global ‚àí
              <input class="input text-xs" data-qnegminus="${i}" type="number" step="1" value="${Number(q.negGlobalMinus ?? ((q.negCatAdd ?? Math.max(1, Number(q.points||1)))*2))}">
            </label>
          </div>
        </div>
      </div>
    `).join("") + `
      <button id="btnTimedQuestAddAgain2" class="btn w-full bg-purple-600 text-white mt-2">+ Timed Quest</button>
    `;

    // Kategorie setzen/binden
    list.querySelectorAll("[data-qcat]").forEach(sel=>{
      const i = Number(sel.getAttribute("data-qcat"));
      sel.value = state.catalog[i].category || "Allgemein";
      sel.addEventListener("change", ()=>{
        state.catalog[i].category = sel.value || "Allgemein";
        save();
      });
    });

    // Gruppe binden
    list.querySelectorAll("[data-qgroup]").forEach(inp=>{
      const i = Number(inp.getAttribute("data-qgroup"));
      inp.addEventListener("change", ()=>{
        state.catalog[i].group = (inp.value||"").trim();
        save();
      });
    });

    // Negativ-Checkbox + Felder
    list.querySelectorAll("[data-qneg]").forEach(chk=>{
      const i = Number(chk.getAttribute("data-qneg"));
      const box = list.querySelector(`[data-qnegbox="${i}"]`);
      chk.addEventListener("change", ()=>{
        state.catalog[i].negative = !!chk.checked;
        // Defaults setzen, falls gerade aktiviert
        if(state.catalog[i].negative){
          if(typeof state.catalog[i].negCatAdd === "undefined")
            state.catalog[i].negCatAdd = Math.max(1, Number(state.catalog[i].points||1));
          if(typeof state.catalog[i].negGlobalMinus === "undefined")
            state.catalog[i].negGlobalMinus = state.catalog[i].negCatAdd*2;
          if(box) box.style.display = "";
        }else{
          if(box) box.style.display = "none";
        }
        save();
      });
    });

    list.querySelectorAll("[data-qnegcadd]").forEach(inp=>{
      const i = Number(inp.getAttribute("data-qnegcadd"));
      inp.addEventListener("change", ()=>{
        state.catalog[i].negCatAdd = Math.max(0, Number(inp.value||0));
        // Falls Global-‚àí noch nicht gesetzt, plausibel ableiten
        if(typeof state.catalog[i].negGlobalMinus === "undefined" || state.catalog[i].negGlobalMinus===0){
          state.catalog[i].negGlobalMinus = state.catalog[i].negCatAdd*2;
        }
        save();
      });
    });
    list.querySelectorAll("[data-qnegminus]").forEach(inp=>{
      const i = Number(inp.getAttribute("data-qnegminus"));
      inp.addEventListener("change", ()=>{
        state.catalog[i].negGlobalMinus = Math.max(0, Number(inp.value||0));
        save();
      });
    });

    // L√∂schen
    list.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        state.catalog.splice(Number(btn.getAttribute("data-del")),1);
        save(); renderAll();
      });
    });

    // Timed-Quest Button neu binden
    const b2 = document.getElementById("btnTimedQuestAddAgain2");
    if(b2 && typeof addTimedQuest==="function"){
      b2.addEventListener("click", addTimedQuest);
    }
  };
})();

/* ---------- Katalog-Render hooken (damit unser Editor & Links-Panel gerendert wird) ---------- */
(function rehookCatalogForNeg(){
  if(window.__negCatalogHooked) { renderQuestCategoryEditors(); return; }
  const prev = (typeof renderCatalog==="function") ? renderCatalog : null;
  renderCatalog = function(){
    if(prev) prev();
    renderQuestCategoryEditors();   // unser Editor (Kat/Gruppe/Negativ)
    if(typeof renderCategoryLinksPanel==="function") renderCategoryLinksPanel(); // Part 19 Panel
  };
  window.__negCatalogHooked = true;
})();
/* ==================== Part 21: Dynamische Meilensteine + h√∂here Rewards ====================
   Features:
   - Auto-Meilensteine f√ºr:
     ‚Ä¢ Gesamt-Quests (normal, nicht negativ)
     ‚Ä¢ Boss-Quests
     ‚Ä¢ Missionen (fertige Missionen; Fallback auf 0, falls Missionssystem sp√§ter kommt)
     ‚Ä¢ Jede Kategorie (Z√§hlung der erledigten Quests je Kategorie; negative Kategorien werden nicht belohnt)
   - ‚Äûundefined‚Äú-Fix: Labels werden immer sinnvoll gebaut.
   - Rewards sp√ºrbar h√∂her (nach deinen Beispielen):
     ‚Ä¢ Quests:      Reward = (Threshold^2)/100  (z. B. 100‚Üí100, 200‚Üí400, 500‚Üí2500)
     ‚Ä¢ Bossquests:  Bis 40 linear (t*10), ab 50 stark (t^2) ‚Üí 10‚Üí100, 20‚Üí200, 50‚Üí2500
     ‚Ä¢ Missionen:   Reward = Threshold^2        (z. B. 10‚Üí100, 20‚Üí400, 50‚Üí2500)
     ‚Ä¢ Kategorien:  Reward = Threshold*10       (motivierende, aber moderatere Steigerung)
   - Endlos: Nach Erreichen wird automatisch der n√§chste sinnvolle Threshold gesetzt
     (vordefinierte Serien, danach Verdopplung).
   - Anzeige im Dashboard mit Fortschritt & ‚ÄûEinl√∂sen‚Äú-Button.
================================================================================================ */

/* ---------- Helpers & Safe Defaults ---------- */
function _isSystemEntry(e){
  const t = (e?.quest||"").toLowerCase();
  return (
    t.startsWith("reward") ||
    t.includes("event-bonus") ||
    t.includes("timed quest verpasst") ||
    t.startsWith("milestone") ||
    t.includes("tagesziel bonus") ||
    t.includes("reward-kauf")
  );
}
function _getQuest(qname){
  return (state.catalog||[]).find(q=>q.name===qname) || null;
}
function _isNegativeQuest(qname){
  const q = _getQuest(qname);
  if(!q) return false;
  return !!q.negative;
}
function _isBossQuest(qname){
  const q = _getQuest(qname);
  return !!(q && q.boss);
}
function _categoryOf(qname){
  const q = _getQuest(qname);
  return (q && q.category) ? q.category : "Allgemein";
}

/* ---------- Z√§hler (Counts) ---------- */
// Normale Quest-Abschl√ºsse: nur nicht-System, nicht negativ
function countTotalQuests(){
  return (state.log||[]).filter(e=>{
    if(_isSystemEntry(e)) return false;
    if(_isNegativeQuest(e.quest)) return false;
    return true;
  }).length;
}
// Boss-Abschl√ºsse (per Name -> aktueller Katalog)
function countBossQuests(){
  return (state.log||[]).filter(e=>{
    if(_isSystemEntry(e)) return false;
    return _isBossQuest(e.quest);
  }).length;
}
// Missionen (Fallback auf 0, falls System noch nicht aktiv)
function countMissionsDone(){
  if(Array.isArray(state.missions)) return state.missions.filter(m=>m && m.done).length;
  if(typeof state.missionsCompleted === "number") return state.missionsCompleted;
  return 0;
}
// Kategorie-Counts (je Kategorie; negative Kategorien belohnen wir NICHT)
function countCategoryDoneMap(){
  const map = {};
  const cats = state.categories || {"Allgemein":{negative:false}};
  (state.log||[]).forEach(e=>{
    if(_isSystemEntry(e)) return;
    const cat = (e.category) ? e.category : _categoryOf(e.quest);
    if(!cat) return;
    if(cats[cat]?.negative) return; // negative Kategorien bekommen keine Belohnungs-Meilensteine
    map[cat] = (map[cat]||0)+1;
  });
  return map;
}

/* ---------- Threshold-Serien & Reward-Formeln ---------- */
const SERIES_QUESTS   = [100,200,500,1000,2000,5000,10000];
const SERIES_BOSS     = [10,20,50,100,200,500];
const SERIES_MISSIONS = [5,10,20,50,100,200,500];
const SERIES_CATEGORY = [25,50,100,200,500,1000,2000];

function nextFromSeries(currentCount, series){
  // N√§chstgr√∂√üeres Element, sonst Verdopplung
  for(const t of series){ if(t>currentCount) return t; }
  return Math.max(1, Math.ceil(currentCount*2));
}

// Rewards nach Regelwerk / Beispielen
function rewardForQuests(th){
  return Math.round((th*th)/100); // 100‚Üí100, 200‚Üí400, 500‚Üí2500
}
function rewardForBoss(th){
  if(th>=50) return th*th;         // 50‚Üí2500 (starker Sprung ab 50)
  return th*10;                    // 10‚Üí100, 20‚Üí200
}
function rewardForMissions(th){
  return th*th;                    // 10‚Üí100, 20‚Üí400, 50‚Üí2500
}
function rewardForCategory(th){
  return th*10;                    // motivierend, aber moderater als Boss/Mission
}

/* ---------- State f√ºr Meilensteine V2 ---------- */
state.milestonesV2 = state.milestonesV2 || {
  quests:   { next: 100 },
  bosses:   { next: 10  },
  missions: { next: 5   },
  cats:     {}          // pro Kategorie { next: X }
};

/* Kategorien initialisieren (falls neu) */
(function initCatMilestones(){
  const cats = Object.keys(state.categories||{"Allgemein":{negative:false}});
  cats.forEach(c=>{
    if(!state.milestonesV2.cats[c]){
      state.milestonesV2.cats[c] = { next: SERIES_CATEGORY[0] };
    }
  });
})();

/* ---------- Einl√∂sen-Logik ---------- */
function claimMilestone(label, reward){
  // Eintrag schreiben
  state.log.push({date: todayISO(), quest: `Milestone: ${label}`, points: reward});
  save(); renderAll();
}

/* ---------- Fortschrittsbox im Dashboard ---------- */
(function patchDashboardMilestones(){
  if(window.__msV2Patched) return;
  const prev = (typeof renderDashboard==="function") ? renderDashboard : null;

  renderDashboard = function(){
    if(prev) prev();

    try{
      const host = document.getElementById("tab-dashboard");
      if(!host) return;

      // Aktuelle Counts
      const qCount   = countTotalQuests();
      const bCount   = countBossQuests();
      const mCount   = countMissionsDone();
      const catMap   = countCategoryDoneMap();
      const catsAll  = Object.keys(state.categories||{"Allgemein":{negative:false}});
      // sicherstellen, dass state und Anzeige synchron sind
      catsAll.forEach(c=>{
        if(!state.milestonesV2.cats[c]){
          state.milestonesV2.cats[c] = { next: SERIES_CATEGORY[0] };
        }
      });

      // N√§chste Schwellen aus State lesen / ggf. nachziehen
      const qNext = state.milestonesV2.quests.next  || (state.milestonesV2.quests.next = SERIES_QUESTS[0]);
      const bNext = state.milestonesV2.bosses.next  || (state.milestonesV2.bosses.next = SERIES_BOSS[0]);
      const mNext = state.milestonesV2.missions.next|| (state.milestonesV2.missions.next = SERIES_MISSIONS[0]);

      const box = document.createElement("div");
      box.className = "mt-4 p-3 border rounded bg-orange-50";
      box.innerHTML = `<h3 class="font-bold mb-2">üéØ Meilensteine</h3>`;

      function row(label, count, next, reward, onClaim){
        const pct = Math.max(0, Math.min(100, Math.round((count/next)*100)));
        const ready = count>=next;
        return `
          <div class="mb-2">
            <div class="flex justify-between text-sm">
              <span>${label}</span>
              <span>${count} / ${next}</span>
            </div>
            <div class="w-full bg-gray-200 rounded h-2 mt-1">
              <div class="bg-amber-500 h-2 rounded" style="width:${pct}%"></div>
            </div>
            <div class="flex justify-between items-center mt-1">
              <span class="text-xs">Belohnung: <b>+${reward}</b> Punkte</span>
              <button class="btn text-xs ${ready?'bg-amber-600 text-white':'opacity-50'}" ${ready?'':'disabled'} data-claim="${onClaim}">Einl√∂sen</button>
            </div>
          </div>
        `;
      }

      // Hauptgruppen
      const qReward = rewardForQuests(qNext);
      const bReward = rewardForBoss(bNext);
      const mReward = rewardForMissions(mNext);

      let html = "";
      html += row("Quests gesamt", qCount, qNext, qReward, "quests");
      html += row("Bossquests",     bCount, bNext, bReward, "bosses");
      html += row("Missionen",      mCount, mNext, mReward, "missions");

      // Kategorien (nur positive Kategorien)
      const cats = Object.keys(state.categories||{"Allgemein":{negative:false}}).filter(c=>!state.categories[c]?.negative);
      if(cats.length){
        html += `<div class="mt-3 text-sm font-semibold">Kategorien</div>`;
        cats.forEach(c=>{
          const cCount = catMap[c]||0;
          const cNext  = state.milestonesV2.cats[c].next || (state.milestonesV2.cats[c].next = SERIES_CATEGORY[0]);
          const cReward = rewardForCategory(cNext);
          html += row(`${c}`, cCount, cNext, cReward, `cat:${c}`);
        });
      }

      box.innerHTML += html;
      host.appendChild(box);

      // Claim-Handler
      box.querySelectorAll("[data-claim]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const key = btn.getAttribute("data-claim");

          if(key==="quests"){
            // Reward
            claimMilestone(`Quests ${qNext}`, qReward);
            // n√§chsten Threshold setzen
            state.milestonesV2.quests.next = nextFromSeries(qNext, SERIES_QUESTS);
            save(); renderAll();
            return;
          }

          if(key==="bosses"){
            claimMilestone(`Bossquests ${bNext}`, bReward);
            state.milestonesV2.bosses.next = nextFromSeries(bNext, SERIES_BOSS);
            save(); renderAll();
            return;
          }

          if(key==="missions"){
            claimMilestone(`Missionen ${mNext}`, mReward);
            state.milestonesV2.missions.next = nextFromSeries(mNext, SERIES_MISSIONS);
            save(); renderAll();
            return;
          }

          if(key.startsWith("cat:")){
            const cat = key.slice(4);
            const cNext = state.milestonesV2.cats[cat].next || SERIES_CATEGORY[0];
            const cReward = rewardForCategory(cNext);
            claimMilestone(`Kategorie ${cat} ${cNext}`, cReward);
            state.milestonesV2.cats[cat].next = nextFromSeries(cNext, SERIES_CATEGORY);
            save(); renderAll();
            return;
          }
        });
      });

    }catch(e){
      // fail-silent, Dashboard rendert trotzdem
    }
  };

  window.__msV2Patched = true;
})();

/* ---------- Missionsabschluss-Helper (4x Belohnung) ----------
   Wenn dein Missionssystem sp√§ter eine Mission als ‚Äûfertig‚Äú markiert,
   rufe einfach:
     completeMission("Wohnzimmer", basePointsTotalDerMission)
   ‚Üí schreibt automatisch 4x Punkte in das Log.
*/
window.completeMission = function(missionName, basePointsTotal){
  const pts = Math.max(0, Number(basePointsTotal||0)) * 4;
  state.log.push({
    date: todayISO(),
    quest: `Mission abgeschlossen: ${missionName}`,
    points: pts
  });
  // Missionsz√§hler aktualisieren (Kompatibilit√§t mit countMissionsDone)
  if(Array.isArray(state.missions)){
    const m = state.missions.find(x=>x && x.name===missionName);
    if(m) m.done = true;
  }else{
    state.missionsCompleted = (state.missionsCompleted||0) + 1;
  }
  save(); renderAll();
};
/* ======================== Part 22: Chat-Tab fix + Aktivierung =========================
   Ziele:
   - Chat-Tab garantiert klickbar (Bottom-Nav) & sichtbar (#tab-chat)
   - Einheitliche Message-Ausgabe (chatWindow bevorzugt, fallback chatLog)
   - Senden per Button (#btnChatSend ODER #btnChat) und per Enter im Input
   - Kompatibilit√§ts-Wrapper: renderChat/chatAddMessage sicher verf√ºgbar
   - Kein Doppel-Binden von Events
======================================================================================= */
(function activateChat(){
  if(window.__chatFixed) return; // nur einmal
  window.__chatFixed = true;

  /* ---- Utilities ---- */
  function getChatBox(){
    return document.getElementById("chatWindow") || document.getElementById("chatLog");
  }
  function scrollToBottom(){
    const box = getChatBox();
    if(box){ box.scrollTop = box.scrollHeight; }
  }
  function el(id){ return document.getElementById(id); }

  // universelle Message-Funktion (Bubbles + optional Buttons)
  function appendChatMessage(text, role="bot", buttons=[]){
    const box = getChatBox();
    if(!box) return;
    const line = document.createElement("div");
    line.className = (role==="user")
      ? "text-right"
      : "text-left text-blue-700";
    line.textContent = String(text);
    box.appendChild(line);

    if(Array.isArray(buttons) && buttons.length){
      const row = document.createElement("div");
      row.className = "flex flex-wrap gap-2 my-1";
      buttons.forEach(b=>{
        const btn = document.createElement("button");
        btn.className = "btn text-xs";
        btn.textContent = "‚ûï "+b.label;
        btn.addEventListener("click", ()=>{
          const today = (typeof todayISO==="function") ? todayISO() : new Date().toISOString().slice(0,10);
          const base = Number(b.points||0);
          const pts  = (typeof computePoints==="function") ? computePoints(base,today) : base;
          if(!window.state) return;
          window.state.log.push({date:today,quest:b.label,points:pts,base});
          if(typeof save==="function") save();
          if(typeof renderAll==="function") renderAll();
          appendChatMessage(`‚úÖ Eingetragen: ${b.label} (+${pts} Punkte)`,"bot");
        });
        row.appendChild(btn);
      });
      box.appendChild(row);
    }

    scrollToBottom();
  }

  // Kompatibilit√§t: Falls irgendwo renderChat/chatAddMessage genutzt wird
  if(typeof window.chatAddMessage!=="function"){
    window.chatAddMessage = appendChatMessage;
  }
  if(typeof window.renderChat!=="function"){
    window.renderChat = (msg, from="bot", buttons=[])=>appendChatMessage(msg, from, buttons);
  }

  /* ---- Chat-UI sicherstellen (fallback, falls #tab-chat fehlt) ---- */
  (function ensureChatSection(){
    if(document.getElementById("tab-chat")) return;
    const main = document.querySelector("main");
    if(!main) return;
    const sec = document.createElement("section");
    sec.id = "tab-chat";
    sec.className = "tab space-y-4";
    sec.innerHTML = `
      <div class="card p-3 space-y-2">
        <div id="chatWindow" class="h-64 overflow-y-auto border p-2 rounded bg-white text-sm"></div>
        <div class="flex gap-2">
          <input id="chatInput" class="input flex-1" placeholder="Schreib etwas..." />
          <button id="btnChatSend" class="btn bg-blue-600 text-white">Senden</button>
        </div>
      </div>
    `;
    main.appendChild(sec);
  })();

  /* ---- Bottom-Nav: Chat-Button sicherstellen & Tab-Switch robust ---- */
  (function ensureNav(){
    const navGrid = document.querySelector("nav .grid");
    if(!navGrid) return;

    // Chat-Button anlegen, falls nicht vorhanden
    if(!navGrid.querySelector('[data-tab="chat"]')){
      const btn = document.createElement("button");
      btn.dataset.tab = "chat";
      btn.className = "py-3";
      btn.textContent = "Chat";
      navGrid.appendChild(btn);

      // Spaltenanzahl ggf. auf 5 erh√∂hen
      if(navGrid.classList.contains("grid-cols-4")){
        navGrid.classList.remove("grid-cols-4");
        navGrid.classList.add("grid-cols-5");
      }
    }

    // Einheitliche Tab-Umschaltung (nur einmal binden)
    navGrid.querySelectorAll("[data-tab]").forEach(btn=>{
      if(btn.__boundTab) return;
      btn.__boundTab = true;
      btn.addEventListener("click", ()=>{
        const tab = btn.getAttribute("data-tab");
        document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
        const target = document.getElementById("tab-"+tab);
        if(target) target.classList.add("active");
        navGrid.querySelectorAll("[data-tab]").forEach(b=>b.classList.remove("text-blue-600"));
        btn.classList.add("text-blue-600");
      });
    });
  })();

  /* ---- Senden-Handler (Buttons + Enter) ---- */
  function doSend(){
    const input = el("chatInput");
    const text  = (input?.value||"").trim();
    if(!text) return;
    appendChatMessage(text,"user");
    // processMessage nutzen, aber robust bleiben
    try{
      const out = (typeof processMessage==="function") ? processMessage(text) : [];
      if(Array.isArray(out) && out.length){
        out.forEach(line=>appendChatMessage(line,"bot"));
      }
    }catch(err){
      appendChatMessage("‚ö†Ô∏è Chat-Fehler: "+(err?.message||err),"bot");
    }
    if(input) input.value = "";
  }

  function bindSenders(){
    const btnPrimary = el("btnChatSend");
    const btnLegacy  = el("btnChat"); // falls √§ltere ID existiert
    const input      = el("chatInput");

    if(btnPrimary && !btnPrimary.__boundSend){
      btnPrimary.__boundSend = true;
      btnPrimary.addEventListener("click", doSend);
    }
    if(btnLegacy && !btnLegacy.__boundSend){
      btnLegacy.__boundSend = true;
      btnLegacy.addEventListener("click", doSend);
    }
    if(input && !input.__boundEnter){
      input.__boundEnter = true;
      input.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){ e.preventDefault(); doSend(); }
      });
    }
  }
  bindSenders();

  /* ---- Falls Render neu aufbaut (SPA-Style), Sender erneut binden ---- */
  const _oldRenderAll = (typeof renderAll==="function") ? renderAll : null;
  if(_oldRenderAll){
    window.renderAll = function(){
      _oldRenderAll();
      bindSenders();
    };
  }

  // Erste Info, wenn jemand den Tab √∂ffnet und noch nichts im Chat steht
  const firstPaintHint = ()=>{
    const box = getChatBox();
    if(!box) return;
    if(box.childElementCount===0){
      appendChatMessage("üëã Hi! Schreib z. B. ‚ÄûWas soll ich tun?‚Äú oder ‚Äûzeige Level‚Äú.","bot");
    }
  };
  firstPaintHint();
})();
/* ==================== Part 23: Kategorien-√úbersicht + Summen ==================== 
   Ziele:
   - Kategorien f√ºr Quests einf√ºhren (nicht-invasiv, bestehende Daten werden migriert)
   - Bei allen Log-Eintr√§gen fehlende Kategorie nachtragen
   - Summen je Kategorie anzeigen (Dashboard + im Katalog unten)
   - Kompatibel mit vorhandenem Render-Flow & sp√§terer Kategorie-Verwaltung
================================================================================= */
(function categoriesOverview(){
  if(window.__categoriesOverview) return;
  window.__categoriesOverview = true;

  /* ---------- State-Bootstrap ---------- */
  // Standard-Kategorien (k√∂nnen sp√§ter bearbeitet/erweitert werden)
  const DEFAULT_CATS = [
    "Allgemein",
    "Sport",
    "Haushalt",
    "Ern√§hrung",
    "Arbeit",
    "Gesundheit",
    "Hobby",
    "Negativ: Schlechter Lebensstil"
  ];

  // Stelle Container bereit
  window.state = window.state || {};
  state.catalog = state.catalog || [];
  state.categories = state.categories || DEFAULT_CATS.slice();

  // Auto-Kategorisierung f√ºr bestehende Quests (nur wenn noch keine gesetzt)
  function autoCategory(name){
    const n = (name||"").toLowerCase();
    if(n.includes("sport")||n.includes("workout")||n.includes("laufen")||n.includes("liegest√ºtz")) return "Sport";
    if(n.includes("aufr√§um")||n.includes("putz")||n.includes("keller")||n.includes("k√ºche")) return "Haushalt";
    if(n.includes("essen")||n.includes("kochen")||n.includes("fast food")||n.includes("zucker")) return "Ern√§hrung";
    if(n.includes("arbeit")||n.includes("task")||n.includes("projekt")||n.includes("job")) return "Arbeit";
    if(n.includes("gesund")||n.includes("arzt")||n.includes("medit")||n.includes("schlaf")) return "Gesundheit";
    if(n.includes("hobby")||n.includes("lernen")||n.includes("gitarre")||n.includes("lesen")) return "Hobby";
    if(n.includes("joint")||n.includes("kater")||n.includes("junkfood")||n.includes("rauchen")) return "Negativ: Schlechter Lebensstil";
    return "Allgemein";
  }

  // Katalog-Migration: fehlende category setzen
  state.catalog.forEach(q=>{
    if(!q.category){
      q.category = autoCategory(q.name);
    }
    // Stelle sicher, dass die Kategorie im Set existiert
    if(!state.categories.includes(q.category)){
      state.categories.push(q.category);
    }
  });

  // Hilfen
  const todayISO = (typeof window.todayISO==="function")
    ? window.todayISO
    : ()=>new Date().toISOString().slice(0,10);

  function getQuestCategory(qname){
    const q = state.catalog.find(x=>x.name===qname);
    return q?.category || autoCategory(qname);
  }

  // Logs normalisieren: fehlende e.cat nachtragen
  function normalizeLogCategories(){
    if(!Array.isArray(state.log)) state.log = [];
    let changed = false;
    state.log.forEach(e=>{
      if(!e.cat){
        e.cat = getQuestCategory(e.quest);
        changed = true;
      }
      // Sicherheitsnetz: unbekannte Kategorie zum Pool hinzuf√ºgen
      if(e.cat && !state.categories.includes(e.cat)){
        state.categories.push(e.cat);
        changed = true;
      }
    });
    if(changed && typeof save==="function") save();
  }
  normalizeLogCategories();

  // Hook in addLog: nach dem Eintragen die Kategorie mitschreiben
  const _oldAddLog = (typeof window.addLog==="function") ? window.addLog : null;
  if(_oldAddLog){
    window.addLog = function(){
      const lenBefore = state.log.length;
      _oldAddLog.apply(this, arguments);
      const last = state.log[state.log.length-1];
      if(state.log.length>lenBefore && last){
        if(!last.cat){ last.cat = getQuestCategory(last.quest); }
        if(last.cat && !state.categories.includes(last.cat)){
          state.categories.push(last.cat);
        }
        if(typeof save==="function") save();
      }
    };
  }

  // Falls Logs auch direkt via state.log.push(...) hinzugef√ºgt werden:
  // Nach jedem Render normalisieren
  const _oldRenderAll = (typeof window.renderAll==="function") ? window.renderAll : null;
  if(_oldRenderAll){
    window.renderAll = function(){
      _oldRenderAll();
      normalizeLogCategories();
    };
  }

  /* ---------- Summen-Berechnung ---------- */
  function categoryTotals(days=null){
    // days=null => All-Time; days=30 => letzte 30 Tage
    const map = new Map();
    const cutoff = days ? (()=>{ const d=new Date(); d.setDate(d.getDate()-days+1); return d; })() : null;

    state.log.forEach(e=>{
      if(!e.cat) return;
      if(cutoff){
        const d = new Date(e.date);
        if(d < cutoff) return;
      }
      map.set(e.cat, (map.get(e.cat)||0) + Number(e.points||0));
    });

    // Alle bekannten Kategorien zumindest mit 0 ausgeben
    state.categories.forEach(c=>{
      if(!map.has(c)) map.set(c,0);
    });

    // Sortierung: Punkte absteigend, dann Name
    const arr = Array.from(map.entries()).sort((a,b)=>{
      if(b[1]!==a[1]) return b[1]-a[1];
      return a[0].localeCompare(b[0]);
    });
    return arr;
  }

  /* ---------- UI: Dashboard-Box ---------- */
  function renderCategoryOverviewDashboard(){
    normalizeLogCategories();
    const dash = document.getElementById("tab-dashboard");
    if(!dash) return;

    // Vorherige Box ersetzen
    let box = document.getElementById("catOverviewDash");
    if(box) box.remove();

    box = document.createElement("div");
    box.id = "catOverviewDash";
    box.className = "mt-4 p-3 border rounded bg-white";
    box.innerHTML = `
      <h3 class="font-bold mb-2">Kategorien (Summe gesamt)</h3>
      <div id="catListAll" class="space-y-1"></div>
    `;
    dash.appendChild(box);

    const listAll = box.querySelector("#catListAll");
    const all = categoryTotals(null); // All-Time
    if(all.length===0){
      listAll.innerHTML = `<div class="text-sm text-slate-500">Noch keine Daten</div>`;
    }else{
      listAll.innerHTML = all.map(([cat,sum])=>`
        <div class="flex justify-between text-sm">
          <span>${cat}</span>
          <span class="${sum<0?'text-red-600':''}">${sum} Punkte</span>
        </div>
      `).join("");
    }
  }

  // Hook Dashboard
  const _oldRenderDashboard = (typeof window.renderDashboard==="function") ? window.renderDashboard : null;
  if(_oldRenderDashboard){
    window.renderDashboard = function(){
      _oldRenderDashboard();
      renderCategoryOverviewDashboard();
    };
  }else{
    // Fallback, einmalig nach DOM ready versuchen
    setTimeout(renderCategoryOverviewDashboard, 0);
  }

  /* ---------- UI: Katalog-Box (unterhalb der Liste) ---------- */
  function renderCategoryOverviewCatalog(){
    normalizeLogCategories();
    const listWrap = document.getElementById("catalogList");
    if(!listWrap) return;

    // Vorherige Box ersetzen
    let box = document.getElementById("catOverviewCatalog");
    if(box) box.remove();

    box = document.createElement("div");
    box.id = "catOverviewCatalog";
    box.className = "mt-4 p-3 border rounded bg-gray-50";
    box.innerHTML = `
      <h3 class="font-bold mb-2">Kategorien (Summe gesamt)</h3>
      <div id="catListAllCatalog" class="space-y-1"></div>
    `;
    listWrap.parentElement?.appendChild(box);

    const listAll = box.querySelector("#catListAllCatalog");
    const all = categoryTotals(null);
    listAll.innerHTML = all.map(([cat,sum])=>`
      <div class="flex justify-between text-sm">
        <span>${cat}</span>
        <span class="${sum<0?'text-red-600':''}">${sum} Punkte</span>
      </div>
    `).join("");
  }

  // Hook Katalogrender: Wir h√§ngen uns NACH der bisherigen Katalog-Logik ein
  const _oldRenderCatalog = (typeof window.renderCatalog==="function") ? window.renderCatalog : null;
  if(_oldRenderCatalog){
    window.renderCatalog = function(){
      _oldRenderCatalog();
      // Zus√§tzlich: Quest-Zeilen im Katalog um Kategorie-Label erg√§nzen (falls nicht schon vorhanden)
      try{
        const list = document.getElementById("catalogList");
        if(list){
          // alle Quest-Kacheln um Kategorie erg√§nzen
          list.querySelectorAll("div.p-2.border.rounded").forEach((row)=>{
            // nur einmal labeln
            if(row.__labeledCat) return;
            row.__labeledCat = true;
            const span = row.querySelector("span");
            if(span){
              const nameText = span.textContent||"";
              // Questname ermitteln
              const match = nameText.match(/^\s*(üëë\s*)?(.+?)\s+\(\+\d+/);
              const questName = match ? match[2].trim() : nameText.trim();
              const cat = getQuestCategory(questName);
              // Badge anh√§ngen
              const badge = document.createElement("span");
              badge.className = "ml-2 px-2 py-0.5 text-xs rounded bg-slate-100 border";
              badge.textContent = cat;
              span.appendChild(badge);
            }
          });
        }
      }catch(e){/* noop */}
      renderCategoryOverviewCatalog();
    };
  }else{
    // Falls Katalog erst sp√§ter gebaut wird, nachtr√§glich versuchen
    setTimeout(renderCategoryOverviewCatalog, 0);
  }

  /* ---------- Erst-Render triggern ---------- */
  if(typeof window.renderAll==="function"){
    // leicht verz√∂gert, damit andere Panels zuerst aufbauen
    setTimeout(()=>window.renderAll(), 0);
  }else{
    // Minimum: die beiden Boxen wenigstens einmal versuchen
    setTimeout(()=>{
      renderCategoryOverviewDashboard();
      renderCategoryOverviewCatalog();
    }, 0);
  }
})();
/* ==================== Part 24: Kategorie-Editor im Katalog ====================
   Ziele:
   - In der "Neuen Quest" Leiste ein Kategorie-Dropdown hinzuf√ºgen (+ neue Kategorie anlegen)
   - Bei jeder vorhandenen Quest im Katalog eine Kategorie-Auswahl anzeigen
   - Beim √Ñndern: Quest.category aktualisieren + alle passenden Log-Eintr√§ge live migrieren (e.cat)
   - Robust: keine Doppel-Initialisierung, kompatibel mit vorherigen Parts
================================================================================ */
(function categoryEditor(){
  if(window.__categoryEditor) return;
  window.__categoryEditor = true;

  // --- Helpers & Bootstrap ---
  const DEFAULT_CATS = [
    "Allgemein",
    "Sport",
    "Haushalt",
    "Ern√§hrung",
    "Arbeit",
    "Gesundheit",
    "Hobby",
    "Negativ: Schlechter Lebensstil"
  ];

  window.state = window.state || {};
  state.catalog = state.catalog || [];
  state.categories = state.categories || DEFAULT_CATS.slice();

  function saveSafe(){ try{ if(typeof save==="function") save(); }catch{} }
  function renderAllSafe(){ try{ if(typeof renderAll==="function") renderAll(); }catch{} }

  function autoCategory(name){
    const n=(name||"").toLowerCase();
    if(n.includes("sport")||n.includes("workout")||n.includes("laufen")||n.includes("liegest√ºtz")) return "Sport";
    if(n.includes("aufr√§um")||n.includes("putz")||n.includes("keller")||n.includes("k√ºche")) return "Haushalt";
    if(n.includes("essen")||n.includes("kochen")||n.includes("fast food")||n.includes("zucker")) return "Ern√§hrung";
    if(n.includes("arbeit")||n.includes("task")||n.includes("projekt")||n.includes("job")) return "Arbeit";
    if(n.includes("gesund")||n.includes("arzt")||n.includes("medit")||n.includes("schlaf")) return "Gesundheit";
    if(n.includes("hobby")||n.includes("lernen")||n.includes("gitarre")||n.includes("lesen")) return "Hobby";
    if(n.includes("joint")||n.includes("kater")||n.includes("junkfood")||n.includes("rauchen")) return "Negativ: Schlechter Lebensstil";
    return "Allgemein";
  }

  // Stelle sicher, dass alle Katalog-Quests eine Kategorie haben
  state.catalog.forEach(q=>{
    if(!q.category){
      q.category = autoCategory(q.name);
      if(!state.categories.includes(q.category)) state.categories.push(q.category);
    }
  });

  // Logs: fehlende cat normalisieren
  state.log = Array.isArray(state.log) ? state.log : [];
  state.log.forEach(e=>{
    if(!e.cat){
      // Kategorie aus dem Katalog herleiten oder raten
      const q = state.catalog.find(x=>x.name===e.quest);
      e.cat = q?.category || autoCategory(e.quest);
      if(!state.categories.includes(e.cat)) state.categories.push(e.cat);
    }
  });
  saveSafe();

  // --- Core: Migration aller Logs f√ºr eine Quest auf neue Kategorie ---
  function migrateLogCategory(questName, newCat){
    let changed=false;
    state.log.forEach(e=>{
      if(e.quest===questName){
        if(e.cat!==newCat){ e.cat=newCat; changed=true; }
      }
    });
    if(changed) saveSafe();
  }

  // --- UI-Hilfen ---
  function buildCategorySelect(selected){
    const sel = document.createElement("select");
    sel.className = "input text-xs";
    // Optionen aufbauen
    state.categories.forEach(cat=>{
      const opt=document.createElement("option");
      opt.value=cat; opt.textContent=cat;
      if(cat===selected) opt.selected=true;
      sel.appendChild(opt);
    });
    // Neue Kategorie Option
    const optNew = document.createElement("option");
    optNew.value="__add__";
    optNew.textContent="+ Neue Kategorie‚Ä¶";
    sel.appendChild(optNew);
    return sel;
  }

  function ensureNewCategoryFlow(selectEl){
    selectEl.addEventListener("change",()=>{
      if(selectEl.value==="__add__"){
        const name = prompt("Name der neuen Kategorie?");
        if(name && name.trim()){
          const clean = name.trim();
          if(!state.categories.includes(clean)) state.categories.push(clean);
          // Optionen neu aufbauen
          const fresh = buildCategorySelect(clean);
          selectEl.replaceWith(fresh);
          ensureNewCategoryFlow(fresh);
          saveSafe();
        }else{
          // Auswahl zur√ºcksetzen
          const first = state.categories[0]||"Allgemein";
          const fresh = buildCategorySelect(first);
          selectEl.replaceWith(fresh);
          ensureNewCategoryFlow(fresh);
        }
      }
    });
  }

  // Entfernt alle Event-Listener von einem Button durch Klonen
  function replaceWithClone(el){
    const clone = el.cloneNode(true);
    el.parentNode.replaceChild(clone, el);
    return clone;
  }

  // --- Add-Quest-Leiste um Kategorie erweitern + sauberes Click-Handling ---
  function enhanceAddQuestForm(){
    const tab = document.getElementById("tab-catalog");
    if(!tab) return;
    const formBox = tab.querySelector(".space-y-2");
    const nameInp = tab.querySelector("#qName");
    const ptsInp  = tab.querySelector("#qPoints");
    const bossSel = tab.querySelector("#qBoss");
    const addBtn  = tab.querySelector("#btnAddQuest");

    if(!formBox || !nameInp || !ptsInp || !addBtn) return; // wird in √§lterer renderCatalog-Var erstellt

    // Kategorie-Select einmalig injizieren / aktualisieren
    let catSel = tab.querySelector("#qCategory");
    if(!catSel){
      catSel = buildCategorySelect("Allgemein");
      catSel.id = "qCategory";
      catSel.classList.add("mt-1");
      // Nach qBoss (falls vorhanden) oder nach Punkte einf√ºgen
      if(bossSel && bossSel.parentNode===formBox){
        bossSel.insertAdjacentElement("afterend", catSel);
      }else{
        ptsInp.insertAdjacentElement("afterend", catSel);
      }
      ensureNewCategoryFlow(catSel);
    }else{
      // Optionen refreshen (falls Kategorien ge√§ndert)
      const fresh = buildCategorySelect(catSel.value);
      fresh.id = "qCategory";
      catSel.replaceWith(fresh);
      catSel = fresh;
      ensureNewCategoryFlow(catSel);
    }

    // Click-Handler des Add-Buttons ersetzen (um Kategorie mitzunehmen)
    const safeBtn = replaceWithClone(addBtn);
    safeBtn.addEventListener("click",()=>{
      const name = (nameInp.value||"").trim();
      const points = Number(ptsInp.value||0);
      const boss = bossSel ? (bossSel.value==="true") : false;
      let category = (catSel && catSel.value && catSel.value!=="__add__") ? catSel.value : autoCategory(name);

      if(!name){ alert("Bitte Questname eingeben"); return; }
      if(!points){ alert("Bitte Punkte angeben"); return; }
      if(!state.categories.includes(category)) state.categories.push(category);

      // Einf√ºgen oder √ºberschreiben, falls gleicher Name existiert?
      const existing = state.catalog.find(q=>q.name===name);
      if(existing){
        existing.points = points;
        existing.boss = boss;
        existing.category = category;
      }else{
        state.catalog.push({name,points,boss,category});
      }
      saveSafe();
      renderAllSafe();

      // Felder leeren
      nameInp.value="";
      ptsInp.value="";
      if(catSel) catSel.value = category;
    });
  }

  // --- Pro-Quest Row-Editor: Kategorie-Dropdown in der Liste ---
  function enhanceQuestRows(){
    const list = document.getElementById("catalogList");
    if(!list) return;

    // Jede vorhandene Questzeile anreichern
    const rows = list.querySelectorAll("div.p-2.border.rounded");
    rows.forEach((row, idx)=>{
      // Finde den Questnamen in der Zeile
      const nameSpan = row.querySelector("span");
      if(!nameSpan) return;

      // Pr√ºfen, ob schon Editor hineingebaut
      if(row.__catEditorAttached) return;
      row.__catEditorAttached = true;

      // Namen extrahieren (Badge & Punkte-Anzeige ignorieren)
      const raw = (nameSpan.textContent||"").trim();
      // Muster: "üëë <Name> (+<Punkte> Punkte)"
      const match = raw.match(/^\s*(üëë\s*)?(.+?)\s+\(\+\d+/);
      const questName = match ? match[2].trim() : raw;

      // Katalogeintrag finden (Index kann wegen Timed-Button etc. abweichen, deshalb by name)
      const q = state.catalog.find(x=>x.name===questName);
      if(!q) return;

      const wrap = document.createElement("div");
      wrap.className = "flex items-center gap-2 mt-2";

      const sel = buildCategorySelect(q.category || autoCategory(q.name));
      ensureNewCategoryFlow(sel);

      const btn = document.createElement("button");
      btn.className = "btn text-xs";
      btn.textContent = "Speichern";

      btn.addEventListener("click",()=>{
        const newCat = sel.value==="__add__" ? autoCategory(q.name) : sel.value;
        q.category = newCat;
        if(!state.categories.includes(newCat)) state.categories.push(newCat);
        migrateLogCategory(q.name, newCat);
        saveSafe();
        renderAllSafe();
      });

      wrap.appendChild(sel);
      wrap.appendChild(btn);
      row.appendChild(wrap);
    });
  }

  // --- Hook ins bestehende renderCatalog (Kaskade beibehalten) ---
  const _oldRenderCatalog = (typeof window.renderCatalog==="function") ? window.renderCatalog : null;
  if(_oldRenderCatalog){
    window.renderCatalog = function(){
      _oldRenderCatalog();
      // Nach der bestehenden DOM-Erstellung unsere Controls hinzuf√ºgen
      try{
        enhanceAddQuestForm();
        enhanceQuestRows();
      }catch(e){}
    };
  }else{
    // Falls renderCatalog noch nicht existiert (Edge), sp√§ter erneut versuchen
    setTimeout(()=>{
      try{
        enhanceAddQuestForm();
        enhanceQuestRows();
      }catch(e){}
    }, 0);
  }

  // Beim ersten Durchlauf einmal sicherstellen
  setTimeout(()=>{
    try{
      enhanceAddQuestForm();
      enhanceQuestRows();
    }catch(e){}
  }, 0);

})();
/* ==================== Part 25: Kategorie-Management (Settings) ====================
   Funktionen:
   - Kategorien in den Einstellungen verwalten (Add / Rename / Merge / Delete)
   - Alle √Ñnderungen migrieren sicher:
       * state.categories (Liste)
       * state.catalog[].category (alle Quests)
       * state.log[].cat (alle Log-Eintr√§ge)
   - Z√§hler pro Kategorie (Quests, Logs, Punkte) anzeigen
   - "Allgemein" ist gesch√ºtzt (nicht l√∂sch-/umbenennbar)
   Robust:
   - Einmaliger Init (Guard)
   - Greift nicht in bestehende Render-Pipeline ein, h√§ngt sich nur dran
=================================================================================== */
(function categoryManager(){
  if(window.__categoryManager) return;
  window.__categoryManager = true;

  const PROTECTED_CATS = ["Allgemein"];
  const NEGATIVE_DEFAULT = "Negativ: Schlechter Lebensstil";

  // Guards & Defaults
  window.state = window.state || {};
  state.categories = state.categories || ["Allgemein", NEGATIVE_DEFAULT];
  state.catalog = Array.isArray(state.catalog) ? state.catalog : [];
  state.log = Array.isArray(state.log) ? state.log : [];

  function saveSafe(){ try{ if(typeof save==="function") save(); }catch{} }
  function renderAllSafe(){ try{ if(typeof renderAll==="function") renderAll(); }catch{} }

  // --- Stats je Kategorie ---
  function categoryStats(){
    const stats = {};
    // Init
    state.categories.forEach(c=>{
      stats[c] = {quests:0, logs:0, points:0};
    });
    // Quests z√§hlen
    state.catalog.forEach(q=>{
      const c = q.category || "Allgemein";
      if(!stats[c]) stats[c] = {quests:0, logs:0, points:0};
      stats[c].quests++;
    });
    // Logs & Punkte
    state.log.forEach(e=>{
      const c = e.cat || "Allgemein";
      if(!stats[c]) stats[c] = {quests:0, logs:0, points:0};
      stats[c].logs++;
      stats[c].points += Number(e.points||0);
    });
    return stats;
  }

  // --- Core Ops ---
  function renameCategory(oldName, newName){
    if(!newName || oldName===newName) return false;
    if(PROTECTED_CATS.includes(oldName)) { alert("Diese Kategorie ist gesch√ºtzt."); return false; }
    // Kein Duplikat (case-insensitive)
    if(state.categories.some(c=>c.toLowerCase()===newName.toLowerCase())){
      alert("Kategorie existiert bereits.");
      return false;
    }
    // categories
    const i = state.categories.indexOf(oldName);
    if(i>=0) state.categories[i] = newName;
    // catalog
    state.catalog.forEach(q=>{ if((q.category||"Allgemein")===oldName) q.category=newName; });
    // logs
    state.log.forEach(e=>{ if((e.cat||"Allgemein")===oldName) e.cat=newName; });

    saveSafe(); renderAllSafe();
    return true;
  }

  function mergeCategories(src, dst){
    if(src===dst) return false;
    if(PROTECTED_CATS.includes(src) && src!=="Allgemein"){ /*allow merge but keep dst*/ }
    if(!state.categories.includes(dst)){
      alert("Zielkategorie existiert nicht.");
      return false;
    }
    // catalog
    state.catalog.forEach(q=>{ if((q.category||"Allgemein")===src) q.category=dst; });
    // logs
    state.log.forEach(e=>{ if((e.cat||"Allgemein")===src) e.cat=dst; });
    // remove src in categories
    state.categories = state.categories.filter(c=>c!==src);
    saveSafe(); renderAllSafe();
    return true;
  }

  function deleteCategory(cat){
    if(PROTECTED_CATS.includes(cat)){
      alert("Diese Kategorie kann nicht gel√∂scht werden.");
      return false;
    }
    // Wenn benutzt -> Nachfrage & nach "Allgemein" migrieren
    const used = state.catalog.some(q=>(q.category||"Allgemein")===cat) ||
                 state.log.some(e=>(e.cat||"Allgemein")===cat);
    if(used){
      if(!confirm(`"${cat}" ist in Verwendung. Eintr√§ge nach "Allgemein" verschieben und Kategorie l√∂schen?`)) return false;
      // migrieren
      state.catalog.forEach(q=>{ if((q.category||"Allgemein")===cat) q.category="Allgemein"; });
      state.log.forEach(e=>{ if((e.cat||"Allgemein")===cat) e.cat="Allgemein"; });
    }
    // entfernen
    state.categories = state.categories.filter(c=>c!==cat);
    saveSafe(); renderAllSafe();
    return true;
  }

  function addCategory(name){
    const n=(name||"").trim();
    if(!n) return false;
    if(state.categories.some(c=>c.toLowerCase()===n.toLowerCase())){ alert("Kategorie existiert bereits."); return false; }
    state.categories.push(n);
    saveSafe(); renderAllSafe();
    return true;
  }

  // --- UI ---
  function buildMergeSelect(current){
    const sel = document.createElement("select");
    sel.className = "input text-xs";
    state.categories
      .filter(c=>c!==current)
      .forEach(c=>{
        const opt=document.createElement("option");
        opt.value=c; opt.textContent=c;
        sel.appendChild(opt);
      });
    return sel;
  }

  function renderCategoryManager(){
    const tab = document.getElementById("tab-settings");
    if(!tab) return;

    // Container (reset on each renderSettings)
    let box = document.getElementById("catManager");
    if(box) box.remove();

    const stats = categoryStats();

    box = document.createElement("div");
    box.id = "catManager";
    box.className = "mt-6 p-3 border rounded bg-white space-y-3";
    box.innerHTML = `
      <h3 class="font-bold">Kategorien verwalten</h3>

      <div class="flex gap-2 items-center">
        <input id="cmNewName" class="input flex-1" placeholder="Neue Kategorie‚Ä¶" />
        <button id="cmAdd" class="btn">+ Hinzuf√ºgen</button>
      </div>

      <div class="text-xs text-slate-500">Hinweis: "Allgemein" ist gesch√ºtzt und kann nicht gel√∂scht/umbenannt werden.</div>

      <div id="cmList" class="space-y-2"></div>
    `;

    // Liste rendern
    const list = box.querySelector("#cmList");
    // Sort: gesch√ºtzte zuerst
    const cats = [...state.categories].sort((a,b)=>{
      const pa = PROTECTED_CATS.includes(a)?0:1;
      const pb = PROTECTED_CATS.includes(b)?0:1;
      if(pa!==pb) return pa-pb;
      return a.localeCompare(b);
    });

    cats.forEach(cat=>{
      const s = stats[cat] || {quests:0,logs:0,points:0};
      const row = document.createElement("div");
      row.className = "p-2 border rounded";
      row.dataset.cat = cat;

      const protectedBadge = PROTECTED_CATS.includes(cat)
        ? `<span class="ml-2 text-[10px] px-2 py-[2px] rounded bg-slate-100 border">gesch√ºtzt</span>`
        : "";

      row.innerHTML = `
        <div class="flex flex-wrap items-center gap-2 justify-between">
          <div class="flex flex-wrap items-center gap-2">
            <input data-role="renameInput" class="input text-sm" value="${cat}" ${PROTECTED_CATS.includes(cat) ? "disabled":""} />
            ${protectedBadge}
            <div class="text-xs text-slate-600">
              ‚Ä¢ Quests: ${s.quests} ‚Ä¢ Logs: ${s.logs} ‚Ä¢ Punkte: ${s.points}
            </div>
          </div>
          <div class="flex flex-wrap items-center gap-2">
            <div class="flex items-center gap-1">
              <span class="text-xs text-slate-500">Merge in:</span>
              <span data-role="mergeWrap"></span>
              <button data-action="merge" class="btn text-xs">Zusammenf√ºhren</button>
            </div>
            <button data-action="rename" class="btn text-xs" ${PROTECTED_CATS.includes(cat)?"disabled":""}>Umbenennen</button>
            <button data-action="delete" class="btn text-xs bg-red-50 border-red-200" ${PROTECTED_CATS.includes(cat)?"disabled":""}>L√∂schen</button>
          </div>
        </div>
      `;
      // Merge Select einsetzen
      const wrap = row.querySelector('[data-role="mergeWrap"]');
      wrap.appendChild(buildMergeSelect(cat));
      list.appendChild(row);
    });

    // Events: Add / Row actions
    box.querySelector("#cmAdd").addEventListener("click",()=>{
      const val = box.querySelector("#cmNewName").value;
      if(addCategory(val)){
        // Feld leeren, re-render via renderAllSafe -> wir h√§ngen uns an renderSettings Hook an
      }
    });

    // Delegation f√ºr Zeilen
    box.addEventListener("click",(ev)=>{
      const btn = ev.target.closest("button[data-action]");
      if(!btn) return;
      const row = ev.target.closest("[data-cat]");
      if(!row) return;
      const cat = row.dataset.cat;
      const action = btn.getAttribute("data-action");

      if(action==="rename"){
        const inp = row.querySelector('[data-role="renameInput"]');
        const newName = (inp.value||"").trim();
        if(!newName){ alert("Bitte neuen Namen eingeben."); return; }
        if(newName===cat) return;
        if(renameCategory(cat,newName)){
          // nothing else; renderAllSafe() bereits in rename
        }
      }

      if(action==="merge"){
        const sel = row.querySelector('[data-role="mergeWrap"] select');
        const dst = sel?.value;
        if(!dst){ alert("Bitte Zielkategorie w√§hlen."); return; }
        if(mergeCategories(cat,dst)){
          // done; renderAllSafe() bereits in merge
        }
      }

      if(action==="delete"){
        deleteCategory(cat);
      }
    });

    // In Settings anh√§ngen
    tab.appendChild(box);
  }

  // --- Hook: an das vorhandene renderSettings anh√§ngen ---
  const _oldRenderSettings = (typeof window.renderSettings==="function") ? window.renderSettings : null;
  if(_oldRenderSettings){
    window.renderSettings = function(){
      _oldRenderSettings();
      // direkt danach unseren Manager einbauen
      try{ renderCategoryManager(); }catch(e){}
    };
  }else{
    // Falls noch nicht vorhanden, sp√§ter versuchen
    setTimeout(()=>{ try{ renderCategoryManager(); }catch(e){} }, 0);
  }

  // First paint
  setTimeout(()=>{ try{ renderCategoryManager(); }catch(e){} }, 0);

})();
/* ==================== Part 26: Kategorie-Verkn√ºpfungen ====================
   Ziel:
   - Wenn du eine Quest aus Kategorie A erledigst, bekommt Kategorie B
     **zus√§tzliche Kategorien-Punkte** (nur f√ºr Auswertungen/Milestones der
     Kategorie B). Die Gesamtpunkte (global) bleiben UNVER√ÑNDERT.
   - Verwaltung der Regeln in den Einstellungen:
       * Von-Kategorie ‚Üí Zu-Kategorie
       * Modus: Prozent (%) oder Fix (+Punkte)
   - √úbersicht & L√∂schen von Regeln
   - Die Kategorien-Punkte-Anzeige im Kategorie-Manager (Part 25) wird live
     inkl. dieser Credits aktualisiert.
   - Daten:
       * state.catLinks   = [{from, to, mode:"percent"|"fixed", value:Number}]
       * state.catCredits = [{date, cat, points, refIdx, note}]
     catCredits z√§hlen NUR f√ºr Kategorien-Punkte/Meilensteine, NICHT global.
============================================================================ */
(function catLinksModule(){
  if(window.__catLinksModule) return;
  window.__catLinksModule = true;

  // --- Defaults/Guards ---
  window.state = window.state || {};
  state.categories = state.categories || ["Allgemein"];
  state.catalog    = Array.isArray(state.catalog)    ? state.catalog    : [];
  state.log        = Array.isArray(state.log)        ? state.log        : [];
  state.catLinks   = Array.isArray(state.catLinks)   ? state.catLinks   : [];
  state.catCredits = Array.isArray(state.catCredits) ? state.catCredits : [];

  function saveSafe(){ try{ if(typeof save==="function") save(); }catch{} }
  function renderAllSafe(){ try{ if(typeof renderAll==="function") renderAll(); }catch{} }

  const PROTECTED_CATS = ["Allgemein"];
  const NEGATIVE_DEFAULT = "Negativ: Schlechter Lebensstil";

  // --- Helper: Kategorien-Map aus Katalog (Name ‚Üí Kategorie) ---
  function questCatMap(){
    const m = new Map();
    state.catalog.forEach(q=>{
      const cat = q.category || "Allgemein";
      m.set(q.name, cat);
    });
    return m;
  }

  // --- Helper: Kategorie eines Log-Eintrags bestimmen ---
  function catOfLogEntry(e, qMap){
    // Priorit√§t: explizites e.cat ‚Üí Katalog ‚Üí "Allgemein"
    return (e && (e.cat || qMap.get(e.quest))) || "Allgemein";
  }

  // --- Credits berechnen & verbuchen (nur Kategorie-Punkte, nicht global) ---
  function applyCatLinksForNewLogs(idxFrom){
    const qMap = questCatMap();
    for(let i=idxFrom; i<state.log.length; i++){
      const e = state.log[i];
      if(!e) continue;

      // Nur positive, "echte" Punkte mitnehmen (keine reinen 0er Marker)
      const basePts = Number(e.points||0);
      if(basePts <= 0) continue;

      const fromCat = catOfLogEntry(e, qMap);
      // Passende Regeln suchen
      const rules = state.catLinks.filter(r=>r.from===fromCat && r.to && r.to!==fromCat);

      if(rules.length===0) continue;

      rules.forEach(r=>{
        let add = 0;
        if(r.mode==="percent"){
          add = Math.round(basePts * (Number(r.value||0)/100));
        }else{
          add = Math.round(Number(r.value||0));
        }
        if(add<=0) return;

        // Credit verbuchen (NUR f√ºr Kategorien-Punkte)
        state.catCredits.push({
          date: (typeof todayISO==="function") ? todayISO() : (new Date().toISOString().slice(0,10)),
          cat: r.to,
          points: add,
          refIdx: i,
          note: `Link ${fromCat} ‚Üí ${r.to}`
        });
      });
    }
    saveSafe();
    // UI refresh + Zahlen im Cat-Manager patchen
    patchCategoryStatsWithCredits();
  }

  // --- UI: kleiner Toast ---
  function showToast(msg, cls="bg-indigo-600"){
    try{
      const t=document.createElement("div");
      t.textContent=msg;
      t.className=`fixed bottom-24 left-1/2 -translate-x-1/2 ${cls} text-white px-4 py-2 rounded shadow-lg`;
      document.body.appendChild(t);
      setTimeout(()=>t.remove(),1800);
    }catch{}
  }

  // --- Hook: addLog wrappen, damit Credits nach jedem Log berechnet werden ---
  const _oldAddLog = (typeof window.addLog==="function") ? window.addLog : null;
  if(_oldAddLog){
    window.addLog = function(){
      const before = state.log.length;
      _oldAddLog();
      const after = state.log.length;
      if(after>before){
        applyCatLinksForNewLogs(before);
        // Kurzer Hinweis, falls mind. 1 Rule matched hat
        const qMap = questCatMap();
        const e = state.log[after-1];
        const fromCat = catOfLogEntry(e, qMap);
        if(state.catLinks.some(r=>r.from===fromCat)){
          showToast("Kategorie-Bonus gutgeschrieben (nur Kategorie-Punkte).","bg-purple-600");
        }
      }
    };
  }

  // --- Migration: Credits auf existierende Kategorien mappen (Rename/Merge) ---
  function sanitizeCatCredits(){
    const known = new Set(state.categories);
    let changed=false;
    state.catCredits.forEach(cc=>{
      if(!known.has(cc.cat)){
        cc.cat = "Allgemein";
        changed=true;
      }
    });
    if(changed) saveSafe();
  }

  // --- Stats mit Credits patchen (UI vom Part 25 nachtr√§glich korrigieren) ---
  function patchCategoryStatsWithCredits(){
    sanitizeCatCredits();

    const cm = document.getElementById("catManager");
    const list = cm ? cm.querySelector("#cmList") : null;
    if(!list) return;

    const rows = list.querySelectorAll("[data-cat]");
    if(!rows || rows.length===0) return;

    const qMap = questCatMap();

    // Voraggregieren: Logs nach Kat + Punkte
    const agg = {};
    function ensure(k){
      if(!agg[k]) agg[k]={quests:0, logs:0, points:0};
    }

    // Quests pro Kategorie
    state.catalog.forEach(q=>{
      const c=q.category||"Allgemein";
      ensure(c); agg[c].quests++;
    });

    // Logs & Punkte (globaler Log-Punktestand pro Kategorie)
    state.log.forEach(e=>{
      const c = catOfLogEntry(e, qMap);
      ensure(c);
      agg[c].logs++;
      agg[c].points += Number(e.points||0);
    });

    // Credits addieren (nur Kategorie-Punkte, nicht logs/quests)
    state.catCredits.forEach(cc=>{
      ensure(cc.cat);
      agg[cc.cat].points += Number(cc.points||0);
    });

    // In DOM einsetzen
    rows.forEach(row=>{
      const cat = row.dataset.cat;
      const s = agg[cat] || {quests:0,logs:0,points:0};
      const info = row.querySelector(".text-xs.text-slate-600");
      if(info){
        info.textContent = `‚Ä¢ Quests: ${s.quests} ‚Ä¢ Logs: ${s.logs} ‚Ä¢ Punkte: ${s.points}`;
      }
    });
  }

  // --- UI: Verkn√ºpfungen in Settings rendern ---
  function renderCatLinksUI(){
    const tab = document.getElementById("tab-settings");
    if(!tab) return;

    // Vorhandenen Block ersetzen
    let box = document.getElementById("catLinksBox");
    if(box) box.remove();

    box = document.createElement("div");
    box.id = "catLinksBox";
    box.className = "mt-6 p-3 border rounded bg-white space-y-3";

    // Builder: Select
    function buildSelect(id, placeholder){
      const s=document.createElement("select");
      s.id=id; s.className="input";
      const def=document.createElement("option");
      def.value=""; def.textContent=placeholder||"Bitte w√§hlen";
      s.appendChild(def);
      // Kategorien einf√ºllen
      [...state.categories].forEach(c=>{
        const opt=document.createElement("option");
        opt.value=c; opt.textContent=c;
        s.appendChild(opt);
      });
      return s;
    }

    // Header & Form
    const form = document.createElement("div");
    form.innerHTML = `
      <h3 class="font-bold">Kategorie-Verkn√ºpfungen</h3>
      <div class="grid grid-cols-1 md:grid-cols-5 gap-2 items-center">
        <div>
          <label class="text-xs">Von</label>
          <div id="clFromWrap"></div>
        </div>
        <div>
          <label class="text-xs">Zu</label>
          <div id="clToWrap"></div>
        </div>
        <div>
          <label class="text-xs">Modus</label>
          <select id="clMode" class="input">
            <option value="percent">% von Quest-Punkten</option>
            <option value="fixed">+ feste Punkte</option>
          </select>
        </div>
        <div>
          <label class="text-xs">Wert</label>
          <input id="clValue" type="number" class="input" placeholder="z. B. 20 oder 5" />
        </div>
        <div class="self-end">
          <button id="clAdd" class="btn bg-purple-600 text-white w-full">+ Regel hinzuf√ºgen</button>
        </div>
      </div>
      <div class="text-xs text-slate-500">
        Hinweis: Diese Boni z√§hlen <b>nur</b> zu den <b>Kategorien-Punkten</b> der Ziel-Kategorie (z. B. f√ºr Milestones),
        nicht zu deinen Gesamtpunkten.
      </div>
    `;

    // Wraps einsetzen
    const fromWrap=form.querySelector("#clFromWrap");
    const toWrap  =form.querySelector("#clToWrap");
    fromWrap.appendChild(buildSelect("clFrom","Quelle‚Ä¶"));
    toWrap.appendChild(buildSelect("clTo","Ziel‚Ä¶"));

    box.appendChild(form);

    // Regeln-Liste
    const list=document.createElement("div");
    list.id="clList";
    list.className="space-y-2";
    box.appendChild(list);

    function renderRuleList(){
      list.innerHTML = state.catLinks.length===0
        ? `<div class="text-sm text-slate-500">Noch keine Verkn√ºpfungen.</div>`
        : state.catLinks.map((r,i)=>{
            const label = r.mode==="percent" ? `${r.value}%` : `+${r.value}`;
            return `
              <div class="p-2 border rounded flex items-center justify-between">
                <div>üîó <b>${r.from}</b> ‚Üí <b>${r.to}</b> <span class="text-xs text-slate-500">(${label})</span></div>
                <button class="btn text-xs bg-red-50 border-red-200" data-del="${i}">L√∂schen</button>
              </div>
            `;
          }).join("");

      // Delete handlers
      list.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const idx=Number(btn.getAttribute("data-del"));
          state.catLinks.splice(idx,1);
          saveSafe(); renderRuleList();
        });
      });
    }
    renderRuleList();

    // Add handler
    form.querySelector("#clAdd").addEventListener("click",()=>{
      const from = (form.querySelector("#clFrom")||{}).value || "";
      const to   = (form.querySelector("#clTo")||{}).value   || "";
      const mode = (form.querySelector("#clMode")||{}).value || "percent";
      const val  = Number((form.querySelector("#clValue")||{}).value || 0);

      if(!from || !to){ alert("Bitte Quelle und Ziel w√§hlen."); return; }
      if(from===to){ alert("Quelle und Ziel d√ºrfen nicht identisch sein."); return; }
      if(val<=0){ alert("Wert muss > 0 sein."); return; }

      // Duplikate verhindern
      if(state.catLinks.some(r=>r.from===from && r.to===to && r.mode===mode)){
        alert("Diese Verkn√ºpfung existiert bereits.");
        return;
      }

      state.catLinks.push({from:from, to:to, mode:mode, value:val});
      saveSafe(); renderRuleList();
      showToast("Verkn√ºpfung gespeichert.","bg-green-600");
    });

    // In Settings anh√§ngen
    tab.appendChild(box);
  }

  // --- Hook in renderSettings (nach Part 25) ---
  const _oldRenderSettings = (typeof window.renderSettings==="function") ? window.renderSettings : null;
  if(_oldRenderSettings){
    window.renderSettings = function(){
      _oldRenderSettings();
      // Unser UI + Zahlenpatch
      renderCatLinksUI();
      setTimeout(patchCategoryStatsWithCredits, 0);
    };
  }else{
    // Falls noch nicht vorhanden, sp√§ter probieren
    setTimeout(()=>{ try{ renderCatLinksUI(); patchCategoryStatsWithCredits(); }catch{} }, 0);
  }

  // --- Auch beim allgemeinen Re-Render sicherheitshalber patchen ---
  const _oldRenderAll = (typeof window.renderAll==="function") ? window.renderAll : null;
  if(_oldRenderAll){
    window.renderAll = function(){
      _oldRenderAll();
      // Kategorie-Zahlen inkl. Credits nachziehen (Settings offen?)
      setTimeout(patchCategoryStatsWithCredits, 0);
    };
  }

  // First UI paint
  setTimeout(()=>{ try{ renderCatLinksUI(); patchCategoryStatsWithCredits(); }catch{} }, 0);

})();
/* ==================== Part 27: Missions-System ====================
   Features:
   - Missionen mit beliebig vielen Schritten (Tasks)
   - Schritte k√∂nnen Abh√§ngigkeiten ("requires") haben
   - Alternative Schritte via "group": mind. 1 Schritt derselben Gruppe gen√ºgt
   - Schritte werden erst sichtbar/anklickbar, wenn freigeschaltet
   - Logging: Klick auf einen Schritt tr√§gt Punkte als normalen Log ein
   - Wenn alle Pflicht-Einheiten erf√ºllt sind: Bonus = 4√ó Summe (siehe unten)
   - Bonus wird nur EINMAL pro Mission vergeben
   - Dashboard: Box "Missionen" mit Fortschritt & freigeschalteten Buttons
   - Einstellungen: einfacher Missions-Manager (anlegen, Schritte hinzuf√ºgen)
   ------------------------------------------------------------------
   Datenstruktur:
   state.missions = [{
     id, name, bonusAwarded:false,
     tasks: [{
       id,                // automatisch t1, t2, ...
       name,              // Anzeigename, muss NICHT eindeutig sein
       points,            // Basis-Punkte f√ºr den Schritt
       group:null|"g2",   // gleicher group-Name = Alternativen
       requires:[],       // Array aus Tokens: "t:<id>" oder "g:<group>"
       unlocked:false,
       done:false
     }]
   }]
   ------------------------------------------------------------------
   Bonus-Berechnung (4√ó):
   - F√ºr jeden erledigten Schritt OHNE Gruppe: Punkte des Schritts
   - F√ºr JEDE Gruppe, in der mind. 1 Schritt erledigt ist: der H√ñCHSTE Punktwert
   - Summe dieser Werte √ó 4 -> als EIN Log-Eintrag "Missionsbonus: <name>"
   - Wird nur vergeben, wenn alle Pflicht-Einheiten erf√ºllt sind:
       * alle nicht-gruppierten Tasks sind done
       * jede Gruppe hat mind. 1 erledigten Task
====================================================================*/
(function missionsModule(){
  if(window.__missionsModule) return;
  window.__missionsModule = true;

  // --- Guards & Defaults ---
  window.state = window.state || {};
  state.missions = Array.isArray(state.missions) ? state.missions : [];
  state.catalog  = Array.isArray(state.catalog)  ? state.catalog  : [];
  state.log      = Array.isArray(state.log)      ? state.log      : [];

  function today(){ return (typeof todayISO==="function") ? todayISO() : new Date().toISOString().slice(0,10); }
  function saveSafe(){ try{ if(typeof save==="function") save(); }catch{} }
  function renderAllSafe(){ try{ if(typeof renderAll==="function") renderAll(); }catch{} }
  function computePointsSafe(base, d){ try{ return (typeof computePoints==="function")? computePoints(base,d) : base; }catch{ return base; } }

  // --- Helpers ---
  function tId(n){ return "t"+n; }

  function getMissionById(mid){
    return state.missions.find(m=>m.id===mid);
  }

  function allTaskIds(m){
    return m.tasks.map(t=>t.id);
  }

  function taskById(m, tid){
    return m.tasks.find(t=>t.id===tid);
  }

  function isGroupSatisfied(m, g){
    return m.tasks.some(t=>t.group===g && t.done);
  }

  function arePrereqsMet(m, task){
    if(!task.requires || task.requires.length===0) return true;
    return task.requires.every(tok=>{
      if(tok.startsWith("t:")){
        const tid = tok.slice(2);
        const tt = taskById(m, tid);
        return !!(tt && tt.done);
      }
      if(tok.startsWith("g:")){
        const g = tok.slice(2);
        return isGroupSatisfied(m, g);
      }
      // Fallback: id direkt (Kompat.)
      const tt = taskById(m, tok);
      return !!(tt && tt.done);
    });
  }

  function unlockTasks(m){
    m.tasks.forEach(t=>{
      if(!t.done){
        t.unlocked = arePrereqsMet(m, t);
      }
    });
  }

  function missionUnitsSatisfied(m){
    // Pflicht-Einheiten = (alle non-group tasks) + (alle existierenden Gruppen)
    const groups = [...new Set(m.tasks.map(t=>t.group).filter(Boolean))];
    const nonGroup = m.tasks.filter(t=>!t.group);

    const nonGroupOK = nonGroup.every(t=>t.done);
    const groupsOK   = groups.every(g=>isGroupSatisfied(m,g));

    return {nonGroupOK, groupsOK, allOK: nonGroupOK && groupsOK};
  }

  function missionProgress(m){
    const total = m.tasks.length;
    const done  = m.tasks.filter(t=>t.done).length;
    return {done, total, pct: total? Math.round(done/total*100) : 0};
  }

  function missionBonusBaseSum(m){
    // non-group: Summe der erledigten
    const nonGroupSum = m.tasks
      .filter(t=>!t.group && t.done)
      .reduce((s,t)=>s + Number(t.points||0), 0);

    // gruppen: je Gruppe max(points) aus erledigten
    const groups = [...new Set(m.tasks.map(t=>t.group).filter(Boolean))];
    const groupSum = groups.reduce((s,g)=>{
      const best = m.tasks
        .filter(t=>t.group===g && t.done)
        .reduce((mx,t)=>Math.max(mx, Number(t.points||0)), 0);
      return s + best;
    }, 0);

    return nonGroupSum + groupSum;
  }

  function awardMissionBonusIfComplete(m){
    const units = missionUnitsSatisfied(m);
    if(!units.allOK || m.bonusAwarded) return;

    const base = missionBonusBaseSum(m);
    const bonus = base * 4; // 4√ó
    if(bonus>0){
      state.log.push({date:today(), quest:"Missionsbonus: "+m.name, points:bonus});
      m.bonusAwarded = true;
      saveSafe();
      renderAllSafe();
      try{ if(window.FX){ FX.burst(); setTimeout(()=>FX.burst(),150); } }catch{}
      try{ if(window.Sound){ Sound.level(); } }catch{}
      setTimeout(()=>alert(`üéâ Mission "${m.name}" abgeschlossen! Bonus: +${bonus} Punkte`), 50);
    }
  }

  // --- Schritt erledigen (per Button) ---
  function completeTaskByClick(mid, tid){
    const m = getMissionById(mid);
    if(!m) return;
    const t = taskById(m, tid);
    if(!t || t.done) return;

    // Punkte als normaler Log (mit Multiplikator/Perks)
    const pts = computePointsSafe(Number(t.points||0), today());
    state.log.push({date:today(), quest:`Mission: ${m.name} ‚Äì ${t.name}`, points:pts});
    t.done = true;

    unlockTasks(m);
    saveSafe();
    renderAllSafe();

    awardMissionBonusIfComplete(m);
  }

  // --- Wenn Nutzer manuell loggt: Task-Erkennung nach Name ---
  //     Nur wenn Punkte > 0 und Task noch offen.
  const _oldAddLogMM = (typeof window.addLog==="function") ? window.addLog : null;
  if(_oldAddLogMM){
    window.addLog = function(){
      const before = state.log.length;
      _oldAddLogMM();
      const after = state.log.length;
      if(after>before){
        const e = state.log[after-1];
        const pts = Number(e.points||0);
        if(pts>0){
          const qname = (e.quest||"").toLowerCase();
          state.missions.forEach(m=>{
            const t = m.tasks.find(x=>!x.done && x.name.toLowerCase()===qname);
            if(t){
              t.done = true;
              unlockTasks(m);
              saveSafe();
            }
          });
          // Bonus pr√ºfen
          state.missions.forEach(awardMissionBonusIfComplete);
        }
      }
    };
  }

  // ======================= UI ‚Äì Dashboard =========================
  function renderMissionsDashboardBox(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // remove old
    const old = document.getElementById("missionsDashBox");
    if(old) old.remove();

    const box = document.createElement("div");
    box.id = "missionsDashBox";
    box.className = "mt-4 p-3 border rounded bg-white space-y-3";
    const title = document.createElement("h3");
    title.className = "font-bold";
    title.textContent = "Missionen";
    box.appendChild(title);

    if(state.missions.length===0){
      const empty = document.createElement("div");
      empty.className = "text-sm text-slate-500";
      empty.textContent = "Noch keine Missionen. Lege in den Einstellungen welche an.";
      box.appendChild(empty);
      host.appendChild(box);
      return;
    }

    state.missions.forEach(m=>{
      // Fortschritt
      const {done,total,pct} = missionProgress(m);
      const units = missionUnitsSatisfied(m);
      const row = document.createElement("div");
      row.className = "p-2 border rounded";

      row.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="font-medium">${m.name}</div>
          <div class="text-xs ${m.bonusAwarded?'text-green-600':'text-slate-500'}">
            ${m.bonusAwarded? 'Bonus vergeben' : 'Bonus offen'}
          </div>
        </div>
        <div class="mt-1">
          <div class="w-full bg-gray-200 rounded h-2">
            <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
          </div>
          <div class="text-xs mt-1">${done}/${total} Schritte erledigt${units.allOK?' ‚Äì ‚úÖ abschlie√übar':''}</div>
        </div>
        <div class="mt-2 space-y-1" id="mbtns-${m.id}"></div>
      `;

      box.appendChild(row);

      // freigeschaltete, offene Tasks als Buttons
      const btnWrap = row.querySelector("#mbtns-"+m.id);
      m.tasks
        .filter(t=>t.unlocked && !t.done)
        .forEach(t=>{
          const b = document.createElement("button");
          b.className = "btn w-full text-left";
          const label = t.group ? `(${t.group}) ${t.name}` : t.name;
          b.textContent = `‚ûï ${label} (+${t.points} Punkte)`;
          b.addEventListener("click", ()=>completeTaskByClick(m.id, t.id));
          btnWrap.appendChild(b);
        });

      if(btnWrap && btnWrap.children.length===0){
        const hint = document.createElement("div");
        hint.className="text-xs text-slate-500";
        hint.textContent="Keine Schritte verf√ºgbar ‚Äì erf√ºlle Abh√§ngigkeiten zuerst.";
        btnWrap.appendChild(hint);
      }
    });

    host.appendChild(box);
  }

  // Hook ins Dashboard
  const _oldRenderDashboardMM = (typeof window.renderDashboard==="function") ? window.renderDashboard : null;
  if(_oldRenderDashboardMM){
    window.renderDashboard = function(){
      _oldRenderDashboardMM();
      // sicherstellen, dass neue Freischaltungen gelten
      state.missions.forEach(unlockTasks);
      renderMissionsDashboardBox();
    };
  }else{
    setTimeout(()=>{ try{ state.missions.forEach(unlockTasks); renderMissionsDashboardBox(); }catch{} }, 0);
  }

  // ======================= UI ‚Äì Settings ==========================
  function renderMissionsManager(){
    const host = document.getElementById("tab-settings");
    if(!host) return;

    // remove old
    const old = document.getElementById("missionsManager");
    if(old) old.remove();

    const box = document.createElement("div");
    box.id = "missionsManager";
    box.className = "mt-6 p-3 border rounded bg-white space-y-3";
    box.innerHTML = `
      <h3 class="font-bold">Missions-Manager</h3>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
        <input id="mmName" class="input" placeholder="Missionsname (z. B. Wohnzimmer fertig)" />
        <button id="mmAdd" class="btn bg-blue-600 text-white">+ Mission anlegen</button>
        <button id="mmDemo" class="btn">Demo-Mission hinzuf√ºgen</button>
      </div>
      <div id="mmList" class="space-y-3 mt-2"></div>
      <div class="text-xs text-slate-500">
        Tipp: "group" erlaubt Alternativen (z. B. beide Schritte Gruppe "g2" ‚Üí einer gen√ºgt).
        "requires" nutzt Tokens: <b>t:t1</b> f√ºr Schritt-ID oder <b>g:g2</b> f√ºr Gruppen-Abh√§ngigkeit.
      </div>
    `;

    host.appendChild(box);

    const mmList = box.querySelector("#mmList");
    const mmName = box.querySelector("#mmName");

    // Render Missionsliste
    function renderList(){
      mmList.innerHTML = state.missions.length===0
        ? `<div class="text-sm text-slate-500">Noch keine Missionen.</div>`
        : state.missions.map(m=>{
            const {done,total,pct} = missionProgress(m);
            return `
              <div class="p-2 border rounded">
                <div class="flex items-center justify-between">
                  <div class="font-medium">${m.name}</div>
                  <div class="text-xs">Progress: ${done}/${total} (${pct}%)</div>
                </div>
                <div class="mt-2 space-y-1" id="mt-${m.id}">
                  ${m.tasks.map(t=>`
                    <div class="grid grid-cols-5 gap-2 items-center">
                      <input data-mid="${m.id}" data-tid="${t.id}" data-k="name"   class="input col-span-2" value="${t.name}">
                      <input data-mid="${m.id}" data-tid="${t.id}" data-k="points" class="input" type="number" value="${t.points}">
                      <input data-mid="${m.id}" data-tid="${t.id}" data-k="group"  class="input" placeholder="group (optional)" value="${t.group||""}">
                      <input data-mid="${m.id}" data-tid="${t.id}" data-k="requires"class="input" placeholder="requires (z. B. t:t1,g:g2)" value="${(t.requires||[]).join(",")}">
                    </div>
                  `).join("")}
                </div>
                <div class="mt-2 grid grid-cols-5 gap-2">
                  <input id="newName-${m.id}" class="input col-span-2" placeholder="Neuer Schritt: Name">
                  <input id="newPts-${m.id}" class="input" type="number" placeholder="Punkte">
                  <input id="newGrp-${m.id}" class="input" placeholder="group (optional)">
                  <input id="newReq-${m.id}" class="input" placeholder="requires (z. B. t:t1,g:g2)">
                </div>
                <div class="mt-2 flex gap-2">
                  <button class="btn bg-blue-600 text-white" data-add="${m.id}">+ Schritt</button>
                  <button class="btn" data-recalc="${m.id}">Freischaltungen pr√ºfen</button>
                  <button class="btn bg-red-50 border-red-200" data-del="${m.id}">Mission l√∂schen</button>
                </div>
              </div>
            `;
          }).join("");

      // Bind Eingabe-√Ñnderungen (Tasks)
      mmList.querySelectorAll("[data-mid][data-tid][data-k]").forEach(inp=>{
        inp.addEventListener("change", ()=>{
          const mid = inp.getAttribute("data-mid");
          const tid = inp.getAttribute("data-tid");
          const k   = inp.getAttribute("data-k");
          const m = getMissionById(mid);
          if(!m) return;
          const t = taskById(m, tid);
          if(!t) return;
          let v = inp.value;
          if(k==="points") v = Number(v||0);
          if(k==="requires"){
            v = (v||"").split(",").map(s=>s.trim()).filter(Boolean);
          }
          t[k] = v || (k==="group"? null : v);
          saveSafe();
        });
      });

      // Add Step
      mmList.querySelectorAll("[data-add]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const mid = btn.getAttribute("data-add");
          const m = getMissionById(mid);
          if(!m) return;
          const base = m.tasks.length+1;
          const id = tId(base);
          const nInp = document.getElementById(`newName-${mid}`);
          const pInp = document.getElementById(`newPts-${mid}`);
          const gInp = document.getElementById(`newGrp-${mid}`);
          const rInp = document.getElementById(`newReq-${mid}`);

          const name = (nInp.value||"").trim();
          const points = Number(pInp.value||0);
          const group = (gInp.value||"").trim() || null;
          const requires = (rInp.value||"").split(",").map(s=>s.trim()).filter(Boolean);

          if(!name || points<=0){ alert("Name und Punkte sind erforderlich."); return; }

          const t = {id, name, points, group, requires, unlocked:false, done:false};
          m.tasks.push(t);
          unlockTasks(m);
          saveSafe();
          renderList();
        });
      });

      // Recalc
      mmList.querySelectorAll("[data-recalc]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const mid = btn.getAttribute("data-recalc");
          const m = getMissionById(mid);
          if(!m) return;
          unlockTasks(m);
          saveSafe();
          renderList();
        });
      });

      // Delete Mission
      mmList.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const mid = btn.getAttribute("data-del");
          const idx = state.missions.findIndex(x=>x.id===mid);
          if(idx>=0){
            if(confirm("Mission wirklich l√∂schen?")){
              state.missions.splice(idx,1);
              saveSafe();
              renderList();
              renderAllSafe();
            }
          }
        });
      });
    }

    // Add Mission
    box.querySelector("#mmAdd").addEventListener("click", ()=>{
      const name = (mmName.value||"").trim();
      if(!name) return alert("Bitte Missionsname eingeben.");
      const id = "m"+(Date.now().toString(36));
      const m = {id, name, bonusAwarded:false, tasks:[]};
      state.missions.push(m);
      saveSafe();
      mmName.value="";
      renderList();
    });

    // Demo Mission (Wohnzimmer)
    box.querySelector("#mmDemo").addEventListener("click", ()=>{
      const id = "m"+(Date.now().toString(36));
      const m = {
        id,
        name:"Wohnzimmer fertig",
        bonusAwarded:false,
        tasks:[
          {id:"t1",  name:"Leisten anbringen", points:20, group:null, requires:[],         unlocked:true,  done:false},
          {id:"t2a", name:"Wand streichen",    points:30, group:"g2", requires:["t:t1"],   unlocked:false, done:false},
          {id:"t2b", name:"Lampen anbringen",  points:25, group:"g2", requires:["t:t1"],   unlocked:false, done:false},
          {id:"t3",  name:"Deko & Feinschliff",points:10, group:null, requires:["g:g2"],   unlocked:false, done:false}
        ]
      };
      state.missions.push(m);
      saveSafe();
      renderList();
      alert("Demo-Mission angelegt. Freischaltungen erscheinen im Dashboard.");
      renderAllSafe();
    });

    renderList();
  }

  // Hook in Settings
  const _oldRenderSettingsMM = (typeof window.renderSettings==="function") ? window.renderSettings : null;
  if(_oldRenderSettingsMM){
    window.renderSettings = function(){
      _oldRenderSettingsMM();
      // Bei jedem √ñffnen aktualisieren
      state.missions.forEach(unlockTasks);
      renderMissionsManager();
    };
  }else{
    setTimeout(()=>{ try{ state.missions.forEach(unlockTasks); renderMissionsManager(); }catch{} }, 0);
  }

  // Safety: beim ersten Laden Freischaltungen berechnen
  setTimeout(()=>{ try{ state.missions.forEach(unlockTasks); }catch{} }, 0);

})();
/* ==================== Part 28: Kategorien & Auto-Meilensteine ====================
   Ziele
   - Kategorien f√ºr Quests (inkl. nachtr√§glicher Zuweisung / Umsortierung)
   - Anzeige "Kategorien" im Dashboard mit aufsummierten Punkten je Kategorie
   - Auto-Meilensteine ohne "undefined", unendlich fortlaufend:
       ‚Ä¢ Quests gesamt: Ziele 100,200,500,1000,...  Belohnung = target^2 / 100
       ‚Ä¢ Bossquests:    Ziele 10,20,50,100,...     Belohnung = target^2
       ‚Ä¢ Missionen:     Ziele 5,10,20,50,100,...   Belohnung = target^2
       ‚Ä¢ je Kategorie*: Ziele 50,100,200,500,...   Belohnung = target^2 / 100
         (*negative Kategorien werden NICHT belohnt)
   - Automatisches Erzeugen/Nachschieben des n√§chsten Meilensteins, sobald
     einer erreicht & gutgeschrieben wurde.
   - Keine Datenverluste: Migration vorhandener Daten wird ber√ºcksichtigt.

   Hinweise:
   - Wir fassen "normale Quests" als Log-Eintr√§ge auf, die NICHT
     ‚Ä¢ "Mission:" am Anfang haben,
     ‚Ä¢ "Reward-Kauf", "Event-Bonus", "Missionsbonus", "Tagesziel Bonus"
     hei√üen.
   - Bossquests werden √ºber state.catalog[].boss erkannt (per Name-Match).
   - Kategorien werden Quest-basiert ausgewertet (per Name-Match in catalog).
   ==============================================================================*/
(function autoMilestonesModule(){
  if(window.__autoMilestonesModule) return;
  window.__autoMilestonesModule = true;

  // --- Guards & Defaults ---
  window.state = window.state || {};
  state.catalog = Array.isArray(state.catalog) ? state.catalog : [];
  state.log = Array.isArray(state.log) ? state.log : [];

  // Kategorien-Setup (Default nur einmal anlegen)
  state.categories = Array.isArray(state.categories) ? state.categories : [
    {id:"sport",     name:"Sport",     negative:false},
    {id:"haushalt",  name:"Haushalt",  negative:false},
    {id:"handwerk",  name:"Handwerk",  negative:false},
    {id:"lifestyle-",name:"Schlechter Lebensstil", negative:true}
  ];

  // Bestehende Catalog-Eintr√§ge auf categoryId erweitern (falls fehlt)
  state.catalog.forEach(q=>{
    if(typeof q.categoryId==="undefined") q.categoryId = null; // noch nicht zugewiesen
  });

  // Auto-Milestone State
  state.autoMs = state.autoMs || {
    quests:   { next:100 },
    boss:     { next:10  },
    missions: { next:5   },
    byCat:    {}          // {catId:{next:50}}
  };
  state.autoMsHistory = Array.isArray(state.autoMsHistory) ? state.autoMsHistory : []; // [{type:"quests"|"boss"|"missions"|"cat:<id>", target, date}]

  function todayISO2(){ try{return todayISO();}catch{ return new Date().toISOString().slice(0,10);} }
  function saveSafe(){ try{ save(); }catch{} }
  function renderAllSafe(){ try{ renderAll(); }catch{} }
  function isSpecialName(name=""){
    const n=name.toLowerCase();
    return (
      n.startsWith("mission:") ||
      n.includes("reward-kauf") ||
      n.includes("event-bonus") ||
      n.includes("missionsbonus") ||
      n.includes("tagesziel bonus")
    );
  }
  function findCatalogByName(name){
    return state.catalog.find(c=> (c.name||"").toLowerCase() === (name||"").toLowerCase() );
  }

  // --- Z√§hlungen / Aggregation ---
  function countNormalQuests(){
    return state.log.filter(e=> Number(e.points||0)!==0 && !isSpecialName(e.quest||"")).length;
  }
  function countBossQuests(){
    let cnt=0;
    state.log.forEach(e=>{
      if(Number(e.points||0)===0) return;
      const c = findCatalogByName(e.quest);
      if(c && c.boss===true) cnt++;
    });
    return cnt;
  }
  function countCompletedMissions(){
    // Mission als abgeschlossen werten, wenn bonusAwarded==true
    // (wurde im Missions-Part gesetzt).
    if(!Array.isArray(state.missions)) return 0;
    return state.missions.filter(m=>m && m.bonusAwarded===true).length;
  }
  function categoryPointTotals(){
    // Summe der Punkte je Kategorie (nur Quests, die einem catalog-Eintrag zuordenbar sind)
    const sums = {};
    state.categories.forEach(cat=> sums[cat.id]=0 );
    state.log.forEach(e=>{
      const c = findCatalogByName(e.quest);
      if(!c || !c.categoryId) return;
      if(typeof sums[c.categoryId]==="undefined") sums[c.categoryId]=0;
      sums[c.categoryId] += Number(e.points||0);
    });
    return sums;
  }
  function categoryCounts(){
    // Anzahl erledigter Quests je Kategorie (nur zuordenbare catalog-Eintr√§ge)
    const counts = {};
    state.categories.forEach(cat=> counts[cat.id]=0 );
    state.log.forEach(e=>{
      if(Number(e.points||0)===0) return;
      const c = findCatalogByName(e.quest);
      if(!c || !c.categoryId) return;
      if(typeof counts[c.categoryId]==="undefined") counts[c.categoryId]=0;
      counts[c.categoryId]++;
    });
    return counts;
  }

  // --- Ziel-Progression (‚àû) ---
  const seqQuests    = [100,200,500,1000,2000,5000,10000,20000,50000,100000];
  const seqBoss      = [10,20,50,100,200,500,1000,2000,5000];
  const seqMissions  = [5,10,20,50,100,200,500,1000];
  const seqCategory  = [50,100,200,500,1000,2000,5000,10000];

  function nextFromSeq(current, seq){
    for(const t of seq){ if(t>current) return t; }
    // wenn √ºber allem ‚Üí n√§chstes Ziel verdoppeln
    const last = seq[seq.length-1];
    let n = last;
    while(n<=current) n*=2;
    return n;
  }

  // --- Rewards (gem√§√ü Beispiele) ---
  function rewardQuests(target){   return Math.round((target*target)/100); }
  function rewardBoss(target){     return Math.round(target*target); }
  function rewardMissions(target){ return Math.round(target*target); }
  function rewardCategory(target){ return Math.round((target*target)/100); }

  // --- Auto-Milestones pr√ºfen & ggf. gutschreiben ---
  function alreadyAwarded(key, target){
    return state.autoMsHistory.some(h=>h.type===key && Number(h.target)===Number(target));
  }
  function pushHistory(key, target){
    state.autoMsHistory.push({type:key, target, date: todayISO2()});
  }
  function safeLog(quest, pts){
    state.log.push({date:todayISO2(), quest, points:Number(pts||0)});
  }

  function checkAndAwardAutoMilestones(){
    // Quests gesamt
    const qCount = countNormalQuests();
    const qNext = state.autoMs.quests.next || 100;
    if(qCount>=qNext && !alreadyAwarded("quests", qNext)){
      const reward = rewardQuests(qNext);
      safeLog(`Meilenstein: ${qNext} Quests`, reward);
      pushHistory("quests", qNext);
      state.autoMs.quests.next = nextFromSeq(qNext, seqQuests);
    }

    // Bossquests
    const bCount = countBossQuests();
    const bNext  = state.autoMs.boss.next || 10;
    if(bCount>=bNext && !alreadyAwarded("boss", bNext)){
      const reward = rewardBoss(bNext);
      safeLog(`Meilenstein: ${bNext} Bossquests`, reward);
      pushHistory("boss", bNext);
      state.autoMs.boss.next = nextFromSeq(bNext, seqBoss);
    }

    // Missionen
    const mCount = countCompletedMissions();
    const mNext  = state.autoMs.missions.next || 5;
    if(mCount>=mNext && !alreadyAwarded("missions", mNext)){
      const reward = rewardMissions(mNext);
      safeLog(`Meilenstein: ${mNext} Missionen`, reward);
      pushHistory("missions", mNext);
      state.autoMs.missions.next = nextFromSeq(mNext, seqMissions);
    }

    // Kategorien (nur positive)
    const catCnts = categoryCounts();
    state.categories.forEach(cat=>{
      if(cat.negative) return; // negative Kategorien werden nicht belohnt
      // init next
      if(!state.autoMs.byCat[cat.id]) state.autoMs.byCat[cat.id] = {next:50};
      const nextT = state.autoMs.byCat[cat.id].next || 50;
      const cur   = Number(catCnts[cat.id]||0);
      if(cur>=nextT && !alreadyAwarded("cat:"+cat.id, nextT)){
        const reward = rewardCategory(nextT);
        safeLog(`Meilenstein: ${nextT} Quests in ${cat.name}`, reward);
        pushHistory("cat:"+cat.id, nextT);
        state.autoMs.byCat[cat.id].next = nextFromSeq(nextT, seqCategory);
      }
    });

    saveSafe();
  }

  // --- UI: Dashboard ‚Äì Kategorien & Auto-Meilensteine (Next Targets) ---
  function renderCategoriesBox(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // remove old
    const old = document.getElementById("categoriesDashBox");
    if(old) old.remove();

    const sums = categoryPointTotals();
    const box = document.createElement("div");
    box.id = "categoriesDashBox";
    box.className = "mt-4 p-3 border rounded bg-white";

    const title = document.createElement("h3");
    title.className = "font-bold mb-2";
    title.textContent = "Kategorien";
    box.appendChild(title);

    if(state.categories.length===0){
      box.innerHTML += `<div class="text-sm text-slate-500">Noch keine Kategorien.</div>`;
      host.appendChild(box); return;
    }

    // Liste: Name ‚Äî Punkte-Summe
    const list = document.createElement("div");
    list.className = "space-y-1 text-sm";
    state.categories.forEach(cat=>{
      const val = Number(sums[cat.id]||0);
      const row = document.createElement("div");
      row.className = "flex justify-between";
      row.innerHTML = `<span>${cat.negative?'‚ö†Ô∏è ':''}${cat.name}</span><span>${val>=0?'+':''}${val} Punkte</span>`;
      list.appendChild(row);
    });
    box.appendChild(list);

    host.appendChild(box);
  }

  function renderAutoMilestonesBox(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // remove old
    const old = document.getElementById("autoMsDashBox");
    if(old) old.remove();

    // live counts
    const qCount = countNormalQuests();
    const bCount = countBossQuests();
    const mCount = countCompletedMissions();
    const catCnts = categoryCounts();

    const box = document.createElement("div");
    box.id = "autoMsDashBox";
    box.className = "mt-4 p-3 border rounded bg-orange-50";
    box.innerHTML = `<h3 class="font-bold">Meilensteine (automatisch)</h3>`;

    // helper progress row
    function row(label, cur, next, rewardText){
      const pct = next ? Math.max(0, Math.min(100, Math.round(cur/next*100))) : 0;
      return `
        <div class="mt-2">
          <div class="flex justify-between text-sm"><span>${label}</span><span>${cur}/${next}</span></div>
          <div class="w-full bg-gray-200 rounded h-2">
            <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
          </div>
          <div class="text-xs mt-1 text-slate-600">${rewardText}</div>
        </div>
      `;
    }

    const qNext = state.autoMs.quests.next || 100;
    box.innerHTML += row("Quests gesamt", qCount, qNext, `Belohnung bei ${qNext}: +${rewardQuests(qNext)} Punkte`);

    const bNext = state.autoMs.boss.next || 10;
    box.innerHTML += row("Bossquests", bCount, bNext, `Belohnung bei ${bNext}: +${rewardBoss(bNext)} Punkte`);

    const mNext = state.autoMs.missions.next || 5;
    box.innerHTML += row("Missionen abgeschlossen", mCount, mNext, `Belohnung bei ${mNext}: +${rewardMissions(mNext)} Punkte`);

    // Kategorien (nur positive)
    state.categories.filter(c=>!c.negative).forEach(cat=>{
      if(!state.autoMs.byCat[cat.id]) state.autoMs.byCat[cat.id] = {next:50};
      const n = state.autoMs.byCat[cat.id].next || 50;
      const cur = Number(catCnts[cat.id]||0);
      box.innerHTML += row(`Kategorie: ${cat.name}`, cur, n, `Belohnung bei ${n}: +${rewardCategory(n)} Punkte`);
    });

    host.appendChild(box);
  }

  // Hook ins Dashboard (anh√§ngen nach existierendem renderDashboard)
  const _oldRenderDashboardMS = (typeof window.renderDashboard==="function") ? window.renderDashboard : null;
  if(_oldRenderDashboardMS){
    window.renderDashboard = function(){
      _oldRenderDashboardMS();
      // bei jedem Render Fortschritt + Boxen aktualisieren
      checkAndAwardAutoMilestones();
      renderCategoriesBox();
      renderAutoMilestonesBox();
    };
  }else{
    // Fallback: einmalig nach Load
    setTimeout(()=>{
      checkAndAwardAutoMilestones();
      renderCategoriesBox();
      renderAutoMilestonesBox();
    }, 0);
  }

  // --- UI: Settings ‚Äì Kategorien & Zuweisung ---
  function renderCategoriesManager(){
    const host = document.getElementById("tab-settings");
    if(!host) return;

    const old = document.getElementById("catManager");
    if(old) old.remove();

    const sums = categoryPointTotals();

    const wrap = document.createElement("div");
    wrap.id = "catManager";
    wrap.className = "mt-6 p-3 border rounded bg-white space-y-3";
    wrap.innerHTML = `
      <h3 class="font-bold">Kategorien &amp; Zuweisung</h3>

      <div class="space-y-1" id="catList"></div>

      <div class="grid grid-cols-1 md:grid-cols-4 gap-2 mt-2">
        <input id="catNewName" class="input md:col-span-2" placeholder="Neue Kategorie">
        <label class="flex items-center gap-2 text-sm"><input id="catNewNeg" type="checkbox"> negative Kategorie</label>
        <button id="catAdd" class="btn bg-blue-600 text-white">+ Kategorie</button>
      </div>

      <div class="mt-4">
        <div class="font-medium mb-2">Quests zuordnen</div>
        <div id="catAssign" class="space-y-1"></div>
      </div>
    `;
    host.appendChild(wrap);

    // Render Kategorienliste mit Summen
    function renderCatList(){
      const box = wrap.querySelector("#catList");
      box.innerHTML = state.categories.length===0
        ? `<div class="text-sm text-slate-500">Noch keine Kategorien.</div>`
        : state.categories.map(cat=>{
            const val = Number(sums[cat.id]||0);
            return `
              <div class="p-2 border rounded flex justify-between items-center">
                <div>
                  ${cat.negative?'‚ö†Ô∏è ':''}<b>${cat.name}</b>
                  <div class="text-xs text-slate-600">${val>=0?'+':''}${val} Punkte gesamt</div>
                </div>
                <div class="flex gap-2">
                  <button class="btn text-xs" data-rename="${cat.id}">Umbenennen</button>
                  <button class="btn text-xs border-red-300" data-delcat="${cat.id}">L√∂schen</button>
                </div>
              </div>
            `;
          }).join("");

      // Rename
      box.querySelectorAll("[data-rename]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const id = btn.getAttribute("data-rename");
          const cat = state.categories.find(c=>c.id===id);
          if(!cat) return;
          const nn = prompt("Neuer Name f√ºr Kategorie:", cat.name);
          if(!nn) return;
          cat.name = nn.trim();
          saveSafe(); renderCatList(); renderAssignList(); renderAllSafe();
        });
      });

      // Delete (nur wenn nicht zugewiesen)
      box.querySelectorAll("[data-delcat]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const id = btn.getAttribute("data-delcat");
          const used = state.catalog.some(q=>q.categoryId===id);
          if(used){ alert("Kategorie ist Quests zugewiesen und kann nicht gel√∂scht werden."); return; }
          const idx = state.categories.findIndex(c=>c.id===id);
          if(idx>=0){
            if(confirm("Kategorie wirklich l√∂schen?")){
              state.categories.splice(idx,1);
              // Aufr√§umen evtl. autoMs.byCat
              if(state.autoMs.byCat && state.autoMs.byCat[id]) delete state.autoMs.byCat[id];
              saveSafe(); renderCatList(); renderAllSafe();
            }
          }
        });
      });
    }

    // Render Zuordnungsliste (alle catalog-Quests mit Dropdown)
    function renderAssignList(){
      const box = wrap.querySelector("#catAssign");
      if(state.catalog.length===0){
        box.innerHTML = `<div class="text-sm text-slate-500">Noch keine Quests im Katalog.</div>`;
        return;
      }
      const options = [
        `<option value="">(keine)</option>`,
        ...state.categories.map(c=>`<option value="${c.id}">${c.name}</option>`)
      ].join("");

      box.innerHTML = state.catalog.map((q,i)=>`
        <div class="grid grid-cols-3 gap-2 items-center">
          <div class="truncate">${q.boss?'üëë ':''}${q.name}</div>
          <div>${q.points} Punkte</div>
          <select class="input" data-assign="${i}">
            ${options}
          </select>
        </div>
      `).join("");

      // Set current values
      box.querySelectorAll("[data-assign]").forEach(sel=>{
        const idx = Number(sel.getAttribute("data-assign"));
        sel.value = state.catalog[idx].categoryId || "";
        sel.addEventListener("change", ()=>{
          const val = sel.value || null;
          state.catalog[idx].categoryId = val;
          saveSafe(); renderAllSafe();
        });
      });
    }

    // Add Kategorie
    wrap.querySelector("#catAdd").addEventListener("click", ()=>{
      const name = (wrap.querySelector("#catNewName").value||"").trim();
      const neg  = !!wrap.querySelector("#catNewNeg").checked;
      if(!name) return;
      // ID generieren (slug)
      let id = name.toLowerCase().normalize("NFKD").replace(/[^\w\- ]+/g,"").trim().replace(/\s+/g,"-");
      if(!id) id = "cat-"+Date.now().toString(36);
      if(state.categories.find(c=>c.id===id)){
        id += "-"+Math.floor(Math.random()*1000);
      }
      state.categories.push({id,name,negative:neg});
      if(!state.autoMs.byCat) state.autoMs.byCat = {};
      if(!state.autoMs.byCat[id]) state.autoMs.byCat[id] = {next:50};
      wrap.querySelector("#catNewName").value="";
      wrap.querySelector("#catNewNeg").checked=false;
      saveSafe(); renderCatList(); renderAssignList(); renderAllSafe();
    });

    renderCatList();
    renderAssignList();
  }

  // Hook in Settings
  const _oldRenderSettingsMS = (typeof window.renderSettings==="function") ? window.renderSettings : null;
  if(_oldRenderSettingsMS){
    window.renderSettings = function(){
      _oldRenderSettingsMS();
      renderCategoriesManager();
    };
  }else{
    setTimeout(()=>renderCategoriesManager(),0);
  }

  // --- Reaktion auf neue Logs: Auto-Milestones pr√ºfen ---
  const _oldAddLogMS = (typeof window.addLog==="function") ? window.addLog : null;
  if(_oldAddLogMS){
    window.addLog = function(){
      const before = state.log.length;
      _oldAddLogMS();
      if(state.log.length>before){
        checkAndAwardAutoMilestones();
        renderAllSafe();
      }
    };
  }

  // Safety: initialer Check
  setTimeout(()=>{ checkAndAwardAutoMilestones(); },0);

})();
<script>
// ====================== NEGATIVE KATEGORIEN ‚Äì SETUP ======================
(function(){
  // 1) Defaults & Migration
  state.categories = state.categories || [
    { key:"Allgemein",                label:"Allgemein",                negative:false, malusMultiplier:1 },
    { key:"Gesundheit",               label:"Gesundheit",               negative:false, malusMultiplier:1 },
    { key:"Sport",                    label:"Sport",                    negative:false, malusMultiplier:1 },
    { key:"Ordnung",                  label:"Ordnung",                  negative:false, malusMultiplier:1 },
    { key:"Finanzen",                 label:"Finanzen",                 negative:false, malusMultiplier:1 },
    { key:"Beziehung",                label:"Beziehung",                negative:false, malusMultiplier:1 },
    { key:"Handwerk",                 label:"Handwerk",                 negative:false, malusMultiplier:1 },
    { key:"Schlechter Lebensstil",    label:"Schlechter Lebensstil",    negative:true,  malusMultiplier:2 } // Beispiel: +15 in der Kategorie, -30 gesamt
  ];

  // vorhandenen Katalog migrieren (alle ohne Kategorie -> "Allgemein")
  state.catalog = state.catalog || [];
  state.catalog.forEach(q => { if(!q.category) q.category = "Allgemein"; });
  save();

  // Helper
  const catByKey = (k)=> state.categories.find(c=>c.key===k);
  const catOptionsHTML = ()=> state.categories.map(c=>`<option value="${c.key}">${c.label}${c.negative?' (negativ)':''}</option>`).join('');

  // 2) Globale Hook f√ºr alle Log-Eintr√§ge (auch wenn irgendwo direkt state.log.push genutzt wird)
  if(!state.__logPushPatched){
    const origPush = state.log.push.bind(state.log);
    state.log.push = function(entry){
      try { entry = normalizeLogEntry(entry); } catch(e){}
      return origPush(entry);
    };
    state.__logPushPatched = true;
  }

  // Negative Kat.-Logik: Punkte flie√üen NUR negativ in die Gesamtpunkte,
  // aber positiv in die Kategoriensumme (√ºber e.catPoints).
  function normalizeLogEntry(e){
    // ignore System-/Hilfseintr√§ge, die keinen Quest-Bezug haben
    if(!e || typeof e!=="object" || !e.quest) return e;

    // passenden Quest im Katalog suchen (exakte Namensgleichheit)
    const q = state.catalog.find(x => x.name === e.quest);
    if(!q || !q.category) return e;

    const cat = catByKey(q.category);
    if(!cat || !cat.negative) return e; // positive Kategorien unver√§ndert

    // schon normalisiert?
    if(typeof e.catPoints === "number" && typeof e.points === "number" && e.points <= 0) return e;

    // Basis: wenn base vorhanden, die verwenden; sonst Betrag der Punkte
    const base = (typeof e.base === "number" && e.base>0) ? e.base : Math.abs(Number(e.points) || 0);
    const catPts = base; // positive Kategoriensumme
    const malus  = -Math.round(base * (cat.malusMultiplier || 2)); // z.B. -30 bei base 15

    // in die Gesamtpunkte soll nur der Malus flie√üen
    return Object.assign({}, e, { points: malus, catPoints: catPts, negative:true });
  }

  // 3) Kategoriensummen berechnen (f√ºr Dashboard)
  function categoryTotals(){
    const totals = {};
    state.categories.forEach(c => totals[c.key] = 0);

    state.log.forEach(e=>{
      // nur Eintr√§ge mit Katalog-Quest z√§hlen
      const q = state.catalog.find(x => x.name === e.quest);
      if(!q || !q.category) return;
      const cat = q.category;
      // Negative Kategorien: catPoints (positiv) z√§hlen
      if(e.hasOwnProperty("catPoints")){
        totals[cat] += Number(e.catPoints)||0;
      }else{
        // normale Kategorien: normale Punkte z√§hlen (>=0; falls negativ, nicht addieren)
        const p = Number(e.points)||0;
        if(p>0) totals[cat] += p;
      }
    });

    return totals;
  }

  // 4) Dashboard: Kategoriekasten mit Summen
  function renderCategoryOverview(){
    const totals = categoryTotals();
    const box = document.createElement('div');
    box.className = "mt-4";
    box.innerHTML = `<h3 class="font-bold">Kategorien (Summen)</h3>`;
    Object.keys(totals).forEach(key=>{
      const c = catByKey(key);
      const sum = totals[key]||0;
      const row = document.createElement('div');
      row.className = `flex justify-between items-center p-2 border rounded mb-1 ${c?.negative?'bg-red-50 border-red-200':'bg-white'}`;
      row.innerHTML = `
        <span>${c?.label || key} ${c?.negative?'<span class="text-xs ml-2 px-2 py-[2px] rounded bg-red-100 text-red-700">negativ</span>':''}</span>
        <span class="font-medium ${c?.negative?'text-red-700':'text-slate-700'}">${c?.negative?'+':''}${sum} Punkte</span>
      `;
      box.appendChild(row);
    });
    document.getElementById("tab-dashboard").appendChild(box);
  }

  // 5) Log-Ansicht: catPoints anzeigen (falls vorhanden)
  const __oldRenderLog_negCat = renderLog;
  renderLog = function(){
    __oldRenderLog_negCat();
    const list = document.getElementById("logList");
    if(!list) return;
    // Markiere Items mit catPoints (negativ) h√ºbsch
    const items = list.querySelectorAll(":scope > div");
    // Wir m√ºssen die state.log-Reihenfolge (wie im Renderer) kennen ‚Äì dort wird simple map genutzt.
    // Einfach neu bauen: (kurz & robust)
    list.innerHTML = state.log.map(e=>{
      const cat = state.catalog.find(x=>x.name===e.quest)?.category || '';
      const catBadge = cat ? `<span class="ml-2 text-xs px-2 py-[2px] rounded bg-slate-100">${cat}</span>` : '';
      const lineBase = `${e.date} ‚Ä¢ ${e.quest}${catBadge}`;
      if(typeof e.catPoints === "number"){
        return `<div class="p-2 rounded border bg-red-50 border-red-200">
          <div class="flex justify-between">
            <span>${lineBase}</span>
            <span class="font-semibold text-red-700">${e.points}</span>
          </div>
          <div class="text-xs text-slate-600 mt-1">Kategorie-Wert: +${e.catPoints} Punkte (z√§hlt nur f√ºr die Kategorie)</div>
        </div>`;
      }else{
        return `<div class="p-2 rounded border bg-white">${lineBase} <span class="float-right font-semibold">+${e.points}</span></div>`;
      }
    }).join("") || "Noch keine Eintr√§ge.";
  };

  // 6) Katalog: Formular + Zeilen um Kategorie-Auswahl erweitern
  const __oldRenderCatalog_negCat = renderCatalog;
  renderCatalog = function(){
    const host = document.getElementById("tab-catalog");
    if(!host){ __oldRenderCatalog_negCat(); return; }

    // eigenes Rendering, damit wir die Kategorie-Selects √ºberall haben
    host.innerHTML = `
      <div class="space-y-2">
        <input id="qName" class="input" placeholder="Questname" />
        <input id="qPoints" type="number" class="input" placeholder="Punkte" />
        <select id="qCategory" class="input">
          ${catOptionsHTML()}
        </select>
        <select id="qBoss" class="input">
          <option value="false">Normale Quest</option>
          <option value="true">Bossquest</option>
        </select>
        <button id="btnAddQuest" class="btn bg-blue-600 text-white">Zur Liste hinzuf√ºgen</button>
      </div>
      <div id="catalogList" class="mt-4 space-y-2"></div>
    `;

    const list = document.getElementById("catalogList");
    const renderRows = ()=>{
      list.innerHTML = state.catalog.map((q,i)=>`
        <div class="p-2 border rounded flex flex-col gap-2 ${q.boss?'bg-yellow-50':'bg-white'}">
          <div class="flex items-center justify-between">
            <div>
              <div class="font-medium">${q.boss?'üëë ':''}${q.name} (+${q.points} Punkte)</div>
              <div class="text-xs text-slate-500">Kategorie: ${q.category||'Allgemein'}</div>
            </div>
            <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
          </div>
          <div class="grid grid-cols-2 gap-2">
            <label class="text-xs">Kategorie √§ndern
              <select class="input" data-edit-cat="${i}">
                ${state.categories.map(c=>`<option value="${c.key}" ${q.category===c.key?'selected':''}>${c.label}${c.negative?' (negativ)':''}</option>`).join('')}
              </select>
            </label>
            <label class="text-xs">Punkte anpassen
              <input class="input" type="number" data-edit-pts="${i}" value="${q.points}">
            </label>
          </div>
        </div>
      `).join("");

      // Delete
      list.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const idx = Number(btn.getAttribute("data-del"));
          state.catalog.splice(idx,1); save(); renderCatalog();
        });
      });
      // Kategorie √§ndern
      list.querySelectorAll("[data-edit-cat]").forEach(sel=>{
        sel.addEventListener("change",()=>{
          const i = Number(sel.getAttribute("data-edit-cat"));
          state.catalog[i].category = sel.value; save(); renderCatalog();
        });
      });
      // Punkte √§ndern
      list.querySelectorAll("[data-edit-pts]").forEach(inp=>{
        inp.addEventListener("change",()=>{
          const i = Number(inp.getAttribute("data-edit-pts"));
          state.catalog[i].points = Number(inp.value)||0; save();
        });
      });
    };

    // Add-Button
    document.getElementById("btnAddQuest").addEventListener("click",()=>{
      const name = document.getElementById("qName").value.trim();
      const pts  = Number(document.getElementById("qPoints").value||0);
      const cat  = document.getElementById("qCategory").value || "Allgemein";
      const boss = document.getElementById("qBoss").value==="true";
      if(!name || !pts) return;
      state.catalog.push({ name, points:pts, category:cat, boss });
      save();
      document.getElementById("qName").value="";
      document.getElementById("qPoints").value="";
      renderRows();
    });

    renderRows();
  };

  // 7) Dashboard um Kategorie-Box erweitern
  const __oldRenderDashboard_negCat = renderDashboard;
  renderDashboard = function(){
    __oldRenderDashboard_negCat();
    renderCategoryOverview();
  };

  // 8) Beim Speichern sicherstellen
  save();
})();
</script>
<script>
// ====================== MISSIONEN ‚Äì FREISCHALTBAR / ALTERNATIVEN / 4√ó BONUS ======================
(function(){
  // ---- State + Migration ----
  state.missions = state.missions || []; // [{id,name,category,steps:[{id,label,points,reqAll:[],reqAny:[],optional:false,done:false}],completed:false}]

  function uid(){ return Math.random().toString(36).slice(2,8); }
  function missionById(id){ return state.missions.find(m=>m.id===id); }
  function stepById(m,stepId){ return m.steps.find(s=>s.id===stepId); }

  // ---- Verf√ºgbarkeit eines Schritts pr√ºfen ----
  function isStepAvailable(m, s){
    if(s.done) return false;
    const doneSet = new Set(m.steps.filter(x=>x.done).map(x=>x.id));
    // reqAll: alle erforderlich
    if(s.reqAll && s.reqAll.length){
      for(const r of s.reqAll){ if(!doneSet.has(r)) return false; }
      return true;
    }
    // reqAny: mindestens einer erforderlich
    if(s.reqAny && s.reqAny.length){
      return s.reqAny.some(r=>doneSet.has(r));
    }
    // keine Voraussetzungen -> sofort verf√ºgbar
    return true;
  }

  // ---- Mission abgeschlossen? (alle NICHT optionalen Schritte erledigt) ----
  function isMissionCompleted(m){
    return m.steps.filter(s=>!s.optional).every(s=>!!s.done);
  }

  // ---- Katalog-Quest sicherstellen (f√ºr Kategorie/negative Kategorien-Logik) ----
  function ensureCatalogQuest(name, basePoints, category, boss=false){
    let q = state.catalog.find(x=>x.name===name);
    if(!q){
      q = { name, points: basePoints, category: category||"Allgemein", boss: !!boss };
      state.catalog.push(q); save();
    }else{
      // Punkte ggf. aktualisieren (nur, wenn noch nicht gesetzt)
      if(!q.points) q.points = basePoints;
      if(!q.category) q.category = category||"Allgemein";
    }
    return q;
  }

  // ---- Schritt abschlie√üen -> Punkte loggen -> Mission pr√ºfen -> 4√ó Bonus ----
  function completeStep(missionId, stepId){
    const m = missionById(missionId);
    if(!m) return;
    const s = stepById(m, stepId);
    if(!s || s.done) return;

    // Quest im Katalog sichern (damit Kategorie-Logik greift)
    ensureCatalogQuest(s.label, s.points, m.category||"Allgemein", false);

    // Punkte berechnen + loggen (computePoints inkl. Perks/Events/Negatives greift √ºber Katalog)
    const today = todayISO();
    const pts = computePoints(s.points, today);
    state.log.push({date: today, quest: s.label, points: pts, base: s.points});
    s.done = true;
    save(); renderAll();

    // Mission-Abschluss & 4√ó Bonus
    if(isMissionCompleted(m) && !m.completed){
      m.completed = true;

      const sumBase = m.steps
        .filter(x=>!x.optional) // Bonus orientiert sich an ‚ÄûPflicht‚Äú-Schritten
        .reduce((acc,x)=>acc + (x.points||0), 0);

      const bonus = 4 * sumBase; // Vorgabe: 4√ó so viele Punkte als Belohnung
      state.log.push({date: todayISO(), quest: "Mission Bonus: "+m.name, points: bonus, base: bonus});
      save(); renderAll();

      // kleines Feedback
      try{ if(typeof FX!=="undefined"){ FX.burst(); setTimeout(()=>FX.burst(),150); } }catch{}
    }
  }

  // ---- Mission/Steps Editor (im Katalog) ----
  function renderMissionsEditor(){
    const host = document.getElementById("tab-catalog");
    if(!host) return;

    const wrap = document.createElement("div");
    wrap.className = "mt-6 p-3 border rounded bg-slate-50";
    wrap.innerHTML = `
      <h3 class="font-bold">Missionen</h3>
      <div class="text-sm text-slate-600 mb-2">
        Schritte k√∂nnen Voraussetzungen haben (alle/irgendeine). Optional bedeutet: Schritt z√§hlt nicht als Pflicht zum Abschluss.
      </div>
      <div class="flex gap-2 mb-3">
        <input id="mNewName" class="input flex-1" placeholder="Neue Mission: Name" />
        <select id="mNewCat" class="input w-40">
          ${ (state.categories||[{key:"Allgemein",label:"Allgemein"}]).map(c=>`<option value="${c.key}">${c.label}${c.negative?' (negativ)':''}</option>`).join('') }
        </select>
        <button id="btnAddMission" class="btn bg-purple-600 text-white">+ Mission</button>
      </div>
      <div id="missionsList" class="space-y-3"></div>
    `;
    host.appendChild(wrap);

    const list = wrap.querySelector("#missionsList");

    function renderList(){
      list.innerHTML = state.missions.map(m=>{
        const doneCnt = m.steps.filter(s=>s.done).length;
        const mustCnt = m.steps.filter(s=>!s.optional).length;
        const status = m.completed ? `‚úÖ Abgeschlossen` : `${doneCnt}/${m.steps.length} Schritte (${mustCnt} Pflicht)`;

        return `
          <div class="p-3 border rounded bg-white">
            <div class="flex justify-between items-center">
              <div>
                <div class="font-medium">${m.name}</div>
                <div class="text-xs text-slate-500">Kategorie: ${m.category||"Allgemein"} ‚Ä¢ ${status}</div>
              </div>
              <div class="flex gap-2">
                <button class="btn" data-add-step="${m.id}">+ Schritt</button>
                <button class="btn text-red-600" data-del-m="${m.id}">L√∂schen</button>
              </div>
            </div>
            <div class="mt-2 space-y-2">
              ${m.steps.map(s=>{
                const avail = isStepAvailable(m,s);
                const reqAllTxt = (s.reqAll&&s.reqAll.length)?`alle: [${s.reqAll.join(", ")}]`:"";
                const reqAnyTxt = (s.reqAny&&s.reqAny.length)?`eine von: [${s.reqAny.join(", ")}]`:"";
                const reqTxt = (reqAllTxt||reqAnyTxt) ? `Voraussetzungen: ${[reqAllTxt,reqAnyTxt].filter(Boolean).join(" ‚Ä¢ ")}` : "keine Voraussetzungen";
                return `
                  <div class="p-2 border rounded ${s.done?'bg-green-50': avail?'bg-yellow-50':'bg-slate-50'}">
                    <div class="flex justify-between items-center">
                      <div>
                        <div><b>${s.id}</b> ‚Ä¢ ${s.label} <span class="text-xs text-slate-500">(+${s.points})${s.optional?' ‚Ä¢ optional':''}</span></div>
                        <div class="text-xs text-slate-500">${reqTxt}</div>
                      </div>
                      <div class="flex gap-2">
                        ${!s.done && avail ? `<button class="btn bg-blue-600 text-white" data-done="${m.id}|${s.id}">Abschlie√üen</button>` : ``}
                        <button class="btn" data-edit="${m.id}|${s.id}">‚úé</button>
                        <button class="btn text-red-600" data-del="${m.id}|${s.id}">üóë</button>
                      </div>
                    </div>
                  </div>
                `;
              }).join("")}
            </div>
          </div>
        `;
      }).join("");

      // Handlers: Mission l√∂schen
      list.querySelectorAll("[data-del-m]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id = btn.getAttribute("data-del-m");
          state.missions = state.missions.filter(x=>x.id!==id);
          save(); renderList();
        });
      });

      // Handlers: Schritt abschlie√üen
      list.querySelectorAll("[data-done]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const [mid,sid] = btn.getAttribute("data-done").split("|");
          completeStep(mid,sid);
          renderList();
        });
      });

      // Handlers: Schritt l√∂schen
      list.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const [mid,sid] = btn.getAttribute("data-del").split("|");
          const m = missionById(mid);
          if(!m) return;
          m.steps = m.steps.filter(s=>s.id!==sid);
          // Mission-Status ggf. neu bewerten
          if(isMissionCompleted(m)) m.completed = true; else m.completed = false;
          save(); renderList();
        });
      });

      // Handlers: Schritt editieren (Prompt-basiert, schnell & simpel)
      list.querySelectorAll("[data-edit]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const [mid,sid] = btn.getAttribute("data-edit").split("|");
          const m = missionById(mid), s = stepById(m,sid);
          if(!m || !s) return;
          const newLabel = prompt("Neuer Titel:", s.label) ?? s.label;
          const newPts   = Number(prompt("Neue Punkte:", s.points) ?? s.points);
          // reqType: "all" / "any"
          const type = prompt("Voraussetzungen Typ ('all' oder 'any'):", (s.reqAny && s.reqAny.length)? "any" : ((s.reqAll&&s.reqAll.length)?"all":"all")) || "all";
          const reqStr = prompt("Voraussetzungen (kommagetrennte Schritt-IDs, z. B. 1 oder 2.0,2.1):",
                                (s.reqAny&&s.reqAny.length?s.reqAny.join(","): (s.reqAll&&s.reqAll.length?s.reqAll.join(","):"")));
          const opt    = prompt("Optional? ('ja' oder 'nein'):", s.optional?"ja":"nein") || (s.optional?"ja":"nein");

          s.label = newLabel.trim() || s.label;
          s.points = isNaN(newPts) ? s.points : newPts;
          s.reqAll = []; s.reqAny = [];
          const arr = (reqStr||"").split(",").map(x=>x.trim()).filter(Boolean);
          if(type.toLowerCase()==="any") s.reqAny = arr; else s.reqAll = arr;
          s.optional = (opt.toLowerCase().startsWith("j"));

          save(); renderList();
        });
      });

      // Handlers: Schritt hinzuf√ºgen (kleine Inline-Prompts ‚Äì schnell anlegbar)
      list.querySelectorAll("[data-add-step]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const mid = btn.getAttribute("data-add-step");
          const m = missionById(mid); if(!m) return;
          const id = prompt("Schritt-ID (z. B. 1, 2.0, 2.1):", (m.steps.length+1).toString()) || (m.steps.length+1).toString();
          const label = prompt("Titel des Schritts:", "Neuer Schritt");
          const points = Number(prompt("Punkte f√ºr den Schritt:", "10")||"10");
          const type = prompt("Voraussetzungen Typ ('all' oder 'any'):", "all") || "all";
          const reqStr = prompt("Voraussetzungen (kommagetrennte Schritt-IDs, leer = keine):","") || "";
          const optional = confirm("Schritt optional? (OK = ja / Abbrechen = nein)");

          const step = {
            id: id.trim(),
            label: (label||"").trim() || ("Schritt "+id),
            points: isNaN(points)?10:points,
            reqAll: type.toLowerCase()==="any" ? [] : reqStr.split(",").map(x=>x.trim()).filter(Boolean),
            reqAny: type.toLowerCase()==="any" ? reqStr.split(",").map(x=>x.trim()).filter(Boolean) : [],
            optional: !!optional,
            done: false
          };
          m.steps.push(step);
          save(); renderList();
        });
      });
    }

    // Mission anlegen
    wrap.querySelector("#btnAddMission").addEventListener("click",()=>{
      const name = (wrap.querySelector("#mNewName").value||"").trim();
      const cat  = wrap.querySelector("#mNewCat").value || "Allgemein";
      if(!name) return;
      state.missions.push({ id: uid(), name, category: cat, steps: [], completed:false });
      wrap.querySelector("#mNewName").value="";
      save(); renderList();
    });

    renderList();
  }

  // ---- Dashboard: ‚ÄûOffene Missions-Schritte heute‚Äú Quick-Panel ----
  function renderMissionsQuickPanel(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // Ermitteln: alle verf√ºgbaren (nicht erledigten) Schritte
    const available = [];
    state.missions.forEach(m=>{
      m.steps.forEach(s=>{
        if(isStepAvailable(m,s)) available.push({mId:m.id, mName:m.name, s});
      });
    });

    const box = document.createElement("div");
    box.className = "mt-4 p-3 border rounded bg-slate-50";
    box.innerHTML = `<h3 class="font-bold">Missionen ‚Äì offene Schritte</h3>`;
    if(available.length===0){
      box.innerHTML += `<div class="text-sm text-slate-500">Keine offenen/entsperrten Schritte.</div>`;
    }else{
      const btnWrap = document.createElement("div");
      btnWrap.className = "space-y-2 mt-2";
      available.slice(0,6).forEach(it=>{
        const btn = document.createElement("button");
        btn.className = "btn w-full text-left";
        btn.textContent = `‚ûï ${it.mName}: ${it.s.id} ‚Ä¢ ${it.s.label} (+${it.s.points})`;
        btn.addEventListener("click",()=>{
          completeStep(it.mId, it.s.id);
        });
        btnWrap.appendChild(btn);
      });
      box.appendChild(btnWrap);
    }
    host.appendChild(box);
  }

  // ---- Render-Hooks einh√§ngen ----
  const __oldRenderCatalog_missions = renderCatalog;
  renderCatalog = function(){
    __oldRenderCatalog_missions();
    renderMissionsEditor();
  };

  const __oldRenderDashboard_missions = renderDashboard;
  renderDashboard = function(){
    __oldRenderDashboard_missions();
    renderMissionsQuickPanel();
  };

  save();
})();
</script>
<script>
// ====================== KATEGORIEN ‚Äì Manager, Summen, Negative & Links ======================
(function(){
  // ---------- Defaults / Migration ----------
  state.categories = state.categories || [
    {key:"Allgemein", label:"Allgemein", negative:false},
    {key:"Sport", label:"Sport", negative:false},
    {key:"Handwerk", label:"Handwerk", negative:false},
    {key:"Haushalt", label:"Haushalt", negative:false},
    {key:"Ern√§hrung", label:"Ern√§hrung", negative:false},
    // negative Kategorie mit Straf-Faktor: globaler Abzug = faktor * Kategorie-Plus
    {key:"Schlechter Lebensstil", label:"Schlechter Lebensstil", negative:true, penaltyMultiplier:2}
  ];
  state.categoryLinks = state.categoryLinks || [
    // Beispiel: Handwerk gibt +5 Kategorien-Punkte f√ºr Sport (kein globaler Effekt)
    // {from:"Handwerk", to:"Sport", bonus:5}
  ];

  // allen Katalog-Quests Standard-Kategorie geben
  (state.catalog||[]).forEach(q=>{ if(!q.category) q.category="Allgemein"; });

  // ---------- Helpers ----------
  function getCatByKey(key){ return state.categories.find(c=>c.key===key); }
  function labelOf(key){ return (getCatByKey(key)||{label:key}).label; }
  function ensureCategory(key,label,negative=false,mult=2){
    let c = getCatByKey(key);
    if(!c){
      c = {key, label: label||key, negative, penaltyMultiplier: mult};
      state.categories.push(c); save();
    }
    return c;
  }

  function normalizeQuestName(name){
    if(!name) return "";
    // st√∂rende Zus√§tze entfernen
    return name
      .replace(/^\s*Timed Quest:\s*/i,"")
      .replace(/\s*\(Event Bonus\)\s*$/i,"")
      .trim();
  }
  function findCatalogQuestByName(name){
    const n = normalizeQuestName(name).toLowerCase();
    // exakte Suche
    let q = state.catalog.find(q=>q.name.toLowerCase()===n);
    if(q) return q;
    // sanfter: enth√§lt-Variante (zur Not)
    return state.catalog.find(q=>n.includes(q.name.toLowerCase())) || null;
  }

  // ---------- Kategorie-Summen aus Log berechnen ----------
  // Regeln:
  // - Eintr√§ge mit e.categoryOnly z√§hlen f√ºr die angegebene e.catKey.
  // - Normale Eintr√§ge werden der Kategorie ihrer Quest zugerechnet.
  // - Straf-/Penalty-Eintr√§ge (e.penalty) z√§hlen NICHT in Kategorien-Summe.
  function computeCategoryTotals(){
    const totals = {};
    state.categories.forEach(c=>totals[c.key]=0);

    for(const e of state.log){
      if(e.penalty) continue;

      if(e.categoryOnly && e.catKey){
        ensureCategory(e.catKey);
        totals[e.catKey] = (totals[e.catKey]||0) + (e.points||0);
        continue;
      }
      const q = findCatalogQuestByName(e.quest);
      if(q && q.category){
        ensureCategory(q.category);
        totals[q.category] = (totals[q.category]||0) + (e.points||0);
      }
    }
    return totals;
  }

  // ---------- Nach-Logik nach addLog (Negativ & Links) ----------
  // Wir h√§ngen uns GANZ am Ende der vorhandenen addLog-Kaskade ein.
  const __oldAddLog_cat = addLog;
  addLog = function(){
    const before = state.log.length;
    __oldAddLog_cat(); // hier passiert die ganze bisherige Berechnung (Perks, Events, ‚Ä¶)

    // nur reagieren, wenn GENAU EIN neuer Eintrag hinzugekommen ist
    const after = state.log.length;
    if(after !== before+1) return;

    const last = state.log[after-1];
    if(!last || last.penalty || last.categoryOnly) return; // unsere Hilfseintr√§ge ignorieren

    const q = findCatalogQuestByName(last.quest);
    if(!q || !q.category){ save(); renderAll(); return; }

    const cat = getCatByKey(q.category);
    // --- NEGATIVE Kategorie: Kategorie-Plus, aber globaler Abzug ---
    if(cat && cat.negative){
      const base = Math.max(1, Number(last.base||Math.abs(last.points)||0));
      const catPoints = base; // Punkte f√ºrs Kategorie-Plus
      const mult = Number(cat.penaltyMultiplier||2);
      const penalty = Math.round(catPoints * mult);

      // Den urspr√ºnglichen Eintrag in Kategorie-Only umwandeln (damit global nicht z√§hlt)
      last.categoryOnly = true;
      last.catKey = cat.key;
      last.points = catPoints; // sicherstellen, dass Kategorie-Plus positiv ist
      last.quest = `[Kategorie ${labelOf(cat.key)}] ${normalizeQuestName(last.quest)}`;

      // separaten Straf-Eintrag anh√§ngen (globaler Effekt)
      state.log.push({
        date: todayISO(),
        quest: `Negativ (${labelOf(cat.key)}): ${normalizeQuestName(last.quest)}`,
        points: -penalty,
        penalty: true
      });
    }

    // --- KATEGORIE-LINKS (nicht global): z. B. Handwerk ‚Üí Sport +5 Kategorie-Punkte ---
    // Nur ausl√∂sen, wenn die Ursprungs-Quest NICHT aus einer Kategorie-Only Aktion stammt.
    const links = (state.categoryLinks||[]).filter(l=>l.from===q.category);
    if(links.length){
      links.forEach(l=>{
        if(!l.to || !l.bonus) return;
        ensureCategory(l.to);
        state.log.push({
          date: todayISO(),
          quest: `Kategorie-Link ${labelOf(l.from)} ‚Üí ${labelOf(l.to)}`,
          points: Number(l.bonus)||0,
          categoryOnly: true,
          catKey: l.to
        });
      });
    }

    save(); renderAll();
  };

  // ---------- Dashboard-Karte: Kategorien-Summen ----------
  function renderCategorySummaryCard(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;
    const totals = computeCategoryTotals();

    const box = document.createElement("div");
    box.className = "mt-4 p-3 border rounded bg-white";
    box.innerHTML = `<h3 class="font-bold">Kategorien</h3>
      <div id="catSummaryList" class="mt-2 space-y-1"></div>`;
    const list = box.querySelector("#catSummaryList");

    state.categories.forEach(c=>{
      const val = (totals[c.key]||0);
      const badge = c.negative ? "text-red-600" : "text-slate-600";
      list.innerHTML += `
        <div class="flex justify-between text-sm">
          <span>${c.negative?'üö´':''} ${c.label}</span>
          <span class="${badge}">${val}</span>
        </div>`;
    });

    host.appendChild(box);
  }

  const __oldRenderDashboard_cat = renderDashboard;
  renderDashboard = function(){
    __oldRenderDashboard_cat();
    renderCategorySummaryCard();
  };

  // ---------- Katalog-UI erweitern: Kategorie-Auswahl, Manager & Links ----------
  function renderCatalogCategoryEnhancements(){
    const container = document.getElementById("catalogList");
    if(!container) return;

    // Eigene Liste rendern (wir √ºberschreiben das von vorher)
    container.innerHTML = state.catalog.map((q,i)=>{
      const opts = state.categories.map(c=>`<option value="${c.key}" ${q.category===c.key?'selected':''}>
          ${c.label}${c.negative?' (negativ)':''}
        </option>`).join("");
      return `
        <div class="p-2 border rounded mb-2 bg-white">
          <div class="flex items-center justify-between gap-2">
            <div class="min-w-0">
              <div class="font-medium truncate">${q.boss?'üëë ':''}${q.name}</div>
              <div class="text-xs text-slate-500">+${q.points} Punkte</div>
            </div>
            <div class="flex items-center gap-2">
              <select class="input text-sm" data-cat="${i}">${opts}</select>
              <button class="btn text-red-600 text-sm" data-del="${i}">L√∂schen</button>
            </div>
          </div>
        </div>
      `;
    }).join("");

    // Events: Kategorie √§ndern & l√∂schen
    container.querySelectorAll("[data-cat]").forEach(sel=>{
      sel.addEventListener("change",()=>{
        const idx = Number(sel.getAttribute("data-cat"));
        state.catalog[idx].category = sel.value;
        save(); renderAll();
      });
    });
    container.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        state.catalog.splice(Number(btn.getAttribute("data-del")),1);
        save(); renderAll();
      });
    });

    // Kategorie-Manager + Links
    const manager = document.createElement("div");
    manager.className = "mt-3 p-3 border rounded bg-slate-50";
    manager.innerHTML = `
      <h4 class="font-bold">Kategorien verwalten</h4>
      <div id="catsEdit" class="space-y-2 mt-2"></div>
      <div class="flex flex-wrap items-end gap-2 mt-2">
        <input id="catNewLabel" class="input" placeholder="Neue Kategorie (Label)" />
        <label class="text-sm flex items-center gap-1">
          <input id="catNewNeg" type="checkbox" /> negativ
        </label>
        <input id="catNewMult" type="number" class="input w-28" step="0.1" value="2" title="Straf-Faktor f√ºr negative Kategorie" />
        <button id="btnAddCat" class="btn">+ Kategorie</button>
      </div>

      <h4 class="font-bold mt-4">Kategorie-Links</h4>
      <div id="catLinksEdit" class="space-y-2 mt-2"></div>
      <div class="flex flex-wrap items-end gap-2 mt-2">
        <select id="linkFrom" class="input">
          ${state.categories.map(c=>`<option value="${c.key}">${c.label}</option>`).join("")}
        </select>
        <span>‚Üí</span>
        <select id="linkTo" class="input">
          ${state.categories.map(c=>`<option value="${c.key}">${c.label}</option>`).join("")}
        </select>
        <input id="linkBonus" type="number" class="input w-24" value="5" step="1" />
        <button id="btnAddLink" class="btn">+ Link</button>
      </div>
    `;
    container.appendChild(manager);

    function renderCatsEdit(){
      const host = manager.querySelector("#catsEdit");
      host.innerHTML = state.categories.map((c,i)=>{
        return `
          <div class="grid grid-cols-12 gap-2 items-center">
            <input class="input col-span-4" data-clabel="${i}" value="${c.label}" />
            <span class="col-span-3 text-xs truncate">${c.key}</span>
            <label class="text-sm col-span-2 flex items-center gap-1">
              <input type="checkbox" data-cneg="${i}" ${c.negative?'checked':''}/> negativ
            </label>
            <input type="number" step="0.1" class="input col-span-2" data-cmult="${i}" value="${c.penaltyMultiplier||2}" ${c.negative?'':'disabled'} />
            <button class="btn text-red-600 col-span-1" data-cdel="${i}">üóë</button>
          </div>
        `;
      }).join("");

      // Handlers
      host.querySelectorAll("[data-clabel]").forEach(inp=>{
        inp.addEventListener("change",()=>{
          const i = Number(inp.getAttribute("data-clabel"));
          state.categories[i].label = inp.value.trim()||state.categories[i].key;
          save(); renderAll();
        });
      });
      host.querySelectorAll("[data-cneg]").forEach(ch=>{
        ch.addEventListener("change",()=>{
          const i = Number(ch.getAttribute("data-cneg"));
          state.categories[i].negative = ch.checked;
          if(ch.checked && typeof state.categories[i].penaltyMultiplier!=="number"){
            state.categories[i].penaltyMultiplier = 2;
          }
          save(); renderAll();
        });
      });
      host.querySelectorAll("[data-cmult]").forEach(inp=>{
        inp.addEventListener("change",()=>{
          const i = Number(inp.getAttribute("data-cmult"));
          const v = Number(inp.value||2);
          state.categories[i].penaltyMultiplier = v;
          save();
        });
      });
      host.querySelectorAll("[data-cdel]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i = Number(btn.getAttribute("data-cdel"));
          const key = state.categories[i].key;
          if(!confirm(`Kategorie "${state.categories[i].label}" l√∂schen?`)) return;
          // Quests, die diese Kategorie nutzen, zur√ºck auf "Allgemein"
          state.catalog.forEach(q=>{ if(q.category===key) q.category="Allgemein"; });
          state.categories.splice(i,1);
          save(); renderAll();
        });
      });
    }

    function renderLinksEdit(){
      const host = manager.querySelector("#catLinksEdit");
      host.innerHTML = (state.categoryLinks||[]).map((l,i)=>{
        return `
          <div class="grid grid-cols-12 gap-2 items-center">
            <div class="col-span-8 text-sm">${labelOf(l.from)} ‚Üí ${labelOf(l.to)}</div>
            <div class="col-span-3 text-sm">Bonus: ${l.bonus}</div>
            <button class="btn text-red-600 col-span-1" data-ldel="${i}">üóë</button>
          </div>
        `;
      }).join("");

      host.querySelectorAll("[data-ldel]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i = Number(btn.getAttribute("data-ldel"));
          state.categoryLinks.splice(i,1);
          save(); renderAll();
        });
      });
    }

    // Add Category
    manager.querySelector("#btnAddCat").addEventListener("click",()=>{
      const label = manager.querySelector("#catNewLabel").value.trim();
      const neg   = manager.querySelector("#catNewNeg").checked;
      const mult  = Number(manager.querySelector("#catNewMult").value||2);
      if(!label) return;
      const key = label; // key = Label (einfach)
      ensureCategory(key,label,neg,mult);
      manager.querySelector("#catNewLabel").value="";
      manager.querySelector("#catNewNeg").checked=false;
      manager.querySelector("#catNewMult").value="2";
      save(); renderAll();
    });

    // Add Link
    manager.querySelector("#btnAddLink").addEventListener("click",()=>{
      const from = manager.querySelector("#linkFrom").value;
      const to   = manager.querySelector("#linkTo").value;
      const bonus= Number(manager.querySelector("#linkBonus").value||0);
      if(!from || !to || !bonus) return;
      state.categoryLinks.push({from,to,bonus});
      save(); renderAll();
    });

    renderCatsEdit();
    renderLinksEdit();
  }

  const __oldRenderCatalog_cat = renderCatalog;
  renderCatalog = function(){
    __oldRenderCatalog_cat();
    renderCatalogCategoryEnhancements();
  };

  save();
})();
</script>
<script>
// ====================== AUTO-MEILENSTEINE (Quests, Missionen, Bossquests, Kategorien) ======================
(function(){

  // ---- State + Migration ------------------------------------------------------------------
  state.ms = state.ms || {
    // F√ºr jeden Track merken wir, welche Schwellen (z.B. "100","200",...) schon belohnt wurden
    achieved: { quests:{}, missions:{}, boss:{}, cat:{} }
  };

  // ---- Schwellen-Generator (1-2-5 Serie, endlos erweiterbar) -------------------------------
  function genThresholds(base, rounds=9){ // rounds: wie viele 1-2-5-Bl√∂cke (je Block *10)
    const seq=[1,2,5];
    const out=[];
    let mul=1;
    for(let r=0;r<rounds;r++){
      for(const s of seq){ out.push(base*s*mul); }
      mul*=10;
    }
    return out;
  }

  // Quests: 100,200,500,1000,2000,5000,‚Ä¶ (Belohnung passt exakt zu deinem Beispiel)
  const MS_QUEST_THRESH = genThresholds(100,8);      // bis sehr gro√ü
  const MS_MISSION_THRESH = genThresholds(10,8);     // 10,20,50,100,‚Ä¶
  const MS_BOSS_THRESH = genThresholds(10,8);        // 10,20,50,100,‚Ä¶
  const MS_CAT_THRESH = genThresholds(100,8);        // je Kategorie

  // ---- Reward-Formeln (so passen die Beispiele exakt) -------------------------------------
  // Quests-Beispiel: 100‚Üí100, 200‚Üí400, 500‚Üí2500  => (threshold/100)^2 * 100
  const rewardQuests = (thr)=> Math.round(Math.pow(thr/100,2)*100);
  // Missionen/Boss: 10‚Üí100, 20‚Üí400, 50‚Üí2500      => (threshold/10)^2 * 100
  const rewardMissions = (thr)=> Math.round(Math.pow(thr/10,2)*100);
  const rewardBoss     = (thr)=> Math.round(Math.pow(thr/10,2)*100);
  // Kategorien (Punkte in Kategorie): analog zu Quests
  const rewardCategory = (thr)=> Math.round(Math.pow(thr/100,2)*100);

  // ---- Helpers: Daten z√§hlen ---------------------------------------------------------------
  function normalizeQuestName(name){
    if(!name) return "";
    return name
      .replace(/^\s*Timed Quest:\s*/i,"")
      .replace(/\s*\(Event Bonus\)\s*$/i,"")
      .trim();
  }
  function findCatalogQuestByName(name){
    const n=normalizeQuestName(name).toLowerCase();
    let q=state.catalog?.find(q=>q.name.toLowerCase()===n);
    if(q) return q;
    return state.catalog?.find(q=>n.includes(q.name.toLowerCase()))||null;
  }

  // ‚Äûechter‚Äú Quest-Eintrag? (kein Penalty, kein KategorieOnly, kein System-Eintrag)
  function isQuestEntry(e){
    if(!e) return false;
    if(e.penalty || e.categoryOnly) return false;
    if(typeof e.points!=="number" || e.points<=0) return false;
    const sys = [
      "Reward eingel√∂st","Reward-Kauf","Event-Bonus","Milestone","Meilenstein",
      "Negativ (","Kategorie-Link","Tagesziel Bonus","Daily Challenge" // kannst du hier nach Wunsch rausnehmen
    ];
    return !sys.some(p=>String(e.quest||"").startsWith(p));
  }

  // Z√§hle ‚Äûnormale‚Äú Quests (inkl. Boss, inkl. Mission-Schritte ‚Äì solange sie wie Quests geloggt werden)
  function countQuests(){
    return state.log.filter(isQuestEntry).length;
  }

  // Z√§hle Bossquests: Eintr√§ge, die zu einer Katalog-Quest mit boss=true geh√∂ren
  function countBossQuests(){
    let c=0;
    for(const e of state.log){
      if(!isQuestEntry(e)) continue;
      const q=findCatalogQuestByName(e.quest);
      if(q && q.boss) c++;
    }
    return c;
  }

  // Missionen abgeschlossen: Erkennen wir √ºber markierte Logs oder Text-Marker
  // (Falls dein Missionssystem Logs wie ‚ÄûMission abgeschlossen:‚Äú schreibt, wird es gez√§hlt.
  //  Sonst bleibt es 0 und schadet nicht.)
  function countMissionsDone(){
    return state.log.filter(e=>
      !e.penalty && /mission (abgeschlossen|complete)/i.test(String(e.quest||""))
    ).length;
  }

  // Kategorie-Summen (Punkte je Kategorie) ‚Äî nutzt die Funktion aus dem Kategorien-Baustein, falls vorhanden.
  function computeCategoryTotals(){
    // Falls der Kategorien-Baustein noch nicht eingef√ºgt wurde, liefern wir leere Summen:
    if(typeof window.computeCategoryTotals === "function") return window.computeCategoryTotals();
    const totals={};
    (state.categories||[{key:"Allgemein",label:"Allgemein"}]).forEach(c=>totals[c.key]=0);
    for(const e of state.log){
      if(e.penalty) continue;
      if(e.categoryOnly && e.catKey){
        totals[e.catKey]=(totals[e.catKey]||0)+(e.points||0);
        continue;
      }
      const q=findCatalogQuestByName(e.quest);
      if(q && q.category) totals[q.category]=(totals[q.category]||0)+(e.points||0);
    }
    return totals;
  }

  // ---- Meilenstein-Pr√ºfung + Belohnung ausgeben -------------------------------------------
  function award(label, points){
    state.log.push({date: todayISO(), quest:`Meilenstein: ${label}`, points});
    save();
  }

  function checkTrack(currentValue, thresholds, achievedMap, labelFn, rewardFn){
    // Finde alle THR, die ‚â§ currentValue und noch nicht vergeben sind ‚Üí nacheinander belohnen
    let awarded=false;
    for(const thr of thresholds){
      const key=String(thr);
      if(currentValue>=thr && !achievedMap[key]){
        achievedMap[key]=true;
        award(labelFn(thr), rewardFn(thr));
        awarded=true;
      }
    }
    return awarded;
  }

  function checkAutoMilestones(){
    let somethingAwarded=false;

    // Quests gesamt
    const qCount = countQuests();
    if(checkTrack(qCount, MS_QUEST_THRESH, state.ms.achieved.quests,
      (thr)=>`Quests gesamt ${thr}`,
      rewardQuests)) somethingAwarded=true;

    // Missionen abgeschlossen
    const mCount = countMissionsDone();
    if(checkTrack(mCount, MS_MISSION_THRESH, state.ms.achieved.missions,
      (thr)=>`Missionen abgeschlossen ${thr}`,
      rewardMissions)) somethingAwarded=true;

    // Bossquests
    const bCount = countBossQuests();
    if(checkTrack(bCount, MS_BOSS_THRESH, state.ms.achieved.boss,
      (thr)=>`Bossquests erledigt ${thr}`,
      rewardBoss)) somethingAwarded=true;

    // Kategorien (jede Kategorie separat)
    const totals = computeCategoryTotals();
    state.categories = state.categories || [{key:"Allgemein",label:"Allgemein"}];
    // Map je Kategorie initialisieren
    state.ms.achieved.cat = state.ms.achieved.cat || {};
    for(const c of state.categories){
      state.ms.achieved.cat[c.key] = state.ms.achieved.cat[c.key] || {};
      const cur = totals[c.key]||0;
      if(checkTrack(cur, MS_CAT_THRESH, state.ms.achieved.cat[c.key],
        (thr)=>`Kategorie ${c.label} ${thr}`,
        rewardCategory)) somethingAwarded=true;
    }

    if(somethingAwarded){
      save();
      // Kein addLog()-Re-Entry; wir rendern nur neu
      if(typeof renderAll==="function") renderAll();
    }
  }

  // ---- Dashboard-Card (√úbersicht + n√§chste Ziele) -----------------------------------------
  function nextTarget(current, thresholds){
    for(const thr of thresholds){ if(current<thr) return thr; }
    return null;
  }
  function rewardPreview(fn, thr){ return (thr==null? "-" : `+${fn(thr)}`); }

  function renderMilestonesCard(){
    const host=document.getElementById("tab-dashboard");
    if(!host) return;

    const qCount = countQuests();
    const mCount = countMissionsDone();
    const bCount = countBossQuests();
    const totals = computeCategoryTotals();

    const qNext = nextTarget(qCount, MS_QUEST_THRESH);
    const mNext = nextTarget(mCount, MS_MISSION_THRESH);
    const bNext = nextTarget(bCount, MS_BOSS_THRESH);

    const box=document.createElement("div");
    box.className="mt-4 p-3 border rounded bg-white";
    box.innerHTML = `
      <h3 class="font-bold">Meilensteine (automatisch)</h3>
      <div class="mt-2 space-y-1 text-sm">
        <div class="flex justify-between"><span>Quests gesamt</span><span>${qCount} / ${qNext??"‚àû"} ${qNext?`(${rewardPreview(rewardQuests,qNext)})`:""}</span></div>
        <div class="flex justify-between"><span>Missionen abgeschlossen</span><span>${mCount} / ${mNext??"‚àû"} ${mNext?`(${rewardPreview(rewardMissions,mNext)})`:""}</span></div>
        <div class="flex justify-between"><span>Bossquests</span><span>${bCount} / ${bNext??"‚àû"} ${bNext?`(${rewardPreview(rewardBoss,bNext)})`:""}</span></div>
      </div>
      <div class="mt-3">
        <div class="font-semibold text-sm mb-1">Kategorien</div>
        <div id="msCats" class="space-y-1 text-sm"></div>
      </div>
    `;
    const catsBox=box.querySelector("#msCats");
    (state.categories||[{key:"Allgemein",label:"Allgemein"}]).forEach(c=>{
      const cur = totals[c.key]||0;
      const nxt = nextTarget(cur, MS_CAT_THRESH);
      const line = document.createElement("div");
      line.className="flex justify-between";
      line.innerHTML = `<span>${c.negative?'üö´':''} ${c.label}</span><span>${cur} / ${nxt??"‚àû"} ${nxt?`(${rewardPreview(rewardCategory,nxt)})`:""}</span>`;
      catsBox.appendChild(line);
    });

    host.appendChild(box);
  }

  // ---- Hooks: nach jedem AddLog pr√ºfen; beim Render anzeigen -------------------------------
  const __oldAddLog_MS = addLog;
  addLog = function(){
    __oldAddLog_MS();
    // Nach allen anderen Effekten pr√ºfen
    checkAutoMilestones();
  };

  const __oldRenderDashboard_MS = renderDashboard;
  renderDashboard = function(){
    __oldRenderDashboard_MS();
    // Beim Rendern auch einmal pr√ºfen (falls Import etc.)
    checkAutoMilestones();
    renderMilestonesCard();
  };

  // Initial
  checkAutoMilestones();

})();
</script>
<script>
// ====================== PER-QUEST LEVELSYSTEM (inkl. t√§glichem -15 Penalty) ======================
(function(){

  // ---------- State & Migration ----------
  state.questXP = state.questXP || {}; // { "<questName>": { xp, lastCheck, lastDone } }

  function todayISO(){ return new Date().toISOString().slice(0,10); }
  function isoToDate(iso){ const d=new Date(iso); d.setHours(0,0,0,0); return d; }
  function daysDiff(d1Iso,d2Iso){ // full days d2 - d1
    const a=isoToDate(d1Iso), b=isoToDate(d2Iso);
    return Math.round((b-a)/(1000*60*60*24));
  }

  function normalizeQuestName(name){
    if(!name) return "";
    return String(name)
      .replace(/^\s*Timed Quest:\s*/i,"")
      .replace(/\s*\(Event Bonus\)\s*$/i,"")
      .trim();
  }

  function findCatalogQuestByName(name){
    const n=normalizeQuestName(name).toLowerCase();
    let q=state.catalog?.find(q=>q.name.toLowerCase()===n);
    if(q) return q;
    return state.catalog?.find(q=>n.includes(q.name.toLowerCase()))||null;
  }

  function getBasePointsForEntry(e){
    // Basis-Punkte f√ºr Quest-XP (nicht der Multiplier): bevorzugt e.base, sonst Katalog, sonst positive points
    const q=findCatalogQuestByName(e.quest);
    return typeof e.base==="number" && e.base>0 ? e.base
         : (q && q.points>0 ? q.points
         : Math.max(0, Number(e.points||0)));
  }

  // Level-Logik: Level 1 bei 100 XP, Level 2 nach +110, Level 3 nach +120, ...
  function xpToLevel(xp){
    let lvl=0;
    let need=100;
    let rem=xp;
    while(rem>=need){
      rem-=need;
      lvl++;
      need=100+10*lvl; // n√§chste Stufe wird 10 h√∂her
    }
    return { level:lvl, progress:rem, need }; // need = XP bis n√§chste Stufe
  }

  function ensureQuestRecord(name){
    const key=normalizeQuestName(name);
    if(!key) return null;
    if(!state.questXP[key]){
      // Initial aus History summieren
      let xp=0, last=null;
      state.log.forEach(e=>{
        if(normalizeQuestName(e.quest).toLowerCase()===key.toLowerCase()){
          xp += getBasePointsForEntry(e);
          last = e.date; // letzter Treffer gewinnt
        }
      });
      state.questXP[key]={ xp:Math.max(0,Math.round(xp)), lastDone:last||"", lastCheck: todayISO() };
    }
    return state.questXP[key];
  }

  // ---------- Penalties pro Tag ohne Erf√ºllung ----------
  function questDatesSet(name){
    const key=normalizeQuestName(name).toLowerCase();
    const set=new Set();
    state.log.forEach(e=>{
      if(normalizeQuestName(e.quest).toLowerCase()===key){
        set.add(e.date);
      }
    });
    return set;
  }

  function applyDailyPenalties(){
    const t = todayISO();
    for(const name of Object.keys(state.questXP)){
      const rec = state.questXP[name];
      const lastCheck = rec.lastCheck || t;
      if(lastCheck===t) continue;
      const missingDates = [];
      const had = questDatesSet(name);
      let d = isoToDate(lastCheck);
      d.setDate(d.getDate()+1); // Tag nach letztem Check starten
      const end = isoToDate(t);
      while(d<end){
        const iso=d.toISOString().slice(0,10);
        if(!had.has(iso)) missingDates.push(iso);
        d.setDate(d.getDate()+1);
      }
      if(missingDates.length>0){
        rec.xp = Math.max(0, rec.xp - 15*missingDates.length);
      }
      rec.lastCheck = t;
    }
    save();
  }

  // ---------- Hook: nach jedem Log XP gutschreiben ----------
  const __oldAddLog_QL = addLog;
  addLog = function(){
    const beforeLen = state.log.length;
    __oldAddLog_QL();
    const afterLen = state.log.length;
    if(afterLen>beforeLen){
      const last = state.log[afterLen-1];
      if(last && last.quest){
        const key = normalizeQuestName(last.quest);
        const rec = ensureQuestRecord(key);
        if(rec){
          const base = getBasePointsForEntry(last);
          rec.xp = Math.max(0, rec.xp + base);
          rec.lastDone = last.date;
          rec.lastCheck = last.date; // heute erledigt -> heute keine Penalty
          save();
        }
      }
    }
    // Nach jedem Log auch Penalties f√ºr andere Quests des Tages nachziehen (falls n√∂tig)
    applyDailyPenalties();
  };

  // ---------- Katalog-UI: Level-Anzeige je Quest ----------
  function injectLevelsIntoCatalogList(){
    const list = document.getElementById("catalogList");
    if(!list) return;
    const rows = Array.from(list.querySelectorAll(".p-2.border.rounded"));
    rows.forEach((row, i)=>{
      const q = state.catalog[i];
      if(!q) return;
      const key = normalizeQuestName(q.name);
      const rec = ensureQuestRecord(key);
      const {level,progress,need} = xpToLevel(rec?.xp||0);
      // Kleines HUD unter dem Namen
      let holder = row.querySelector("[data-ql-hud]");
      if(!holder){
        holder = document.createElement("div");
        holder.setAttribute("data-ql-hud","1");
        holder.className="mt-1 text-xs text-slate-600 w-full";
        // versuche unter das erste <span> zu h√§ngen
        const left = row.querySelector("span");
        (left || row).appendChild(holder);
      }
      const pct = Math.max(0, Math.min(100, Math.round((progress/need)*100)));
      holder.innerHTML = `
        <div class="flex items-center gap-2 mt-1">
          <span>Lvl ${level}</span>
          <div class="flex-1 max-w-[160px]">
            <div class="w-full bg-gray-200 h-2 rounded overflow-hidden">
              <div class="bg-blue-500 h-2" style="width:${pct}%"></div>
            </div>
          </div>
          <span>${progress}/${need}</span>
        </div>
      `;
    });
  }

  const __oldRenderCatalog_QL = renderCatalog;
  renderCatalog = function(){
    __oldRenderCatalog_QL();
    // Nach dem Standard-Render: Timed-Button wird ggf. drangeh√§ngt ‚Äì wir injizieren danach
    injectLevelsIntoCatalogList();
  };

  // ---------- Dashboard-Widget: Top-Quests nach Level ----------
  function renderQuestLevelDashboard(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;
    const box = document.createElement("div");
    box.className="mt-4 p-3 border rounded bg-white";
    box.innerHTML = `<h3 class="font-bold">Quest-Levels</h3><div id="qlTop" class="mt-2 space-y-1 text-sm"></div>`;
    const list = box.querySelector("#qlTop");

    // Liste bauen
    const entries = Object.keys(state.questXP).map(name=>{
      const rec=state.questXP[name];
      const xp = rec?.xp||0;
      const lv = xpToLevel(xp);
      return {name, xp, level: lv.level, progress: lv.progress, need: lv.need};
    }).sort((a,b)=> b.level===a.level ? b.xp-a.xp : b.level-a.level).slice(0,5);

    if(entries.length===0){
      list.innerHTML = `<div class="text-slate-500">Noch keine Quest-Level vorhanden.</div>`;
    }else{
      entries.forEach(e=>{
        const pct = Math.max(0, Math.min(100, Math.round((e.progress/e.need)*100)));
        const row = document.createElement("div");
        row.innerHTML = `
          <div class="flex items-center gap-2">
            <div class="flex-1 truncate">${e.name}</div>
            <div class="text-xs">Lvl ${e.level}</div>
          </div>
          <div class="w-full bg-gray-200 h-2 rounded overflow-hidden mt-1">
            <div class="bg-blue-500 h-2" style="width:${pct}%"></div>
          </div>
          <div class="text-[11px] text-slate-500">${e.progress}/${e.need} XP</div>
        `;
        row.className="p-2 rounded hover:bg-gray-50";
        list.appendChild(row);
      });
    }

    host.appendChild(box);
  }

  const __oldRenderDashboard_QL = renderDashboard;
  renderDashboard = function(){
    // vor dem normalen Render: Penalties einmal pro Tag anwenden
    applyDailyPenalties();
    __oldRenderDashboard_QL();
    renderQuestLevelDashboard();
  };

  // ---------- Initial ----------
  // Migration: sorge daf√ºr, dass es Records f√ºr alle im Katalog existenten Quests gibt
  (state.catalog||[]).forEach(q=>ensureQuestRecord(q.name));
  // Einmalige Tages-Penalties beim Laden
  applyDailyPenalties();

})(); 
</script>
// ====================== MISSIONEN (Schritt-f√ºr-Schritt, Branches, 4√ó Bonus) ======================
(function(){

  // ---------- State ----------
  state.missions = state.missions || []; // [{id,name,steps:[{id,title,points,dependsOn:[],group,done,skipped,unlocked,doneDate}],completed,completionDate}]

  const T = ()=>new Date().toISOString().slice(0,10);
  const uid = (p='msn_') => p+Math.random().toString(36).slice(2,9);

  // Hilfen
  function byId(id){ return document.getElementById(id); }
  function normName(s){ return (s||'').trim(); }

  // Step-Freischaltung berechnen
  function recomputeUnlocks(msn){
    const doneSet = new Set(msn.steps.filter(s=>s.done).map(s=>s.id));
    msn.steps.forEach(s=>{
      if(s.done || s.skipped){ s.unlocked=false; return; }
      const deps = s.dependsOn || [];
      s.unlocked = deps.every(d=>doneSet.has(d));
    });
  }

  // Mission fertig?
  function missionCompleted(msn){
    return msn.steps.every(s=>s.done || s.skipped);
  }

  // 4√ó Abschlussbonus (Summe der erledigten Schrittpunkte √ó4)
  function awardMissionBonus(msn){
    const sum = msn.steps.filter(s=>s.done).reduce((a,b)=>a+(Number(b.points)||0),0);
    const bonus = sum*4;
    state.log.push({date:T(), quest:"Mission abgeschlossen: "+msn.name, points:bonus});
    save();
  }

  // Einen Schritt als erledigt markieren (inkl. Branch-Exklusivit√§t)
  function completeStep(msnId, stepId, viaLog=true){
    const msn = state.missions.find(m=>m.id===msnId);
    if(!msn) return;
    const step = msn.steps.find(s=>s.id===stepId);
    if(!step || step.done || step.skipped) return;

    // Wenn noch nicht freigeschaltet, nur Hinweis ‚Äì Schritt bleibt zu.
    recomputeUnlocks(msn);
    if(!step.unlocked){
      toast("üîí Schritt '"+step.title+"' ist noch gesperrt.");
      return;
    }

    // Optional: automatisch loggen (damit Multiplier/Events/Perks greifen)
    if(viaLog){
      // Stelle sicher, dass es den Quest im Katalog gibt (damit select/Log UI klappt)
      ensureCatalogQuest(step.title, step.points);
      safeLog(step.title, step.points);
    }

    // Schritt abschlie√üen
    step.done = true;
    step.doneDate = T();

    // Branch-Exklusivit√§t: alle anderen Schritte mit gleicher group ‚Äûskippen‚Äú
    if(step.group){
      msn.steps.forEach(s=>{
        if(!s.done && !s.skipped && s.group===step.group && s.id!==step.id){
          s.skipped = true;
        }
      });
    }

    // Freischaltungen aktualisieren
    recomputeUnlocks(msn);

    // Mission evtl. abschlie√üen + Bonus
    if(!msn.completed && missionCompleted(msn)){
      msn.completed = true;
      msn.completionDate = T();
      awardMissionBonus(msn);
      toast("üéâ Mission abgeschlossen: "+msn.name+" (+ Bonus)");
    }

    save(); renderAll();
  }

  // Katalog-Quest sicherstellen (damit Log-Select die Mission-Schritte enth√§lt)
  function ensureCatalogQuest(name, points){
    if(!state.catalog) state.catalog=[];
    const exists = state.catalog.some(q=>q.name.toLowerCase()===name.toLowerCase());
    if(!exists){
      state.catalog.push({name, points: Number(points)||0});
    }
  }

  // √úber das bestehende addLog-Pipeline sauber eintragen
  function safeLog(qName, basePoints){
    const d = T();
    const dateEl = byId("logDate");
    const qEl = byId("logQuest");
    const pEl = byId("logPoints");
    const mEl = byId("logMalus");

    if(dateEl) dateEl.value = d;
    if(qEl){
      // select oder input?
      if(qEl.tagName==="SELECT"){
        // Option sicherstellen
        let opt = Array.from(qEl.options).find(o=>o.value===qName || o.text===qName);
        if(!opt){
          const o = document.createElement("option"); o.value=qName; o.text=qName; qEl.appendChild(o);
        }
        qEl.value = qName;
      }else{
        qEl.value = qName;
      }
    }
    if(pEl) pEl.value = Number(basePoints)||0;
    if(mEl) mEl.value = 0;

    // vorhandenes addLog() benutzen (damit alle Hooks/Sounds/Events greifen)
    try{ addLog(); }catch(e){ 
      // Fallback: direkte Buchung (nur falls addLog ausf√§llt)
      const pts = computePoints(Number(basePoints)||0, d);
      state.log.push({date:d, quest:qName, points:pts, base:Number(basePoints)||0});
      save(); renderAll();
    }
  }

  // Kleiner Toast
  function toast(msg){
    const t=document.createElement("div");
    t.textContent=msg;
    t.className="fixed bottom-24 left-1/2 -translate-x-1/2 bg-black text-white text-sm px-3 py-2 rounded shadow";
    document.body.appendChild(t);
    setTimeout(()=>t.remove(),1800);
  }

  // ---------- Editor im Katalog ----------
  function renderMissionsEditor(){
    const host = document.querySelector("#tab-catalog");
    if(!host) return;

    // Container erzeugen/erneuern
    let box = byId("missionsEditor");
    if(!box){
      box = document.createElement("div");
      box.id = "missionsEditor";
      box.className = "mt-6 p-3 border rounded bg-white";
      host.appendChild(box);
    }

    // Inhalt
    box.innerHTML = `
      <h3 class="font-bold">Missionen</h3>
      <div class="flex flex-wrap gap-2 mt-2">
        <button id="btnNewMission" class="btn">+ Mission</button>
        <button id="btnImportMission" class="btn">Import (JSON)</button>
        <button id="btnExportMission" class="btn">Export (JSON)</button>
      </div>
      <div id="missionsList" class="mt-3 space-y-2"></div>
    `;

    byId("btnNewMission").addEventListener("click", newMissionWizard);
    byId("btnImportMission").addEventListener("click", importMissionJSON);
    byId("btnExportMission").addEventListener("click", exportMissionJSON);

    // Liste rendern
    const list = byId("missionsList");
    if(state.missions.length===0){
      list.innerHTML = `<div class="text-sm text-slate-500">Noch keine Missionen. Lege eine neue an.</div>`;
    }else{
      list.innerHTML = state.missions.map(msn=>{
        const total = msn.steps.length;
        const done = msn.steps.filter(s=>s.done).length;
        const pct = Math.round((done/Math.max(1,total))*100);
        return `
          <div class="p-2 border rounded">
            <div class="flex items-center justify-between gap-2">
              <div class="font-medium">${msn.name}</div>
              <div class="text-xs ${msn.completed?'text-green-700':'text-slate-600'}">
                ${msn.completed ? 'Abgeschlossen am '+(msn.completionDate||'') : done+'/'+total+' ('+pct+'%)'}
              </div>
            </div>
            <div class="mt-2 flex flex-wrap gap-2">
              <button class="btn text-xs" data-msn-step-add="${msn.id}">+ Schritt</button>
              <button class="btn text-xs" data-msn-edit="${msn.id}">Bearbeiten</button>
              <button class="btn text-xs" data-msn-del="${msn.id}">L√∂schen</button>
            </div>
            <div class="mt-2 text-xs text-slate-600">
              ${renderMiniSteps(msn)}
            </div>
          </div>
        `;
      }).join("");
    }

    // Aktionen
    list.querySelectorAll("[data-msn-step-add]").forEach(btn=>{
      btn.addEventListener("click", ()=> addStepWizard(btn.getAttribute("data-msn-step-add")));
    });
    list.querySelectorAll("[data-msn-edit]").forEach(btn=>{
      btn.addEventListener("click", ()=> editMission(btn.getAttribute("data-msn-edit")));
    });
    list.querySelectorAll("[data-msn-del]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-msn-del");
        if(confirm("Mission wirklich l√∂schen?")){
          state.missions = state.missions.filter(m=>m.id!==id);
          save(); renderAll();
        }
      });
    });
  }

  function renderMiniSteps(msn){
    const pills = msn.steps.map(s=>{
      const st = s.done ? "bg-green-100 border-green-300" : (s.skipped?"bg-gray-100":"bg-yellow-50");
      return `<span class="inline-block border ${st} px-2 py-[2px] rounded mr-1 mb-1">${s.id}: ${s.title}${s.group?` <span class="opacity-60">(Grp ${s.group})</span>`:""}</span>`;
    }).join("");
    return pills || "<span class='text-slate-400'>Noch keine Schritte.</span>";
  }

  // Wizard: neue Mission
  function newMissionWizard(){
    const name = prompt("Missionsname? (z. B. Wohnzimmer fertig machen)");
    if(!name) return;
    const id = uid();
    const msn = { id, name: normName(name), steps: [], completed:false, completionDate:null };
    state.missions.push(msn);
    save(); renderAll();
    toast("Mission erstellt. F√ºge jetzt Schritte hinzu.");
  }

  // Wizard: Schritt hinzuf√ºgen
  function addStepWizard(msnId){
    const msn = state.missions.find(m=>m.id===msnId);
    if(!msn) return;

    const id = prompt("Schritt-ID (z. B. 1 oder 2.1):");
    if(!id) return;
    const title = prompt("Schritt-Titel (z. B. Leisten anbringen):");
    if(!title) return;
    const points = Number(prompt("Punkte f√ºr diesen Schritt (Basis-Punkte):")||0);
    const deps = (prompt("Abh√§ngigkeiten (kommagetrennt, z. B. 1 oder leer):")||"")
                  .split(",").map(s=>s.trim()).filter(Boolean);
    const group = (prompt("Alternative-Gruppe (z. B. 2 f√ºr 2.0/2.1, sonst leer):")||"").trim()||null;

    msn.steps.push({
      id: id.trim(),
      title: normName(title),
      points: Number(points)||0,
      dependsOn: deps,
      group,
      done:false,
      skipped:false,
      unlocked: deps.length===0,
      doneDate:null
    });

    // Schritt auch als Katalog-Quest sicherstellen
    ensureCatalogQuest(title, points);

    recomputeUnlocks(msn);
    save(); renderAll();
  }

  // Einfache Text-Editierfunktion
  function editMission(msnId){
    const msn = state.missions.find(m=>m.id===msnId);
    if(!msn) return;
    const json = prompt(
      "Mission JSON bearbeiten (vorsichtig!)",
      JSON.stringify(msn, null, 2)
    );
    if(!json) return;
    try{
      const obj = JSON.parse(json);
      // Minimalvalidierung
      if(!obj || !obj.name || !Array.isArray(obj.steps)) throw new Error("Ung√ºltig");
      // Sanitisieren
      obj.id = msn.id;
      obj.steps = obj.steps.map(s=>({
        id: String(s.id),
        title: normName(s.title),
        points: Number(s.points)||0,
        dependsOn: Array.isArray(s.dependsOn)? s.dependsOn.map(String):[],
        group: s.group? String(s.group): null,
        done: !!s.done,
        skipped: !!s.skipped,
        unlocked: !!s.unlocked,
        doneDate: s.doneDate||null
      }));
      state.missions = state.missions.map(m=> m.id===msn.id ? obj : m);
      // Unlocks neu
      const mm = state.missions.find(m=>m.id===msn.id);
      recomputeUnlocks(mm);
      save(); renderAll();
      toast("Mission aktualisiert.");
    }catch(e){
      alert("Fehler beim Parsen. √Ñnderung verworfen.");
    }
  }

  function importMissionJSON(){
    const txt = prompt("F√ºge Mission-JSON ein:");
    if(!txt) return;
    try{
      const obj = JSON.parse(txt);
      if(Array.isArray(obj)){ // mehrere
        obj.forEach(m=>{
          m.id = uid();
          (m.steps||[]).forEach(s=>{
            s.unlocked = (s.dependsOn||[]).length===0;
            ensureCatalogQuest(s.title, s.points);
          });
          state.missions.push(m);
        });
      }else{ // eine
        obj.id = uid();
        (obj.steps||[]).forEach(s=>{
          s.unlocked = (s.dependsOn||[]).length===0;
          ensureCatalogQuest(s.title, s.points);
        });
        state.missions.push(obj);
      }
      save(); renderAll();
      toast("Missionen importiert.");
    }catch(e){
      alert("Ung√ºltiges JSON.");
    }
  }

  function exportMissionJSON(){
    const data = JSON.stringify(state.missions, null, 2);
    const blob = new Blob([data],{type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "missions_backup.json";
    a.click();
  }

  // ---------- Dashboard-Widget ----------
  function renderMissionsDashboard(){
    const host = byId("tab-dashboard");
    if(!host) return;

    // Box
    const box = document.createElement("div");
    box.className="mt-4 p-3 border rounded bg-white";
    box.innerHTML = `<h3 class="font-bold">Missionen</h3>
      <div id="msnListDash" class="mt-2 space-y-2"></div>`;
    host.appendChild(box);

    const target = byId("msnListDash");
    if(state.missions.length===0){
      target.innerHTML = `<div class="text-sm text-slate-500">Noch keine Missionen angelegt.</div>`;
      return;
    }

    // Jede Mission anzeigen + freigeschaltete Schritte als Buttons
    state.missions.forEach(msn=>{
      recomputeUnlocks(msn);
      const total = msn.steps.length;
      const done = msn.steps.filter(s=>s.done).length;
      const pct = Math.round((done/Math.max(1,total))*100);
      const unlocked = msn.steps.filter(s=>!s.done && !s.skipped && s.unlocked);

      const row = document.createElement("div");
      row.className="p-2 border rounded";
      row.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="font-medium">${msn.name}</div>
          <div class="text-xs ${msn.completed?'text-green-700':'text-slate-600'}">
            ${msn.completed ? 'Abgeschlossen' : done+'/'+total+' ('+pct+'%)'}
          </div>
        </div>
        <div class="mt-2">${renderStepButtonsHTML(msn, unlocked)}</div>
      `;
      target.appendChild(row);

      // Click-Handler f√ºr freigeschaltete Schritte
      row.querySelectorAll("[data-msn-do]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const sid = btn.getAttribute("data-msn-do");
          completeStep(msn.id, sid, true);
        });
      });
    });
  }

  function renderStepButtonsHTML(msn, unlockedSteps){
    if(msn.completed) return `<div class="text-sm text-green-700">üéâ Mission abgeschlossen</div>`;
    if(unlockedSteps.length===0) return `<div class="text-sm text-slate-500">Keine Schritte freigeschaltet.</div>`;
    return unlockedSteps.map(s=>{
      const label = `${s.id}: ${s.title} (+${s.points})`;
      return `<button class="btn text-xs mr-2 mb-2" data-msn-do="${s.id}">‚ûï ${label}</button>`;
    }).join("");
  }

  // ---------- Log-Hook: Schritt-Erkennung ----------
  const __oldAddLog_MSN = addLog;
  addLog = function(){
    const before = state.log.length;
    __oldAddLog_MSN();
    const after = state.log.length;
    if(after>before){
      const last = state.log[after-1];
      const qName = normName(last.quest).toLowerCase();

      // Pr√ºfe, ob ein Missions-Schritt damit erledigt wurde
      state.missions.forEach(msn=>{
        let matched = msn.steps.find(s=> normName(s.title).toLowerCase()===qName );
        if(matched && !matched.done && !matched.skipped){
          // Wenn noch nicht freigeschaltet: nur Hinweis, Schritt bleibt gesperrt
          recomputeUnlocks(msn);
          if(!matched.unlocked){
            toast("‚ÑπÔ∏è Schritt '"+matched.title+"' gez√§hlt, bleibt aber gesperrt (Abh√§ngigkeiten).");
          }else{
            completeStep(msn.id, matched.id, false); // false = nicht erneut loggen
          }
        }
      });

      save(); renderAll();
    }
  };

  // ---------- Hooks in bestehende Renderer ----------
  const __oldRenderCatalog_MSN = renderCatalog;
  renderCatalog = function(){
    __oldRenderCatalog_MSN();
    renderMissionsEditor();
  };

  const __oldRenderDashboard_MSN = renderDashboard;
  renderDashboard = function(){
    __oldRenderDashboard_MSN();
    renderMissionsDashboard();
  };

  // ---------- Init ----------
  // Nachladen: Unlocks f√ºr alle Missionen initial berechnen
  state.missions.forEach(recomputeUnlocks);

})();
<!-- ==== QUEST-LEVELSYSTEM PRO QUEST (einfach vor </script> einf√ºgen) ==== -->
<script>
// in IIFE kapseln, damit keine globalen Namen kollidieren
(function(){
  // ---- Migration / State ----
  state.questLevels = state.questLevels || {}; 
  // Struktur je QuestName: { xp:0, lvl:0, next:100, lastDone:null, penaltyUpTo:null, created: 'YYYY-MM-DD' }

  // ---- Utils ----
  const isoToday = typeof todayISO === "function" ? todayISO : () => new Date().toISOString().slice(0,10);
  const addDays = (iso, n) => {
    const d = new Date(iso); d.setDate(d.getDate()+n);
    return d.toISOString().slice(0,10);
  };

  function ensureQL(name){
    if(!state.questLevels[name]){
      state.questLevels[name] = {
        xp: 0, lvl: 0, next: 100,
        lastDone: null,
        penaltyUpTo: isoToday(), // ab heute z√§hlen wir erst k√ºnftig Strafen
        created: isoToday()
      };
    }
    return state.questLevels[name];
  }

  // Level-Up/Down Logik mit steigender Anforderung (+10 je Level)
  function normalizeLevels(q){
    // Up
    while(q.xp >= q.next){
      q.xp -= q.next;
      q.lvl += 1;
      q.next += 10; // jede Stufe +10 mehr
    }
    // Down
    while(q.xp < 0 && q.lvl > 0){
      // zur vorherigen Stufe zur√ºck: vorherige erforderliche XP ist (q.next - 10)
      q.next -= 10;
      q.lvl -= 1;
      q.xp += q.next; // Rest-XP in die vorige Stufe "zur√ºckrollen"
    }
    // Untergrenze
    if(q.lvl === 0 && q.xp < 0){ q.xp = 0; }
  }

  // T√§gliche Strafe: ‚àí15 pro vers√§umtem Tag (je Quest)
  function applyPenaltiesFor(name, upToISO){
    const q = ensureQL(name);
    const today = isoToday();
    // wir z√§hlen Strafen nur bis zum Tag vor 'upToISO' (z.B. bis gestern)
    let cursor = addDays(q.penaltyUpTo || q.created, 1);
    const limit = addDays(upToISO, -1);
    while(cursor <= limit){
      // wenn an 'cursor' NICHT erledigt wurde, Strafe ‚àí15
      if(!(q.lastDone && q.lastDone >= cursor)){ // lastDone ist das j√ºngste Erledigt-Datum
        q.xp -= 15;
        normalizeLevels(q);
      }
      q.penaltyUpTo = cursor;
      cursor = addDays(cursor, 1);
    }
  }

  // XP gutschreiben (nur positive Punkte), inkl. vorher Strafen bis heute anwenden
  function addQuestXP(name, gainedPoints, doneISO){
    if(!name || !gainedPoints || gainedPoints <= 0) return;
    const q = ensureQL(name);
    // vor Gutschrift Strafen bis "heute" einziehen
    applyPenaltiesFor(name, isoToday());
    // XP addieren
    q.xp += Math.round(gainedPoints);
    // Done-Datum aktualisieren (f√ºr die ‚Äûheute erledigt?‚Äú-Logik)
    q.lastDone = doneISO || isoToday();
    normalizeLevels(q);
  }

  // ---- Hook ins addLog (nach dem aktuellen Stand deines Codes) ----
  // Wir h√§ngen uns an die *aktuelle* addLog-Funktion, ohne bestehende Logik zu zerst√∂ren.
  const prevAddLog = typeof addLog === "function" ? addLog : null;
  window.addLog = function(){
    const beforeLen = (state.log||[]).length;
    if(prevAddLog) prevAddLog(); // bestehendes Logging ausf√ºhren
    const afterLen = (state.log||[]).length;
    if(afterLen > beforeLen){
      const last = state.log[afterLen-1];
      // Nur ‚Äûnormale‚Äú Quests z√§hlen f√ºr das Quest-Level (keine System-/Kauf-/Bonus-Eintr√§ge)
      const skip = /reward\-kauf|bonus|event|milestone|tagesziel/i.test(last.quest||"");
      if(!skip){
        const pts = Number(last.points||0);
        if(pts>0){
          addQuestXP(last.quest, pts, last.date);
        }
      }
      save();
      if(typeof renderAll === "function") renderAll();
    }
  };

  // ---- Dashboard-Panel: ‚ÄûQuest-Level √úbersicht‚Äú ----
  function renderQuestLevelPanel(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // Panel-Container verwalten (einmalig erstellen / dann erneuern)
    let box = document.getElementById("questLevelPanel");
    if(!box){
      box = document.createElement("div");
      box.id = "questLevelPanel";
      box.className = "mt-4";
      host.appendChild(box);
    }

    // Daten zusammensetzen: nur Quests aus Katalog, damit die Liste ‚Äûsauber‚Äú bleibt
    const quests = (state.catalog||[]).map(q=>{
      const p = ensureQL(q.name);
      return { name: q.name, lvl: p.lvl, xp: p.xp, next: p.next };
    });

    // sortiere nach h√∂chstem Level, dann nach Rest-XP
    quests.sort((a,b)=> (b.lvl - a.lvl) || (b.xp - a.xp));

    // kleines Progress-Template
    const row = q => {
      const pct = Math.max(0, Math.min(100, Math.round(100 * (q.xp / q.next || 0))));
      return `
        <div class="p-2 border rounded mb-2 bg-white">
          <div class="flex justify-between text-sm">
            <div><strong>${q.name}</strong></div>
            <div>Lvl ${q.lvl} ‚Ä¢ ${q.xp}/${q.next} XP</div>
          </div>
          <div class="w-full bg-slate-200 rounded h-2 mt-2">
            <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
          </div>
        </div>`;
    };

    box.innerHTML = `
      <h3 class="font-bold">Quest-Level √úbersicht</h3>
      <div class="text-xs text-slate-500 mb-2">+100 / +110 / +120 ‚Ä¶ je Level ‚Ä¢ ‚àí15/Tag, wenn die Quest an einem Tag nicht erledigt wurde</div>
      ${quests.length ? quests.map(row).join("") : `<div class="p-2 border rounded bg-slate-50 text-sm text-slate-500">Noch keine Quests im Katalog.</div>`}
    `;
  }

  // ---- Hook ins Dashboard-Rendering (damit Panel immer aktuell ist) ----
  const prevRenderDashboard = typeof renderDashboard === "function" ? renderDashboard : null;
  window.renderDashboard = function(){
    if(prevRenderDashboard) prevRenderDashboard();
    // beim Rendern Strafen bis heute f√ºr alle Quests nachziehen (einmal pro Render ok ‚Äì leichtgewichtig)
    Object.keys(state.questLevels||{}).forEach(name => applyPenaltiesFor(name, isoToday()));
    renderQuestLevelPanel();
  };

  // ---- Initiale Strafen anwenden & speichern ----
  Object.keys(state.questLevels||{}).forEach(name => applyPenaltiesFor(name, isoToday()));
  save();

})();
</script>
<!-- ==== /QUEST-LEVELSYSTEM PRO QUEST ==== -->
<!-- ==== DYNAMISCHE MEILENSTEINE + MISSIONS-BONUS (vor </script> einf√ºgen) ==== -->
(function(){
  // ---------- State / Migration ----------
  // Eigener Tracker, kollidiert nicht mit deinem alten state.milestones-Array
  state.milestoneTrack = state.milestoneTrack || {
    quests:   { awarded: {} },   // thresholds => true
    missions: { awarded: {} },
    boss:     { awarded: {} }
  };

  // ---------- Hilfsfunktionen ----------
  const isoToday = typeof todayISO === "function" ? todayISO : () => new Date().toISOString().slice(0,10);

  // ‚ÄûSystem‚Äú-Eintr√§ge herausfiltern (Importe/Bonis/Eink√§ufe etc.)
  const SYSTEM_RX = /(reward\-kauf|milestone|event\-bonus|event|tagesziel bonus|daily challenge|timed quest|import|backup)/i;

  function isBossQuestName(name){
    if(!state.catalog) return false;
    const q = state.catalog.find(x=>x && x.name===name);
    return !!(q && q.boss);
  }

  // Z√§hle ‚Äûnormale‚Äú Quest-Eintr√§ge (alle positiven Punkte au√üer Systemeintr√§ge)
  function countNormalQuests(){
    return (state.log||[]).filter(e => Number(e.points)>0 && !SYSTEM_RX.test(e.quest||"")).length;
  }

  // Z√§hle Boss-Quest-Abschl√ºsse (jede Eintragung z√§hlt)
  function countBossQuests(){
    return (state.log||[]).filter(e => Number(e.points)>0 && isBossQuestName(e.quest||"")).length;
  }

  // Missions-Fertig-Status
  function missionIsDone(m){
    if(!m) return false;
    if(m.done === true) return true;
    if(Array.isArray(m.tasks) && m.tasks.length>0){
      return m.tasks.every(t => t.done === true);
    }
    return false;
  }

  // Z√§hle erledigte Missionen (aus state.missions)
  function countFinishedMissions(){
    if(!Array.isArray(state.missions)) return 0;
    return state.missions.filter(m => missionIsDone(m)).length;
  }

  // ---------- Missions-Abschlussbonus: 4√ó Punkte beim ersten Abschluss ----------
  // Falls eine Mission fertig ist und noch keinen Bonus bekam ‚Üí gutschreiben
  function grantMissionCompletionBonuses(){
    if(!Array.isArray(state.missions)) return;
    let changed = false;

    state.missions.forEach(m=>{
      if(missionIsDone(m) && !m._bonusGranted){
        const baseSum = (m.tasks||[]).reduce((s,t)=> s + (Number(t.points)||0), 0);
        const bonus   = baseSum * 4; // 4√ó so viele Punkte als Belohnung
        if(bonus>0){
          state.log.push({
            date: isoToday(),
            quest: `Mission abgeschlossen: ${m.title||m.name||"Unbenannte Mission"} (Bonus)`,
            points: bonus
          });
          m._bonusGranted = true;
          changed = true;
        }else{
          // selbst wenn 0 Punkte ‚Äì Flag setzen, um Endlosschleifen zu vermeiden
          m._bonusGranted = true;
          changed = true;
        }
      }
    });

    if(changed){ save(); if(typeof renderAll==="function") renderAll(); }
  }

  // ---------- Meilenstein-Definitionen ----------
  // Schwellen & Belohnungen so, dass deine Beispiele exakt getroffen werden
  const QUEST_THRESHOLDS   = [100, 200, 500, 1000, 2000, 5000, 10000];
  const QUEST_REWARD       = t => (t/10)*(t/10); // 100‚Üí100, 200‚Üí400, 500‚Üí2500, ‚Ä¶

  const MISSION_THRESHOLDS = [5, 10, 20, 50, 100, 200, 500];
  const MISSION_REWARD     = t => {
    // Beispiele: 5‚Üí25, 10‚Üí100, 20‚Üí400, 50‚Üí2500, danach t¬≤
    if(t===5) return 25;
    if(t===10) return 100;
    if(t===20) return 400;
    if(t===50) return 2500;
    return t*t;
  };

  const BOSS_THRESHOLDS    = [10, 20, 50, 100, 200, 500];
  const BOSS_REWARD        = t => {
    // Beispiele: 10‚Üí100, 20‚Üí200, 50‚Üí2500, danach t¬≤
    if(t===10) return 100;
    if(t===20) return 200;
    if(t===50) return 2500;
    return t*t;
  };

  // ---------- Meilensteine pr√ºfen & gutschreiben ----------
  function maybeAward(type, count, thresholds, rewardFn, label){
    const awarded = state.milestoneTrack[type].awarded;
    let any = false;

    thresholds.forEach(t=>{
      if(count >= t && !awarded[t]){
        const reward = Math.round(rewardFn(t));
        // Log-Eintrag mit Punktegutschrift
        if(reward>0){
          state.log.push({
            date: isoToday(),
            quest: `Meilenstein: ${label} ‚Äì ${t}`,
            points: reward
          });
        }
        awarded[t] = true;
        any = true;
      }
    });

    if(any){ save(); if(typeof renderAll==="function") renderAll(); }
  }

  function computeAndAwardMilestones(){
    // 1) Missions-Abschlussbonus pr√ºfen
    grantMissionCompletionBonuses();

    // 2) Z√§hler berechnen
    const qc  = countNormalQuests();
    const bc  = countBossQuests();
    const mc  = countFinishedMissions();

    // 3) ggf. Meilensteine gutschreiben
    maybeAward("quests",   qc, QUEST_THRESHOLDS,   QUEST_REWARD,   "Quests erledigt");
    maybeAward("boss",     bc, BOSS_THRESHOLDS,    BOSS_REWARD,    "Bossquests erledigt");
    maybeAward("missions", mc, MISSION_THRESHOLDS, MISSION_REWARD, "Missionen abgeschlossen");
  }

  // ---------- UI: Panel auf dem Dashboard ----------
  function nextThresholdInfo(count, thresholds, rewardFn){
    const next = thresholds.find(t=>t>count);
    if(!next) return {text:"Alle definierten Meilensteine erreicht üéâ", next:null};
    return {text:`N√§chster bei ${next} (Belohnung: +${Math.round(rewardFn(next))})`, next};
  }

  function renderMilestonesDynamic(){
    computeAndAwardMilestones();

    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // Altes ‚Äûstatisches‚Äú Panel unsch√§dlich machen, indem wir unsere Version unter demselben Hooknamen ausgeben
    let box = document.getElementById("milestonesPanelDynamic");
    if(!box){
      box = document.createElement("div");
      box.id = "milestonesPanelDynamic";
      box.className = "mt-4 p-3 border rounded bg-orange-50";
      host.appendChild(box);
    }

    const qc  = countNormalQuests();
    const bc  = countBossQuests();
    const mc  = countFinishedMissions();

    const qn  = nextThresholdInfo(qc, QUEST_THRESHOLDS,   QUEST_REWARD);
    const bn  = nextThresholdInfo(bc, BOSS_THRESHOLDS,    BOSS_REWARD);
    const mn  = nextThresholdInfo(mc, MISSION_THRESHOLDS, MISSION_REWARD);

    // K√ºrzlich erreichte (max. 6) aus dem Log herausziehen
    const recent = (state.log||[])
      .filter(e => /^Meilenstein: /i.test(e.quest||""))
      .slice(-6)
      .map(e => `${e.quest.replace(/^Meilenstein:\s*/i,"")} (+${e.points})`);

    box.innerHTML = `
      <h3 class="font-bold">üéØ Meilensteine</h3>
      <div class="grid grid-cols-1 gap-2 mt-2">
        <div class="p-2 bg-white rounded border">
          <div class="text-sm">Quests erledigt</div>
          <div class="text-lg font-semibold">${qc}</div>
          <div class="text-xs text-slate-600">${qn.text}</div>
        </div>
        <div class="p-2 bg-white rounded border">
          <div class="text-sm">Bossquests erledigt</div>
          <div class="text-lg font-semibold">${bc}</div>
          <div class="text-xs text-slate-600">${bn.text}</div>
        </div>
        <div class="p-2 bg-white rounded border">
          <div class="text-sm">Missionen abgeschlossen</div>
          <div class="text-lg font-semibold">${mc}</div>
          <div class="text-xs text-slate-600">${mn.text}</div>
        </div>
      </div>
      <div class="mt-3">
        <div class="text-sm font-semibold mb-1">Zuletzt erreicht</div>
        ${recent.length
          ? recent.map(r=>`<div class="text-sm">‚úÖ ${r}</div>`).join("")
          : `<div class="text-sm text-slate-500">Noch keine Meilensteine erreicht.</div>`}
      </div>
    `;
  }

  // ---------- Hooks ----------
  // 1) Altes renderMilestones() √ºberschreiben, falls vorhanden
  window.renderMilestones = renderMilestonesDynamic;

  // 2) In den Dashboard-Render einklinken
  const prevRenderDashboard = typeof renderDashboard === "function" ? renderDashboard : null;
  window.renderDashboard = function(){
    if(prevRenderDashboard) prevRenderDashboard();
    renderMilestonesDynamic();
  };

  // 3) Beim Laden einmal pr√ºfen
  computeAndAwardMilestones();
})();
<!-- ==== /DYNAMISCHE MEILENSTEINE ==== -->
<!-- ==== KATEGORIEN, KATEGORIE-SUMMEN & VERKN√úPFUNGEN (vor </script> einf√ºgen) ==== -->
(function(){
  // ---------- State & Migration ----------
  state.categories = state.categories || [
    {id:"sport",     name:"Sport",                negative:false},
    {id:"handwerk",  name:"Handwerk",            negative:false},
    {id:"haushalt",  name:"Haushalt",            negative:false},
    {id:"gesundheit",name:"Gesundheit",          negative:false},
    {id:"bad",       name:"Schlechter Lebensstil", negative:true}
  ];
  state.categoryLinks = state.categoryLinks || []; // {fromId,toId,ratio} -> nur Kategorie-Punkte, NICHT global

  // Stelle sicher: Katalog-Items haben Kategorie-Felder
  function migrateCatalogCats(){
    (state.catalog||[]).forEach(q=>{
      if(!q) return;
      if(typeof q.categoryId==="undefined") q.categoryId=null;
      if(q.categoryId && getCategory(q.categoryId)?.negative){
        // Defaults f√ºr negative Kategorien:
        if(typeof q.catPoints==="undefined")     q.catPoints     = Math.abs(Number(q.points)||0) || 10; // z.B. +15
        if(typeof q.globalPenalty==="undefined") q.globalPenalty = -Math.max(10, Math.abs((Number(q.points)||0)*2)); // z.B. -30
      }
    });
  }
  migrateCatalogCats();

  function getCategory(id){ return (state.categories||[]).find(c=>c.id===id); }
  function getQuestByName(name){ return (state.catalog||[]).find(q=>q && q.name===name); }

  // ---------- Normalisierung negativer Eintr√§ge (ex post) ----------
  // Falls eine Quest in negativer Kategorie ist, wird der globale Punktewert ggf. auf den definierten Malus gesetzt,
  // und zus√§tzlich categoryPoints am Log vermerkt (nur f√ºr Summenanzeige).
  function normalizeNegativeEntries(){
    let changed=false;
    (state.log||[]).forEach(e=>{
      if(e && !e._negAdj){
        const q = getQuestByName(e.quest);
        if(q && q.categoryId && getCategory(q.categoryId)?.negative){
          const catPts = Math.abs(Number(q.catPoints ?? e.base ?? e.points) || 0);
          const penalty = Number(q.globalPenalty ?? -Math.abs(e.points||0));
          // Nur anpassen, wenn nicht schon negativ erfasst
          e.categoryPoints = catPts;
          e.points = penalty; // GLOBAL wirkt sich negativ aus
          e._negAdj = true;
          changed=true;
        }
      }
    });
    if(changed){ save(); }
  }

  // Beim Laden einmal normalisieren
  normalizeNegativeEntries();

  // ---------- Kategorie-Summen (inkl. Verkn√ºpfungen) ----------
  function computeCategoryTotals(){
    const raw = {};               // direkte Kategoriepunkte
    const totals = {};            // totals inkl. Links
    (state.categories||[]).forEach(c=>{ raw[c.id]=0; totals[c.id]=0; });

    (state.log||[]).forEach(e=>{
      const q = getQuestByName(e.quest);
      if(!q || !q.categoryId) return;
      const cat = getCategory(q.categoryId);
      if(!cat) return;

      let add = 0;
      if(cat.negative){
        // Bei negativer Kategorie: nur die categoryPoints z√§hlen positiv in der Kategorie
        add = Math.abs(Number(e.categoryPoints ?? q.catPoints ?? 0) || 0);
      }else{
        // Sonst z√§hlen die real verdienten Punkte (>=0)
        add = Math.max(0, Number(e.points)||0);
      }
      raw[q.categoryId] += add;
    });

    // Links anwenden (keine globalen Punkte ‚Äì nur Kategorie-√úbertrag)
    // ratio = 0.2 => 20% der FROM-Kategorie addieren auf TO-Kategorie (nur Anzeige)
    Object.keys(raw).forEach(k=> totals[k]+=raw[k]);
    (state.categoryLinks||[]).forEach(l=>{
      if(!raw[l.fromId] && raw[l.fromId]!==0) return;
      if(typeof totals[l.toId]==="undefined") return;
      const extra = Math.round((raw[l.fromId]||0) * (Number(l.ratio)||0));
      totals[l.toId] += extra;
    });

    return {raw, totals};
  }

  // ---------- Dashboard: Kategorie-√úbersicht ----------
  function renderCategorySummary(){
    const host=document.getElementById("tab-dashboard");
    if(!host) return;

    const boxId="categorySummaryBox";
    let box=document.getElementById(boxId);
    if(!box){
      box=document.createElement("div");
      box.id=boxId;
      box.className="mt-4 p-3 border rounded bg-sky-50";
      host.appendChild(box);
    }

    const {totals} = computeCategoryTotals();
    const lines = (state.categories||[]).map(c=>{
      const sum = totals[c.id]||0;
      const badge = c.negative ? "‚ö†Ô∏è" : "üè∑Ô∏è";
      return `<div class="flex justify-between">
        <span>${badge} ${c.name}</span>
        <span class="font-semibold">Œ£ ${sum}</span>
      </div>`;
    }).join("");

    box.innerHTML = `
      <h3 class="font-bold">Kategorien</h3>
      <div class="mt-2 space-y-1">${lines}</div>
      <div class="mt-2 text-xs text-slate-600">Hinweis: Verkn√ºpfungen beeinflussen <b>nur</b> diese Summen, nicht deine globale Punktezahl.</div>
    `;
  }

  // ---------- Catalog: Kategorie-Zuordnung/Editor ----------
  function renderCategoryEditor(){
    const list=document.getElementById("catalogList");
    if(!list) return;

    // Box unterhalb der Liste platzieren
    let box=document.getElementById("categoryEditorBox");
    if(!box){
      box=document.createElement("div");
      box.id="categoryEditorBox";
      box.className="mt-4 p-3 border rounded bg-white";
      list.parentElement.appendChild(box);
    }

    // Editor-UI je Quest
    const options = ['<option value="">(keine)</option>']
      .concat((state.categories||[]).map(c=>`<option value="${c.id}">${c.name}${c.negative?' (negativ)':''}</option>`))
      .join("");

    box.innerHTML = `
      <h3 class="font-bold mb-2">Kategorien verwalten</h3>
      <div class="text-xs text-slate-600 mb-2">Bestehende Quests k√∂nnen hier in Kategorien verschoben werden. F√ºr negative Kategorien k√∂nnen separate Werte gesetzt werden (Kategorie-Punkte vs. globaler Malus).</div>
      <div class="space-y-2" id="catEditorRows">
        ${(state.catalog||[]).map((q,idx)=>{
          if(!q) return "";
          const cat = q.categoryId||"";
          const neg = cat && getCategory(cat)?.negative;
          return `
            <div class="p-2 border rounded">
              <div class="flex flex-wrap gap-2 items-center mb-2">
                <div class="font-medium flex-1">üìå ${q.name}</div>
                <label class="text-sm">Kategorie:
                  <select data-idx="${idx}" data-k="categoryId" class="input inline-block w-44">${options}</select>
                </label>
              </div>
              <div class="${neg?'block':'hidden'}" data-adv="${idx}">
                <div class="grid grid-cols-2 gap-2">
                  <label class="text-sm">Kategorie-Punkte (nur √úbersicht)
                    <input type="number" step="1" min="0" class="input" data-idx="${idx}" data-k="catPoints" value="${Number(q.catPoints??Math.abs(q.points||0))}">
                  </label>
                  <label class="text-sm">Globaler Punkte-Malus
                    <input type="number" step="1" class="input" data-idx="${idx}" data-k="globalPenalty" value="${Number(q.globalPenalty??-(Math.abs(q.points||0)*2))}">
                  </label>
                </div>
                <div class="text-xs text-slate-600 mt-1">Beispiel: ‚Äû1 Joint geraucht‚Äú ‚Üí Kategorie +15, global ‚àí30.</div>
              </div>
            </div>`;
        }).join("")}
      </div>
    `;

    // Vorbelegen der Selects
    (state.catalog||[]).forEach((q,idx)=>{
      const sel = box.querySelector(`select[data-idx="${idx}"][data-k="categoryId"]`);
      if(sel) sel.value = q.categoryId || "";
    });

    // Events
    // Kategorie wechseln ‚Üí evtl. Negativ-Panel ein/aus
    box.querySelectorAll('select[data-k="categoryId"]').forEach(sel=>{
      sel.addEventListener("change",()=>{
        const idx=Number(sel.getAttribute("data-idx"));
        const val=sel.value || null;
        state.catalog[idx].categoryId = val;
        // bei Wechsel Defaults f√ºr negative setzen
        const adv = box.querySelector(`[data-adv="${idx}"]`);
        const neg = val && getCategory(val)?.negative;
        if(adv){ adv.classList.toggle("hidden", !neg); }
        if(neg){
          if(typeof state.catalog[idx].catPoints==="undefined"){
            state.catalog[idx].catPoints = Math.abs(Number(state.catalog[idx].points)||0) || 10;
          }
          if(typeof state.catalog[idx].globalPenalty==="undefined"){
            state.catalog[idx].globalPenalty = -Math.max(10, Math.abs((Number(state.catalog[idx].points)||0)*2));
          }
        }else{
          delete state.catalog[idx].catPoints;
          delete state.catalog[idx].globalPenalty;
        }
        save(); normalizeNegativeEntries(); if(typeof renderAll==="function") renderAll();
      });
    });

    // Inputs (catPoints/globalPenalty)
    box.querySelectorAll('input[data-idx]').forEach(inp=>{
      inp.addEventListener("change",()=>{
        const idx=Number(inp.getAttribute("data-idx"));
        const k=inp.getAttribute("data-k");
        let v=Number(inp.value);
        if(k==="catPoints") v=Math.max(0, Math.floor(v));
        state.catalog[idx][k]=v;
        save(); normalizeNegativeEntries(); if(typeof renderAll==="function") renderAll();
      });
    });
  }

  // ---------- Settings: Kategorien & Verkn√ºpfungen bearbeiten ----------
  function renderCategoryManager(){
    const root=document.getElementById("tab-settings");
    if(!root) return;

    let box=document.getElementById("categoryManagerBox");
    if(!box){
      box=document.createElement("div");
      box.id="categoryManagerBox";
      box.className="mt-4 p-3 border rounded bg-white";
      root.appendChild(box);
    }

    const rows=(state.categories||[]).map((c,i)=>`
      <div class="grid grid-cols-3 gap-2 items-center p-2 border rounded">
        <input class="input" data-c="${i}" data-k="name" value="${c.name}">
        <select class="input" data-c="${i}" data-k="negative">
          <option value="false" ${!c.negative?'selected':''}>Normal</option>
          <option value="true"  ${c.negative?'selected':''}>Negativ</option>
        </select>
        <button class="btn text-red-600" data-del="${i}">L√∂schen</button>
      </div>`).join("");

    box.innerHTML=`
      <h3 class="font-bold mb-2">Kategorien verwalten</h3>
      <div class="space-y-2">${rows || '<div class="text-sm text-slate-500">Noch keine Kategorien.</div>'}</div>
      <button id="btnAddCategory" class="btn mt-2">+ Kategorie</button>
    `;

    box.querySelectorAll('input[data-c], select[data-c]').forEach(el=>{
      el.addEventListener("change",()=>{
        const i=Number(el.getAttribute("data-c"));
        const k=el.getAttribute("data-k");
        let v = (k==="negative") ? (el.value==="true") : el.value;
        state.categories[i][k]=v;
        save(); migrateCatalogCats(); normalizeNegativeEntries(); if(typeof renderAll==="function") renderAll();
      });
    });

    box.querySelectorAll('button[data-del]').forEach(btn=>{
      btn.addEventListener("click",()=>{
        const i=Number(btn.getAttribute("data-del"));
        const id=state.categories[i].id;
        // Quests, die diese Kategorie nutzen, auf null setzen
        (state.catalog||[]).forEach(q=>{ if(q.categoryId===id) q.categoryId=null; });
        state.categories.splice(i,1);
        save(); if(typeof renderAll==="function") renderAll();
      });
    });

    const addBtn=box.querySelector("#btnAddCategory");
    if(addBtn){
      addBtn.addEventListener("click",()=>{
        const id=("c"+Math.random().toString(36).slice(2,8));
        state.categories.push({id,name:"Neue Kategorie",negative:false});
        save(); if(typeof renderAll==="function") renderAll();
      });
    }
  }

  function renderCategoryLinksPanel(){
    const root=document.getElementById("tab-settings");
    if(!root) return;

    let box=document.getElementById("categoryLinksBox");
    if(!box){
      box=document.createElement("div");
      box.id="categoryLinksBox";
      box.className="mt-4 p-3 border rounded bg-white";
      root.appendChild(box);
    }

    const opts = (state.categories||[]).map(c=>`<option value="${c.id}">${c.name}${c.negative?' (negativ)':''}</option>`).join("");

    box.innerHTML=`
      <h3 class="font-bold mb-2">Kategorie-Verkn√ºpfungen</h3>
      <div class="text-xs text-slate-600 mb-2">
        Beispiel: Handwerk ‚Üí Sport (20%) bedeutet: Punkte aus <b>Handwerk</b> z√§hlen zus√§tzlich zu <b>Sport</b> (nur in der Kategorie-√úbersicht).
        <br>Keine globalen Boni ‚Äì deine Gesamtpunkte bleiben unver√§ndert.
      </div>
      <div id="linkRows" class="space-y-2">
        ${(state.categoryLinks||[]).map((l,i)=>`
          <div class="grid grid-cols-7 gap-2 items-center p-2 border rounded">
            <span class="text-sm">Von:</span>
            <select class="input col-span-2" data-i="${i}" data-k="fromId">${opts}</select>
            <span class="text-sm">Nach:</span>
            <select class="input col-span-2" data-i="${i}" data-k="toId">${opts}</select>
            <input class="input" type="number" min="0" max="100" step="1" data-i="${i}" data-k="ratioPerc" value="${Math.round((Number(l.ratio)||0)*100)}">
            <button class="btn text-red-600" data-del="${i}">L√∂schen</button>
          </div>
        `).join("")}
      </div>
      <button id="btnAddLink" class="btn mt-2">+ Verkn√ºpfung</button>
    `;

    // Vorbelegen
    (state.categoryLinks||[]).forEach((l,i)=>{
      const f=box.querySelector(`select[data-i="${i}"][data-k="fromId"]`);
      const t=box.querySelector(`select[data-i="${i}"][data-k="toId"]`);
      if(f) f.value=l.fromId;
      if(t) t.value=l.toId;
    });

    // Events
    box.querySelectorAll('select[data-k="fromId"], select[data-k="toId"], input[data-k="ratioPerc"]').forEach(el=>{
      el.addEventListener("change",()=>{
        const i=Number(el.getAttribute("data-i"));
        const k=el.getAttribute("data-k");
        if(k==="ratioPerc"){
          const perc=Math.max(0, Math.min(100, Number(el.value)||0));
          state.categoryLinks[i].ratio = perc/100;
        }else{
          state.categoryLinks[i][k]=el.value;
        }
        save(); if(typeof renderAll==="function") renderAll();
      });
    });

    box.querySelectorAll('button[data-del]').forEach(btn=>{
      btn.addEventListener("click",()=>{
        const i=Number(btn.getAttribute("data-del"));
        state.categoryLinks.splice(i,1);
        save(); if(typeof renderAll==="function") renderAll();
      });
    });

    const add=box.querySelector("#btnAddLink");
    if(add){
      add.addEventListener("click",()=>{
        // Default: erstes‚Üízweites, 20%
        const ids=(state.categories||[]).map(c=>c.id);
        state.categoryLinks.push({fromId:ids[0]||null, toId:ids[1]||ids[0]||null, ratio:0.2});
        save(); if(typeof renderAll==="function") renderAll();
      });
    }
  }

  // ---------- Hooks ----------
  // Dashboard erweitern
  const prevRenderDashboard = (typeof renderDashboard==="function") ? renderDashboard : null;
  window.renderDashboard = function(){
    if(prevRenderDashboard) prevRenderDashboard();
    normalizeNegativeEntries();
    renderCategorySummary();
  };

  // Catalog um Editor erweitern
  const prevRenderCatalog = (typeof renderCatalog==="function") ? renderCatalog : null;
  window.renderCatalog = function(){
    if(prevRenderCatalog) prevRenderCatalog();
    renderCategoryEditor();
  };

  // Settings um Manager + Links erweitern
  const prevRenderSettings = (typeof renderSettings==="function") ? renderSettings : null;
  window.renderSettings = function(){
    if(prevRenderSettings) prevRenderSettings();
    renderCategoryManager();
    renderCategoryLinksPanel();
  };

  // Beim Start einmal alles nachziehen
  if(typeof renderAll==="function") renderAll();
})();
<!-- ==== /KATEGORIEN ==== -->
<!-- ==== DYNAMISCHE MEILENSTEINE (vor </script> einf√ºgen) ==== -->
(function(){

  // --------- State & Migration ----------
  // Alte, starre Meilensteine ignorieren ‚Äì wir nutzen ein eigenes, klares Namespace:
  state.milestonesDyn = state.milestonesDyn || {
    claimed: {} // z.B. { "missions:10": true, "quests:200": true, "cat:sport:500": true }
  };

  // Hilfen
  const todayISO = window.todayISO || (()=>new Date().toISOString().slice(0,10));
  function saveIf(fn){ const r=fn(); save(); return r; }

  // --------- Z√§hler-Quellen ----------
  // Missionen: gez√§hlt werden Missionen, die vollst√§ndig abgeschlossen sind.
  function isMissionDone(m){
    if(!m) return false;
    if(m.done===true) return true;
    if(Array.isArray(m.tasks) && m.tasks.length>0){
      return m.tasks.every(t=>t && t.done===true);
    }
    return false;
  }
  function missionsCompletedCount(){
    if(!Array.isArray(state.missions)) return 0;
    return state.missions.filter(isMissionDone).length;
  }

  // Quests gesamt: Zahl der POSITIVEN Eintr√§ge (negativ kategorisierte Quests z√§hlen hier NICHT).
  function questsCompletedCount(){
    const log = Array.isArray(state.log)?state.log:[];
    return log.filter(e=>{
      // ignore negative/neutral
      if(!e) return false;
      const q = (state.catalog||[]).find(x=>x && x.name===e.quest);
      if(q && q.categoryId){
        const cat = (state.categories||[]).find(c=>c.id===q.categoryId);
        if(cat && cat.negative) return false;
      }
      return Number(e.points||0) > 0;
    }).length;
  }

  // Bossquests: Eintr√§ge, deren Katalogeintrag boss===true
  function bossQuestsCompletedCount(){
    const log = Array.isArray(state.log)?state.log:[];
    return log.filter(e=>{
      if(!e) return false;
      const q = (state.catalog||[]).find(x=>x && x.name===e.quest);
      return !!(q && q.boss===true);
    }).length;
  }

  // Kategorien: wir greifen auf computeCategoryTotals() aus dem Kategorien-Block zur√ºck
  function getCategoryTotalsSafe(){
    if(typeof window.computeCategoryTotals==="function") return window.computeCategoryTotals();
    // Fallback: keine Kategorien ‚Üí leeres Objekt
    return {raw:{},totals:{}};
  }

  // --------- Schwellen-Serien & Rewards ----------
  // Vorgegebene ‚ÄûSamen‚Äú-Schwellen; danach wird jeweils verdoppelt.
  const SEEDS = {
    missions: [5,10,20,50],        // dann *2 ‚Üí 100, 200, 400, ‚Ä¶
    quests:   [100,200,500],        // dann *2 ‚Üí 1000, 2000, ‚Ä¶
    bosses:   [10,20,50],           // dann *2 ‚Üí 100, 200, 400, ‚Ä¶
    category: [100,200,500,1000]    // dann *2 ‚Üí 2000, 4000, ‚Ä¶
  };

  // Rewards:
  // - Missionen: T*T  (passt zu 10‚Üí100, 20‚Üí400, 50‚Üí2500)
  // - Quests:   (T/10)^2  (100‚Üí100, 200‚Üí400, 500‚Üí2500)
  // - Boss:     10/20 bleiben linear x10 (Beispiel 20‚Üí200), ab 50 quadratisch (50‚Üí2500)
  // - Kategorie: (T/10)^2  (analog zu Quests)
  function rewardFor(key, threshold){
    if(key==="missions") return threshold*threshold;
    if(key==="quests")   return Math.round((threshold/10)*(threshold/10));
    if(key==="bosses"){
      if(threshold<=20) return threshold*10;
      return threshold*threshold;
    }
    // category
    return Math.round((threshold/10)*(threshold/10));
  }

  // N√§chste Schwelle in Serie bestimmen
  function nextThresholdFromSeries(series, last){
    if(typeof last==="undefined" || last===null) return series[0];
    const idx = series.indexOf(last);
    if(idx>=0){
      if(idx < series.length-1) return series[idx+1];
      return last*2;
    }
    // falls last nicht exakt in seeds: nimm den gr√∂√üten <= last und verdopple
    const smaller = series.filter(x=>x<=last);
    const base = smaller.length? smaller[smaller.length-1] : series[0];
    if(last<=base) return base;
    return last*2;
  }

  // Generator: gib die ‚Äûn√§chsten N‚Äú Schwellen ab der zuletzt erreichten zur√ºck
  function nextThresholds(key, lastClaimed, N=3){
    const seeds = (key==="category")? SEEDS.category : SEEDS[key];
    const list=[];
    let cur = (typeof lastClaimed==="number")? lastClaimed : null;
    for(let i=0;i<N;i++){
      cur = nextThresholdFromSeries(seeds, cur);
      list.push(cur);
    }
    return list;
  }

  // Bereits beanspruchte (claimed) Schwelle lesen/schreiben
  function getClaimed(key, extraId){ // extraId f√ºr Kategorien (catId)
    const id = extraId ? `${key}:${extraId}` : key;
    const v = state.milestonesDyn.claimed[id];
    return (typeof v==="number")? v : null;
  }
  function setClaimed(key, threshold, extraId){
    const id = extraId ? `${key}:${extraId}` : key;
    state.milestonesDyn.claimed[id] = Number(threshold);
  }

  // --------- Fortschritte bestimmen ----------
  function currentValue(key, extraId){
    if(key==="missions") return missionsCompletedCount();
    if(key==="quests")   return questsCompletedCount();
    if(key==="bosses")   return bossQuestsCompletedCount();
    if(key==="category"){
      const totals = getCategoryTotalsSafe().totals || {};
      return Number(totals[extraId]||0);
    }
    return 0;
  }

  // --------- Auto-Award (Punkte gutschreiben) ----------
  function awardMilestone(key, threshold, extraId){
    const value = currentValue(key, extraId);
    if(value < threshold) return false; // noch nicht erreicht
    const already = getClaimed(key, extraId);
    if(already && already>=threshold) return false; // schon gutgeschrieben

    // Punkte verbuchen
    const reward = rewardFor(key, threshold);
    const title =
      key==="missions" ? `Meilenstein: ${threshold} Missionen`
    : key==="quests"   ? `Meilenstein: ${threshold} Quests`
    : key==="bosses"   ? `Meilenstein: ${threshold} Bossquests`
    :                   `Meilenstein: ${getCategoryName(extraId)} ${threshold}`;

    state.log.push({date:todayISO(),quest:title,points:reward});
    setClaimed(key, threshold, extraId);
    save();
    return true;
  }

  function getCategoryName(id){
    const c=(state.categories||[]).find(x=>x.id===id);
    return c? c.name : id;
  }

  // Alle relevanten Meilensteine pr√ºfen & ggf. gutschreiben
  function checkAllMilestones(){
    // Missionen / Quests / Bossquests:
    ["missions","quests","bosses"].forEach(key=>{
      const last = getClaimed(key,null);
      const list = nextThresholds(key, last, 3);
      list.forEach(T => awardMilestone(key,T,null));
    });

    // Pro Kategorie:
    (state.categories||[]).forEach(cat=>{
      const last = getClaimed("category",cat.id);
      const list = nextThresholds("category", last, 3);
      list.forEach(T => awardMilestone("category",T,cat.id));
    });
  }

  // --------- Render: Box im Dashboard ----------
  function renderMilestonesBox(){
    const host=document.getElementById("tab-dashboard");
    if(!host) return;

    const boxId="dynMilestonesBox";
    let box=document.getElementById(boxId);
    if(!box){
      box=document.createElement("div");
      box.id=boxId;
      box.className="mt-4 p-3 border rounded bg-orange-50";
      host.appendChild(box);
    }

    // Zeige n√§chsten Ziele + Fortschritt
    const rows=[];

    function rowFor(key,label,extraId){
      const last = getClaimed(key, extraId);
      const nexts = nextThresholds(key, last, 2);
      const cur   = currentValue(key, extraId);

      const lines = nexts.map(T=>{
        const reward = rewardFor(key,T);
        const done = cur>=T;
        const pct  = Math.min(100, Math.round((cur/T)*100));
        return `
          <div class="mt-1 p-2 border rounded ${done?'bg-green-100':'bg-white'}">
            <div class="flex justify-between">
              <span>${label} ‚Äì Ziel ${T} ${extraId?`<span class="text-xs text-slate-500">(${getCategoryName(extraId)})</span>`:''}</span>
              <span>üéÅ +${reward}</span>
            </div>
            <div class="w-full bg-slate-200 h-2 rounded mt-1">
              <div class="h-2 rounded bg-green-500" style="width:${pct}%"></div>
            </div>
            <div class="text-xs text-slate-600 mt-1">Fortschritt: ${cur}/${T}</div>
          </div>`;
      }).join("");

      return `<div class="mb-2">
        <div class="font-semibold">${label}${extraId?` ‚Äì ${getCategoryName(extraId)}`:''}</div>
        ${lines}
      </div>`;
    }

    rows.push(rowFor("missions","Missionen erledigt",null));
    rows.push(rowFor("quests","Quests erledigt",null));
    rows.push(rowFor("bosses","Bossquests erledigt",null));

    // Kategorien
    (state.categories||[]).forEach(cat=>{
      rows.push(rowFor("category","Kategorie-Punkte",cat.id));
    });

    box.innerHTML = `
      <h3 class="font-bold">üéØ Dynamische Meilensteine</h3>
      <div class="text-xs text-slate-600">Belohnungen sind hochskaliert (z. B. 50 ‚Üí 2500 Punkte). Alles w√§chst automatisch mit.</div>
      <div class="mt-2">${rows.join("")}</div>
    `;
  }

  // --------- Hooks ----------
  const prevRenderDashboard = (typeof window.renderDashboard==="function") ? window.renderDashboard : null;
  window.renderDashboard = function(){
    if(prevRenderDashboard) prevRenderDashboard();
    checkAllMilestones();
    renderMilestonesBox();
  };

  // Beim Start einmal durchlaufen
  if(typeof window.renderAll==="function") window.renderAll();

})();
<!-- ==== /DYNAMISCHE MEILENSTEINE ==== -->
<!-- ==== MISSION-BONUS (4√ó) + CHAT FIX (vor </script> einf√ºgen) ==== -->
(function(){

  // ---------- Hilfen ----------
  const todayISO = window.todayISO || (()=>new Date().toISOString().slice(0,10));
  function toast(msg, cls="bg-emerald-600"){
    const t=document.createElement("div");
    t.textContent=msg;
    t.className=`fixed bottom-24 left-1/2 -translate-x-1/2 ${cls} text-white px-4 py-2 rounded shadow-lg`;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(),2000);
  }
  function sum(arr){return arr.reduce((a,b)=>a+b,0);}

  // ---------- Mission-Utils ----------
  state.missions = state.missions || [];
  // Flag pro Mission, ob der 4√ó-Abschlussbonus bereits ausgesch√ºttet wurde
  // (falls √§ltere Missionen existieren, initialisiere sicher)
  state.missions.forEach(m=>{ if(m && typeof m.rewarded==="undefined") m.rewarded=false; });

  function missionTotalPoints(m){
    if(!m || !Array.isArray(m.tasks)) return 0;
    return sum(m.tasks.map(t=>Number(t && t.points || 0)));
  }
  function isMissionDone(m){
    if(!m) return false;
    if(m.done===true) return true;
    if(Array.isArray(m.tasks) && m.tasks.length>0){
      return m.tasks.every(t=>t && t.done===true);
    }
    return false;
  }
  function recomputeUnlocks(m){
    // falls dein Missionsblock bereits eine eigene Funktion hat, diese bevorzugen
    if(typeof window.recomputeUnlocks==="function" && m) return window.recomputeUnlocks(m);
    // Minimal: nichts tun (Tasks bleiben sichtbar)
  }

  // Versuche, den letzten Log-Eintrag einer offenen Task zuzuordnen (Name = exakt)
  function tryMarkTaskFromLog(entry){
    if(!entry || !entry.quest) return null;
    let touched = null;

    for(const m of state.missions){
      if(!m || !Array.isArray(m.tasks)) continue;
      const task = m.tasks.find(t => t && !t.done && (t.name||"").toLowerCase() === entry.quest.toLowerCase());
      if(task){
        task.done = true;
        task.doneAt = entry.date || todayISO();
        touched = m;
        recomputeUnlocks(m);
        break;
      }
    }
    return touched; // Mission, die ver√§ndert wurde, oder null
  }

  function awardMissionIfCompleted(m){
    if(!m) return false;
    if(m.rewarded) return false;
    const done = isMissionDone(m);
    if(!done) return false;

    // 4√ó Summe aller Task-Punkte als **Bonus** (ohne Streak/Multiplikator)
    const baseSum = missionTotalPoints(m);
    const bonus   = baseSum * 4;

    state.log.push({
      date: todayISO(),
      quest: `Mission abgeschlossen: ${m.name || "Ohne Titel"}`,
      points: bonus
    });
    m.rewarded = true;
    try{ save(); }catch(e){}
    try{
      if(window.FX) FX.burst();
      if(window.Sound && Sound.level) Sound.level();
    }catch(e){}

    toast(`üéâ Mission abgeschlossen! +${bonus} Punkte`);
    return true;
  }

  // ---------- addLog hooken ----------
  const prevAddLog = window.addLog;
  window.addLog = function(){
    const lenBefore = (state.log||[]).length;
    // urspr√ºngliches Logging ausf√ºhren
    if(typeof prevAddLog==="function"){ prevAddLog(); }
    const lenAfter = (state.log||[]).length;
    if(lenAfter<=lenBefore) return;

    const last = state.log[lenAfter-1];

    // 1) Task auto-abhaken (wenn Name identisch)
    const changedMission = tryMarkTaskFromLog(last);
    if(changedMission){
      try{ save(); }catch(e){}
      awardMissionIfCompleted(changedMission);
      if(typeof window.renderAll==="function") renderAll();
    }
  };

  // ---------- Chat reaktivieren & vereinheitlichen ----------
  // Robuste Chat-Ausgabe (nutzt #chatWindow, fallback #chatLog)
  window.chatAddMessage = function(from, text){
    const host = document.getElementById("chatWindow") || document.getElementById("chatLog");
    if(!host) return;
    const row = document.createElement("div");
    const isUser = (from==="user");
    row.className = isUser ? "text-right" : "text-left text-blue-700";
    row.textContent = text;
    host.appendChild(row);
    host.scrollTop = host.scrollHeight;
  };

  let chatBound = false;
  function ensureChatBindings(){
    if(chatBound) return;
    const btn = document.getElementById("btnChatSend") || document.getElementById("btnChat");
    const inp = document.getElementById("chatInput");
    if(!btn || !inp) return;

    function send(){
      const txt = (inp.value||"").trim();
      if(!txt) return;
      window.chatAddMessage("user", txt);
      let out=[];
      try{
        if(typeof window.processMessage==="function"){
          const r = window.processMessage(txt);
          if(Array.isArray(r)) out=r;
        }
      }catch(e){
        out = ["‚ö†Ô∏è Chat-Fehler: "+(e.message||e)];
      }
      out.forEach(msg=>window.chatAddMessage("bot", msg));
      inp.value="";
    }

    btn.addEventListener("click", send);
    inp.addEventListener("keydown", (ev)=>{ if(ev.key==="Enter") send(); });
    chatBound = true;
  }

  // Nach jedem Render sicher erneut binden
  const prevRenderAll = window.renderAll;
  window.renderAll = function(){
    if(typeof prevRenderAll==="function") prevRenderAll();
    ensureChatBindings();
  };

  // Erstinitialisierung
  ensureChatBindings();

  // ---------- Start: evtl. bestehende Missionen auf Abschluss pr√ºfen ----------
  state.missions.forEach(m=>{
    if(isMissionDone(m) && !m.rewarded){
      // kein Bonus nachtr√§glich ohne Nutzeraktion ‚Äì nur sauber markieren (Vermeidung von doppelten Boni)
      // Wenn du historische Boni auch nachtr√§glich auszahlen willst, setze die n√§chste Zeile auf "false"
      // und rufe awardMissionIfCompleted(m) stattdessen auf.
      m.rewarded = false; // offen lassen, wird beim n√§chsten passenden Log ausgezahlt
    }
  });
  try{ save(); }catch(e){}

})();
<!-- ==== /MISSION-BONUS + CHAT FIX ==== -->
<!-- ==== KATEGORIEN: Summen, Zuordnung & Links (vor </script> einf√ºgen) ==== -->
(function(){

  // ---------- Init ----------
  state.categories = state.categories || [
    {id:"sport",      name:"Sport",      type:"normal"},
    {id:"handwerk",   name:"Handwerk",   type:"normal"},
    {id:"haushalt",   name:"Haushalt",   type:"normal"},
    {id:"ernaehrung", name:"Ern√§hrung",  type:"normal"},
    {id:"negativ",    name:"Schlechter Lebensstil", type:"negative"}
  ];
  // Verkettungen: A -> B mit ratio (0..1), nur als Kategorie-Credit f√ºr B
  state.categoryLinks = state.categoryLinks || [
    // Beispiel: 25% von Handwerk z√§hlen zus√§tzlich zur Kategorie Sport (nur Anzeige/Credit)
    // {from:"handwerk", to:"sport", ratio:0.25}
  ];

  // F√ºr Quests: .cat (categoryId)
  state.catalog = state.catalog || [];

  // ---------- Helpers ----------
  const byId = id => state.categories.find(c=>c.id===id);
  function ensureId(name){
    // mache aus Namen stabile id
    return name.toLowerCase()
               .replace(/\s+/g,"-")
               .replace(/[^\w\-√§√∂√º√Ñ√ñ√ú√ü]/g,"")
               .slice(0,40);
  }
  function saveSafe(){ try{ save(); }catch(e){} }

  function getQuestByName(name){
    return state.catalog.find(q => (q.name||"").toLowerCase() === (name||"").toLowerCase());
  }

  function questCategoryId(q){
    return q && q.cat ? q.cat : null;
  }

  function entryCategoryId(e){
    // 1) Direkt am Log-Eintrag?
    if(e.cat) return e.cat;
    // 2) Vom Quest ableiten
    const q=getQuestByName(e.quest);
    if(q && q.cat){ e.cat = q.cat; return q.cat; }
    return null;
  }

  // ---------- Quests verschieben (inkl. r√ºckwirkend) ----------
  function moveQuestToCategory(questIndex, newCatId, retro=true){
    const q = state.catalog[questIndex];
    if(!q) return;
    q.cat = newCatId || null;
    if(retro){
      const nameLower = (q.name||"").toLowerCase();
      state.log.forEach(e=>{
        if((e.quest||"").toLowerCase()===nameLower){
          e.cat = newCatId || null;
        }
      });
    }
    saveSafe();
    if(typeof renderAll==="function") renderAll();
  }

  // ---------- Kategorie-Summen berechnen ----------
  // Ergebnis: { [catId]: {base:number, link:number, total:number} }
  function computeCategorySums(){
    const sums = {};
    state.categories.forEach(c=>sums[c.id]={base:0, link:0, total:0});

    // Basis aus Log
    (state.log||[]).forEach(e=>{
      const cid = entryCategoryId(e);
      if(!cid || !sums[cid]) return;
      sums[cid].base += Number(e.points||0);
    });

    // Link-Credits einrechnen (A ‚Üí B * ratio)
    (state.categoryLinks||[]).forEach(l=>{
      if(!l || !l.from || !l.to || typeof l.ratio!=="number") return;
      const from = sums[l.from]; const to = sums[l.to];
      if(!from || !to) return;
      const credit = Math.round(from.base * l.ratio);
      to.link += credit;
    });

    // Total
    Object.keys(sums).forEach(id=>{
      sums[id].total = sums[id].base + sums[id].link;
    });
    return sums;
  }

  // ---------- Dashboard: Kategorie-Box ----------
  function renderCategoryOverview(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;
    const sums = computeCategorySums();

    const box = document.createElement("div");
    box.className = "mt-4 p-3 border rounded bg-slate-50";
    let html = `<h3 class="font-bold mb-2">Kategorien (Punktesummen)</h3>`;
    html += `<div class="space-y-1">` +
      state.categories.map(c=>{
        const s = sums[c.id] || {base:0,link:0,total:0};
        const tag = c.type==="negative" ? "text-red-700" : "text-slate-700";
        const linkInfo = s.link ? ` <span class="text-xs text-slate-500">(inkl. +${s.link} Link-Credit)</span>` : "";
        return `<div class="flex justify-between items-baseline">
                  <span class="${tag}">${c.name}</span>
                  <span class="font-medium">${s.total}</span>${linkInfo}
                </div>`;
      }).join("") +
      `</div>`;
    box.innerHTML = html;
    host.appendChild(box);
  }

  // Hook ins Dashboard
  const oldRenderDashboard_cat = renderDashboard;
  renderDashboard = function(){
    oldRenderDashboard_cat();
    renderCategoryOverview();
  };

  // ---------- Settings: Kategorie-Manager ----------
  function renderCategoryManager(){
    const host = document.getElementById("tab-settings");
    if(!host) return;

    // Container anh√§ngen (unter bestehende Settings)
    const wrap = document.createElement("div");
    wrap.className = "mt-6 p-3 border rounded bg-white";
    wrap.innerHTML = `
      <h3 class="font-bold mb-2">Kategorien & Verkn√ºpfungen</h3>

      <div id="cm-cats" class="space-y-2"></div>
      <button id="cm-add-cat" class="btn mt-2">+ Kategorie</button>

      <div class="mt-4">
        <h4 class="font-semibold mb-1">Verkn√ºpfungen (nur Kategorie-Credit)</h4>
        <div id="cm-links" class="space-y-2"></div>
        <div class="grid grid-cols-5 gap-2 items-center">
          <select id="cm-from" class="input col-span-2"></select>
          <span class="text-center">‚Üí</span>
          <select id="cm-to" class="input col-span-2"></select>
          <input id="cm-ratio" type="number" step="0.05" min="0" max="1" class="input" placeholder="Anteil z. B. 0.25" />
        </div>
        <button id="cm-add-link" class="btn mt-2">+ Verkn√ºpfung</button>
      </div>
    `;
    host.appendChild(wrap);

    // Kategorien-Liste
    function drawCats(){
      const area = wrap.querySelector("#cm-cats");
      area.innerHTML = state.categories.map((c,i)=>`
        <div class="grid grid-cols-6 gap-2 items-center">
          <input data-i="${i}" data-k="name" class="input col-span-3" value="${c.name}">
          <select data-i="${i}" data-k="type" class="input col-span-2">
            <option value="normal" ${c.type==="normal"?"selected":""}>normal</option>
            <option value="negative" ${c.type==="negative"?"selected":""}>negativ</option>
          </select>
          <button data-del="${i}" class="btn text-red-600">L√∂schen</button>
        </div>
      `).join("");

      area.querySelectorAll("[data-k]").forEach(inp=>{
        inp.addEventListener("change",()=>{
          const i=+inp.getAttribute("data-i");
          const k=inp.getAttribute("data-k");
          let v=inp.value;
          if(k==="name"){
            // id stabilisieren, wenn neue Kategorie
            if(!state.categories[i].id || state.categories[i].id===ensureId(state.categories[i].name)){
              state.categories[i].id = ensureId(v);
            }
          }
          state.categories[i][k]=v;
          saveSafe();
          // Aktualisiere DropDowns
          fillCatOptions();
          if(typeof renderAll==="function") renderAll();
        });
      });

      area.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i=+btn.getAttribute("data-del");
          const cat=state.categories[i];
          if(!cat) return;
          if(!confirm(`Kategorie "${cat.name}" l√∂schen? Quests behalten ihre Zuordnung nicht.`)) return;
          // Zuordnungen entfernen
          state.catalog.forEach(q=>{ if(q.cat===cat.id) q.cat=null; });
          state.log.forEach(e=>{ if(e.cat===cat.id) e.cat=null; });
          state.categories.splice(i,1);
          saveSafe();
          drawCats(); fillCatOptions();
          if(typeof renderAll==="function") renderAll();
        });
      });
    }

    wrap.querySelector("#cm-add-cat").addEventListener("click",()=>{
      const name = prompt("Neue Kategorie (Name)?");
      if(!name) return;
      const id = ensureId(name);
      if(state.categories.some(c=>c.id===id)){
        alert("Diese Kategorie gibt es bereits.");
        return;
      }
      state.categories.push({id,name,type:"normal"});
      saveSafe(); drawCats(); fillCatOptions();
      if(typeof renderAll==="function") renderAll();
    });

    // Links-Anzeige + Add
    function drawLinks(){
      const area = wrap.querySelector("#cm-links");
      area.innerHTML = (state.categoryLinks||[]).length ? 
        state.categoryLinks.map((l,i)=>{
          const from = byId(l.from)?.name||l.from;
          const to   = byId(l.to)?.name||l.to;
          const r    = (Number(l.ratio)||0).toFixed(2);
          return `<div class="flex justify-between items-center">
                    <div>${from} ‚Üí ${to} <span class="text-slate-500">(+${r}√ó als Kategorie-Credit)</span></div>
                    <button data-del-link="${i}" class="btn text-red-600">Entfernen</button>
                  </div>`;
        }).join("")
        : `<div class="text-sm text-slate-500">Keine Verkn√ºpfungen</div>`;

      area.querySelectorAll("[data-del-link]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const i=+btn.getAttribute("data-del-link");
          state.categoryLinks.splice(i,1);
          saveSafe(); drawLinks();
          if(typeof renderAll==="function") renderAll();
        });
      });
    }

    function fillCatOptions(){
      const fromSel = wrap.querySelector("#cm-from");
      const toSel   = wrap.querySelector("#cm-to");
      const opts = state.categories.map(c=>`<option value="${c.id}">${c.name}</option>`).join("");
      fromSel.innerHTML = opts;
      toSel.innerHTML   = opts;
    }

    wrap.querySelector("#cm-add-link").addEventListener("click",()=>{
      const from = wrap.querySelector("#cm-from").value;
      const to   = wrap.querySelector("#cm-to").value;
      const ratio= Number(wrap.querySelector("#cm-ratio").value||0);
      if(!from || !to || from===to) return alert("Bitte unterschiedliche Kategorien w√§hlen.");
      if(!(ratio>0)) return alert("Bitte einen Anteil > 0 angeben (z. B. 0.25).");
      state.categoryLinks.push({from,to,ratio});
      saveSafe(); drawLinks();
      if(typeof renderAll==="function") renderAll();
    });

    drawCats();
    fillCatOptions();
    drawLinks();
  }

  // Hook ins Settings-Render
  const oldRenderSettings_cat = renderSettings;
  renderSettings = function(){
    oldRenderSettings_cat();
    renderCategoryManager();
  };

  // ---------- Catalog: Kategorie-Select je Quest ----------
  function renderCatalogCategories(){
    const list = document.getElementById("catalogList");
    if(!list) return;

    // Baue die Liste komplett neu (inkl. Timed-Quest-Button)
    list.innerHTML = state.catalog.map((q,i)=>{
      const catName = byId(q.cat)?.name || "‚Äî keine ‚Äî";
      return `
        <div class="p-2 border rounded ${q.boss?'bg-yellow-50':'bg-white'}">
          <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <div>
              ${q.boss?'üëë ':''}<b>${q.name}</b>
              <span class="text-slate-500">(+${q.points} Punkte)</span>
            </div>
            <div class="flex gap-2 items-center">
              <select class="input text-sm" data-cat-for="${i}">
                <option value="">‚Äî keine ‚Äî</option>
                ${state.categories.map(c=>`<option value="${c.id}" ${q.cat===c.id?'selected':''}>${c.name}</option>`).join("")}
              </select>
              <button class="text-red-600 text-sm btn" data-del="${i}">L√∂schen</button>
            </div>
          </div>
        </div>
      `;
    }).join("") + `
      <button id="btnAddTimedQuest_cat" class="btn w-full bg-purple-600 text-white mt-2">+ Timed Quest</button>
    `;

    // Events
    list.querySelectorAll("[data-cat-for]").forEach(sel=>{
      sel.addEventListener("change",()=>{
        const i = Number(sel.getAttribute("data-cat-for"));
        const newCat = sel.value || null;
        const retro = confirm("Soll die neue Kategorie r√ºckwirkend auf bestehende Eintr√§ge dieses Quests angewendet werden?");
        moveQuestToCategory(i, newCat, retro);
      });
    });

    list.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const i=Number(btn.getAttribute("data-del"));
        if(!confirm(`Quest "${state.catalog[i]?.name}" l√∂schen?`)) return;
        state.catalog.splice(i,1);
        saveSafe();
        renderAll();
      });
    });

    const btnT = document.getElementById("btnAddTimedQuest_cat");
    if(btnT) btnT.addEventListener("click", ()=>{
      if(typeof addTimedQuest==="function") addTimedQuest();
    });
  }

  // Hook in Catalog-Render (nach bestehendem Rendering)
  const oldRenderCatalog_cat = renderCatalog;
  renderCatalog = function(){
    oldRenderCatalog_cat();
    renderCatalogCategories();
  };

  // ---------- Fertig ----------
  saveSafe();

})();
<!-- ==== /KATEGORIEN ==== -->
<!-- === PATCH A : Chat-Fix & Konsolidierung (vor </script> einf√ºgen) === -->
<script>
(function(){
  "use strict";

  // 1) DOM sicherstellen / vereinheitlichen
  const mainEl = document.querySelector("main") || document.body;

  // a) Chat-Section sicherstellen
  let chatSection = document.getElementById("tab-chat");
  if(!chatSection){
    chatSection = document.createElement("section");
    chatSection.id = "tab-chat";
    chatSection.className = "tab space-y-4";
    chatSection.innerHTML = `
      <div class="card p-3 space-y-2">
        <div id="chatLog" class="h-64 overflow-y-auto border p-2 rounded bg-white text-sm"></div>
        <div class="flex gap-2">
          <input id="chatInput" class="input flex-1" placeholder="Schreib etwas wie 'Heute habe ich Sport gemacht'"/>
          <button id="btnChatSend" class="btn bg-blue-600 text-white">Senden</button>
        </div>
      </div>
    `;
    mainEl.appendChild(chatSection);
  }

  // b) Chat-Container vereinheitlichen (chatLog bevorzugt, sonst chatWindow √ºbernehmen)
  let chatLog = document.getElementById("chatLog");
  const legacyWin = document.getElementById("chatWindow");
  if(!chatLog && legacyWin){
    // Falls es nur #chatWindow gibt: als #chatLog "umwidmen"
    legacyWin.id = "chatLog";
    chatLog = legacyWin;
  }
  if(!chatLog){
    // Falls gar nichts existiert, neu anlegen
    const box = document.createElement("div");
    box.id = "chatLog";
    box.className = "h-64 overflow-y-auto border p-2 rounded bg-white text-sm";
    chatSection.querySelector(".card")?.prepend(box);
    chatLog = box;
  }

  // c) Input/Button vereinheitlichen
  let chatInput = document.getElementById("chatInput");
  if(!chatInput){
    chatInput = document.createElement("input");
    chatInput.id = "chatInput";
    chatInput.className = "input flex-1";
    chatInput.placeholder = "Schreib etwas‚Ä¶";
    const row = chatSection.querySelector(".flex.gap-2") || chatSection;
    row.appendChild(chatInput);
  }
  let btnSend = document.getElementById("btnChatSend");
  if(!btnSend){
    btnSend = document.createElement("button");
    btnSend.id = "btnChatSend";
    btnSend.className = "btn bg-blue-600 text-white";
    btnSend.textContent = "Senden";
    const row = chatSection.querySelector(".flex.gap-2") || chatSection;
    row.appendChild(btnSend);
  }

  // d) Bottom-Nav: Chat-Button sicherstellen
  const navGrid = document.querySelector("nav .grid");
  if(navGrid && !navGrid.querySelector('[data-tab="chat"]')){
    const btn = document.createElement("button");
    btn.dataset.tab = "chat";
    btn.className = "py-3";
    btn.textContent = "Chat";
    navGrid.appendChild(btn);
  }

  // 2) Rendering-Helfer (eine zentrale Funktion)
  window.chatAddMessage = function(role, text, buttons){
    // role: "user" | "bot"
    const bubble = document.createElement("div");
    bubble.className = role === "user" ? "text-right" : "text-left text-blue-700";
    bubble.textContent = text;
    chatLog.appendChild(bubble);

    if(Array.isArray(buttons) && buttons.length){
      const row = document.createElement("div");
      row.className = "flex flex-wrap gap-2 my-1";
      buttons.forEach(b=>{
        const btn = document.createElement("button");
        btn.className = "btn text-xs";
        btn.textContent = (b.prefix || "‚ûï ") + (b.label ?? "");
        btn.addEventListener("click", ()=>{
          const today = (window.todayISO ? window.todayISO() : new Date().toISOString().slice(0,10));
          const compute = (window.computePoints || ((x)=>x));
          const pts = compute(b.points||0, today);
          if(window.state){
            window.state.log.push({date: today, quest: b.label||"Aktion", points: pts, base: b.points||pts});
            (window.save||(()=>{}))();
            (window.renderAll||(()=>{}))();
          }
          window.chatAddMessage("bot", `‚úÖ Eingetragen: ${b.label} (+${pts} Punkte)`);
        });
        row.appendChild(btn);
      });
      chatLog.appendChild(row);
    }

    chatLog.scrollTop = chatLog.scrollHeight;
  };

  // 3) Einheitliche Sende-Logik
  function unifiedSend(message){
    const msg = (message||"").trim();
    if(!msg) return;
    window.chatAddMessage("user", msg);

    // Fallback, falls processMessage fehlt
    const pm = window.processMessage || (function(m){ return ["(Echo) "+m]; });

    try{
      const res = pm(msg);
      // Viele deiner Handler geben ein Array mit Texten zur√ºck.
      // Manche rendern selbst Buttons und geben [] zur√ºck ‚Äì beides unterst√ºtzen:
      if(Array.isArray(res) && res.length){
        res.forEach(line => window.chatAddMessage("bot", line));
      }
    }catch(e){
      console.error("Chat-Handler Fehler:", e);
      window.chatAddMessage("bot", "‚ö†Ô∏è Da ist was schiefgelaufen. Versuch's nochmal.");
    }
  }

  // 4) Alte Listener sauber umgehen & neue Listener setzen
  // (Wir h√§ngen UNSERE Listener einfach zus√§tzlich an; die alten existieren ggf. nicht mehr oder st√∂ren nicht.)
  btnSend.addEventListener("click", ()=> unifiedSend(chatInput.value));
  chatInput.addEventListener("keydown", (ev)=>{
    if(ev.key === "Enter" && !ev.shiftKey){
      ev.preventDefault();
      unifiedSend(chatInput.value);
      chatInput.value = "";
    }
  });

  // Falls es einen alten #btnChat gab und noch Listener erwarten: wir ignorieren ihn.
  // Wichtig ist, dass der Chat jetzt immer √ºber #btnChatSend funktioniert.

  // 5) Optional: Chat beim ersten Start kurz begr√º√üen (einmalig)
  try{
    if(window.state && !window.state.__chatGreeted){
      window.chatAddMessage("bot","üëã Hi! Ich bin dein Life-RPG-Chat. Schreib z. B. ‚ÄûEmpfehlung‚Äú, ‚Äûzeige Level‚Äú, ‚ÄûR√ºckg√§ngig‚Äú oder ‚ÄûStatistik Woche‚Äú.");
      window.state.__chatGreeted = true;
      (window.save||(()=>{}))();
    }
  }catch{}

})();
</script>
<!-- === /PATCH A === -->
<!-- === PATCH B : Negative Kategorien + Editor + √úbersicht (vor </body> einf√ºgen) === -->
<script>
(function(){
  "use strict";

  // ----- Guard: vorhandener App-State muss existieren -----
  if(!window.state){ console.warn("Patch B: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const S = window.state;

  // ===== 1) Datenmodell: Kategorien =====
  // type: "pos" | "neg"
  // F√ºr "neg": negFactor (z.B. 2 => 15 Cat-Punkte ergeben -30 Global)
  S.categories = S.categories || {
    uncat:     {id:"uncat",     name:"Ohne Kategorie",        type:"pos"},
    sport:     {id:"sport",     name:"Sport",                 type:"pos"},
    handwerk:  {id:"handwerk",  name:"Handwerk",              type:"pos"},
    gesundheit:{id:"gesundheit",name:"Gesundheit",            type:"pos"},
    haushalt:  {id:"haushalt",  name:"Haushalt",              type:"pos"},
    bad:       {id:"bad",       name:"Schlechter Lebensstil", type:"neg", negFactor:2}
  };

  // Katalog-Eintr√§ge ggf. mit Kategorie versehen
  S.catalog = S.catalog || [];
  S.catalog.forEach(q=>{
    if(!q.categoryId) q.categoryId = "uncat";
    // negative Quests d√ºrfen per-Quest Faktor haben (optional)
    if(q.negFactor==null) q.negFactor = null; 
  });

  // ===== 2) Migration: Log-Eintr√§ge um catPoints / categoryId erg√§nzen (ohne Retro-Strafen) =====
  S.log = S.log || [];
  S.log.forEach(e=>{
    if(e.categoryId) return;                // bereits getaggt
    const q = S.catalog.find(x=>x.name===e.quest);
    if(!q) return;                           // Sonderlogs (Reward, Event, etc.) unangetastet
    e.categoryId = q.categoryId || "uncat";
    // catPoints = "thematische" Punkte (immer positiv); globale Punkte NICHT √§ndern
    const baseAbs = Math.abs(e.base!=null ? e.base : e.points);
    e.catPoints = Math.max(0, baseAbs);
  });

  // ===== 3) Interceptor: state.log.push abfangen und kategorien-logik anwenden =====
  if(!S.__logPushWrapped){
    const origPush = S.log.push.bind(S.log);
    S.log.push = function(entry){
      try{
        if(entry && typeof entry==="object"){
          const q = S.catalog.find(x=>x.name===entry.quest);
          if(q){
            // Kategorie √ºbernehmen
            entry.categoryId = q.categoryId || "uncat";
            // thematische Punkte (immer positiv z√§hlen, z.B. in √úbersichten)
            const baseForCat = Math.abs(entry.base!=null ? entry.base : entry.points||0);
            entry.catPoints = Math.max(0, baseForCat);

            // Negative Kategorien: Global-Punkte √ºberschreiben (Strafe), NICHT multiplikatorisch erh√∂hen
            const cat = S.categories[entry.categoryId];
            if(cat && cat.type==="neg"){
              const factor = (q.negFactor || cat.negFactor || 2);
              const penalty = Math.round(baseForCat * factor);
              entry.points = -penalty; // globaler Impact
            }
          }
        }
      }catch(err){ console.warn("Kategorie-Normalisierung Fehler:", err); }
      return origPush(entry);
    };
    S.__logPushWrapped = true;
  }

  // ===== 4) Helfer =====
  const save = window.save || function(){ localStorage.setItem("lifeRPG_p1", JSON.stringify(S)); };
  const todayISO = window.todayISO || ( ()=> new Date().toISOString().slice(0,10) );
  const computePoints = window.computePoints || ( (base)=> base );
  const byId = id => document.getElementById(id);

  function catList(){
    return Object.values(S.categories);
  }

  function categoryTotals(){
    // Summen aus e.catPoints (thematische Sicht), separat: global impact aus e.points
    const totals = {};
    catList().forEach(c=> totals[c.id] = {cat:0, global:0, name:c.name, type:c.type});
    S.log.forEach(e=>{
      if(!e.categoryId || !totals[e.categoryId]) return;
      const t = totals[e.categoryId];
      t.cat    += Math.max(0, e.catPoints||0);
      t.global += e.points||0;
    });
    return totals;
  }

  // ===== 5) Dashboard: Kategorie-√úbersicht einh√§ngen =====
  function renderCategorySummary(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;
    // Container erschaffen/erneuern
    let box = byId("catSummaryBox");
    if(!box){
      box = document.createElement("div");
      box.id = "catSummaryBox";
      box.className = "mt-4 p-3 border rounded bg-white";
      host.appendChild(box);
    }
    const totals = categoryTotals();
    const rows = Object.entries(totals).map(([id,t])=>{
      const negInfo = t.type==="neg" ? `<span class="text-xs text-slate-500 ml-2">üìâ Global: ${t.global}</span>` : "";
      return `<div class="flex justify-between items-center py-1">
        <div>üè∑Ô∏è ${t.name}</div>
        <div><b>${t.cat}</b>${negInfo}</div>
      </div>`;
    }).join("");
    box.innerHTML = `<h3 class="font-bold">Kategorien (Summen)</h3>${rows || "<div class='text-sm text-slate-500'>Noch keine Eintr√§ge</div>"}`;
  }

  // Hook in renderDashboard (sp√§tester Hook gewinnt)
  const _oldRenderDashboard_B = window.renderDashboard;
  window.renderDashboard = function(){
    if(typeof _oldRenderDashboard_B === "function") _oldRenderDashboard_B();
    renderCategorySummary();
  };

  // ===== 6) Settings: einfacher Kategorien-Editor =====
  function renderSettingsCategories(){
    const settingsTab = byId("tab-settings");
    if(!settingsTab) return;

    // Container einf√ºgen/auffrischen
    let wrap = byId("settingsCatsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "settingsCatsWrap";
      wrap.className = "space-y-2 mt-4 p-3 border rounded bg-white";
      settingsTab.appendChild(wrap);
    }

    const cats = catList();
    wrap.innerHTML = `
      <h3 class="font-bold">Kategorien verwalten</h3>
      <div id="catEditorList" class="space-y-1">
        ${
          cats.map(c=>`
            <div class="grid grid-cols-12 gap-2 items-center">
              <div class="col-span-4">
                <input data-cid="${c.id}" data-k="name" class="input" value="${c.name}">
              </div>
              <div class="col-span-3">
                <select data-cid="${c.id}" data-k="type" class="input">
                  <option value="pos" ${c.type==="pos"?"selected":""}>Positiv</option>
                  <option value="neg" ${c.type==="neg"?"selected":""}>Negativ</option>
                </select>
              </div>
              <div class="col-span-3">
                <input data-cid="${c.id}" data-k="negFactor" type="number" class="input" placeholder="Faktor (neg)" value="${c.negFactor!=null?c.negFactor:""}">
              </div>
              <div class="col-span-2 text-right">
                ${c.id==="uncat" ? "" : `<button class="btn text-red-600" data-del="${c.id}">L√∂schen</button>`}
              </div>
            </div>
          `).join("")
        }
      </div>
      <div class="grid grid-cols-12 gap-2 items-center">
        <input id="newCatName" class="input col-span-5" placeholder="Neue Kategorie (Name)">
        <select id="newCatType" class="input col-span-3">
          <option value="pos">Positiv</option>
          <option value="neg">Negativ</option>
        </select>
        <input id="newCatFactor" type="number" class="input col-span-2" placeholder="Faktor">
        <button id="btnAddCat" class="btn col-span-2">+ Hinzuf√ºgen</button>
      </div>
      <div class="text-xs text-slate-500">Hinweis: F√ºr negative Kategorien gilt Globalstrafe = Faktor √ó Kategoriepunkte. Kategorien wirken nicht global als Bonus auf andere Kategorien.</div>
    `;

    // Change-Handler
    wrap.querySelectorAll("[data-cid][data-k]").forEach(inp=>{
      inp.addEventListener("change",()=>{
        const id = inp.getAttribute("data-cid");
        const k  = inp.getAttribute("data-k");
        const cat = S.categories[id];
        if(!cat) return;
        let val = inp.value;
        if(k==="negFactor"){
          val = val==="" ? null : Number(val);
        }
        cat[k] = (k==="negFactor" ? val : (k==="type" ? (val==="neg"?"neg":"pos") : val));
        save();
        // Neu rendern, da sich Anzeige/Feldern √§ndern k√∂nnte
        renderSettingsCategories();
        // Dashboard aktualisieren
        (window.renderAll||(()=>{}))();
      });
    });

    // Delete
    wrap.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const id = btn.getAttribute("data-del");
        if(!S.categories[id]) return;
        // Quests dieser Kategorie auf "uncat" umh√§ngen
        S.catalog.forEach(q=>{ if(q.categoryId===id) q.categoryId="uncat"; });
        delete S.categories[id];
        save();
        renderSettingsCategories();
        (window.renderAll||(()=>{}))();
      });
    });

    // Add
    const addBtn = byId("btnAddCat");
    if(addBtn){
      addBtn.addEventListener("click",()=>{
        const name = (byId("newCatName").value||"").trim();
        if(!name) return;
        const type = byId("newCatType").value==="neg"?"neg":"pos";
        const facStr = byId("newCatFactor").value;
        const negFactor = facStr==="" ? null : Number(facStr);
        // ID generieren
        let id = name.toLowerCase().replace(/\s+/g,"-").replace(/[^a-z0-9\-]/g,"");
        if(!id) id = "cat"+Math.random().toString(36).slice(2,6);
        if(S.categories[id]) id = id+"-"+Math.random().toString(36).slice(2,4);
        S.categories[id] = {id, name, type, negFactor};
        save();
        renderSettingsCategories();
        (window.renderAll||(()=>{}))();
      });
    }
  }

  // Hook in renderSettings
  const _oldRenderSettings_B = window.renderSettings;
  window.renderSettings = function(){
    if(typeof _oldRenderSettings_B === "function") _oldRenderSettings_B();
    renderSettingsCategories();
  };

  // ===== 7) Catalog: Kategorie-Zuweisung je Quest (auch nachtr√§glich √§nderbar) =====
  const _oldRenderCatalog_B = window.renderCatalog;
  window.renderCatalog = function(){
    const tab = byId("tab-catalog");
    if(!tab){ if(typeof _oldRenderCatalog_B === "function") _oldRenderCatalog_B(); return; }

    // Eigene Version des Tab-Inhalts (komplett)
    tab.innerHTML = `
      <div class="space-y-2">
        <input id="qName"    class="input" placeholder="Questname (z. B. 'Keller aufr√§umen')" />
        <input id="qPoints"  type="number" class="input" placeholder="Punkte" />
        <select id="qBoss"   class="input">
          <option value="false">Normale Quest</option>
          <option value="true">Bossquest</option>
        </select>
        <select id="qCat"    class="input">
          ${catList().map(c=>`<option value="${c.id}">${c.name}${c.type==="neg"?" (neg)":" (pos)"}</option>`).join("")}
        </select>
        <button id="btnAddQuest" class="btn bg-blue-600 text-white">Zur Liste hinzuf√ºgen</button>
      </div>

      <div class="mt-4 space-y-2" id="catalogList"></div>
    `;

    const list = byId("catalogList");
    const cats = catList();

    // Liste rendern
    function renderList(){
      if(!list) return;
      list.innerHTML = S.catalog.map((q,i)=>{
        const cat = S.categories[q.categoryId] || S.categories["uncat"];
        return `
          <div class="p-2 border rounded">
            <div class="flex items-center justify-between gap-2">
              <div class="${q.boss?'font-semibold':''}">
                ${q.boss?'üëë ':''}${q.name} (+${q.points} Punkte)
              </div>
              <div class="flex items-center gap-2">
                <select class="input text-sm" data-i="${i}" data-k="categoryId" title="Kategorie">
                  ${cats.map(c=>`<option value="${c.id}" ${c.id===q.categoryId?"selected":""}>${c.name}${c.type==="neg"?" (neg)":""}</option>`).join("")}
                </select>
                <button class="btn text-red-600 text-sm" data-del="${i}">L√∂schen</button>
              </div>
            </div>
            <div class="text-xs text-slate-500 mt-1">Kategorie: ${cat.name} ‚Ä¢ Typ: ${cat.type==="neg"?"Negativ":"Positiv"}${cat.type==="neg"&& (q.negFactor||cat.negFactor)?` ‚Ä¢ Faktor: ${q.negFactor||cat.negFactor}`:""}</div>
          </div>
        `;
      }).join("") || `<div class="text-sm text-slate-500">Noch keine Quests im Katalog.</div>`;

      // Kategorie √§ndern
      list.querySelectorAll("[data-k='categoryId']").forEach(sel=>{
        sel.addEventListener("change",()=>{
          const i = Number(sel.getAttribute("data-i"));
          const val = sel.value;
          if(!S.catalog[i]) return;
          S.catalog[i].categoryId = val;
          save();
          // Bestehende Logs mit dieser Quest nur taggen/aktualisieren (keine Retro-Strafen!)
          S.log.forEach(e=>{
            if(e.quest===S.catalog[i].name){
              e.categoryId = val;
              e.catPoints = Math.max(0, Math.abs(e.base!=null ? e.base : e.points||0));
            }
          });
          save();
          // Liste & Dashboard auffrischen
          renderList();
          (window.renderAll||(()=>{}))();
        });
      });

      // L√∂schen
      list.querySelectorAll("[data-del]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const idx = Number(btn.getAttribute("data-del"));
          if(!S.catalog[idx]) return;
          S.catalog.splice(idx,1);
          save();
          renderList();
          (window.renderAll||(()=>{}))();
        });
      });
    }
    renderList();

    // Hinzuf√ºgen
    const addBtn = byId("btnAddQuest");
    if(addBtn){
      addBtn.addEventListener("click",()=>{
        const name = (byId("qName").value||"").trim();
        const points = Number(byId("qPoints").value||0);
        const boss = (byId("qBoss").value==="true");
        const catId = byId("qCat").value || "uncat";
        if(!name || !points){ alert("Bitte Name und Punkte ausf√ºllen."); return; }
        S.catalog.push({name, points, boss, categoryId:catId, negFactor:null});
        save();
        byId("qName").value="";
        byId("qPoints").value="";
        renderList();
        (window.renderAll||(()=>{}))();
      });
    }
  };

  // ===== 8) Log/Chat: wenn direkt Quests eingetragen werden, greift unser Push-Interceptor automatisch =====
  // Nichts weiter n√∂tig ‚Äì alle state.log.push() laufen √ºber den Interceptor.

  // ===== 9) Render-All patchen, damit Settings/Catalog/Dashboard Erg√§nzungen angezeigt werden =====
  const _oldRenderAll_B = window.renderAll;
  window.renderAll = function(){
    if(typeof _oldRenderAll_B === "function") _oldRenderAll_B();
    // Unsere Teile h√§ngen auf ihre Hooks (renderSettings, renderCatalog, renderDashboard) ‚Äì diese wurden schon gepatcht.
  };

  // Einmal initial auffrischen (falls App schon geladen ist)
  try{ (window.renderAll||(()=>{}))(); }catch(e){}

})();
</script>
<!-- === /PATCH B === -->
<!-- === PATCH C : Missionen (Dependencies, Alternativen, 4√ó Bonus) ‚Äî vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  // ----- Guard -----
  if(!window.state){ console.warn("Patch C: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const S   = window.state;
  const save = window.save || function(){ localStorage.setItem("lifeRPG_p1", JSON.stringify(S)); };
  const todayISO = window.todayISO || (()=>new Date().toISOString().slice(0,10));
  const computePoints = window.computePoints || (base=>base);

  // ===== 1) Datenmodell Missionen =====
  // Mission:
  // { id, name, tasks:[ Task ], done, bonusGrantedAt? }
  // Task:
  // { id, label, questName?, points?, requires:[], groupKey?:string, unlocked?:bool, done?:bool, skipped?:bool, doneAt?:ISO }
  S.missions = S.missions || [];

  // ===== 2) Hilfsfunktionen =====
  const byId = id => document.getElementById(id);

  function uid(prefix="m"){
    return prefix + Math.random().toString(36).slice(2,8);
  }

  function findCatalogQuest(name){
    return (S.catalog||[]).find(q=>q.name===name);
  }

  function taskBasePoints(t){
    if(t.points && t.points>0) return t.points;
    if(t.questName){
      const q = findCatalogQuest(t.questName);
      if(q) return q.points||0;
    }
    return 0;
  }

  function missionBaseSum(m){
    return m.tasks.reduce((s,t)=> s + taskBasePoints(t), 0);
  }

  function isTaskDoneOrSkipped(t){ return !!(t.done || t.skipped); }

  // Abh√§ngigkeiten pr√ºfen (alle requires m√ºssen done/skipped sein)
  function depsSatisfied(m, t){
    if(!t.requires || t.requires.length===0) return true;
    const doneSet = new Set(m.tasks.filter(isTaskDoneOrSkipped).map(x=>x.id));
    return t.requires.every(rid=> doneSet.has(rid));
  }

  // ‚ÄûAlternativen‚Äú: Alle mit gleicher groupKey geh√∂ren zusammen; wenn eine erledigt, sind andere ‚Äûskipped‚Äú
  function applyAlternativesAfterComplete(m, task){
    if(!task.groupKey) return;
    m.tasks.forEach(t=>{
      if(t.id!==task.id && t.groupKey===task.groupKey && !t.done){
        t.skipped = true; // ohne Punkte
      }
    });
  }

  function recomputeUnlocks(m){
    m.tasks.forEach(t=>{
      t.unlocked = !isTaskDoneOrSkipped(t) && depsSatisfied(m,t);
    });
  }

  function missionComplete(m){
    return m.tasks.every(isTaskDoneOrSkipped);
  }

  function awardMissionBonus(m){
    if(m.bonusGrantedAt) return; // schon vergeben
    const baseSum = missionBaseSum(m);
    const bonus = Math.round(baseSum * 4); // 4√ó Belohnung
    S.log.push({date:todayISO(), quest:"Mission abgeschlossen: "+m.name, points:bonus});
    m.bonusGrantedAt = todayISO();
    save();
    try{
      if(window.FX) window.FX.burst();
      if(window.Sound && window.Sound.level) window.Sound.level();
      // kleiner Toast
      const t=document.createElement("div");
      t.textContent="üéØ Mission '"+m.name+"' abgeschlossen! +"+bonus+" Punkte";
      t.className="fixed bottom-24 left-1/2 -translate-x-1/2 bg-emerald-600 text-white px-4 py-2 rounded shadow-lg";
      document.body.appendChild(t);
      setTimeout(()=>t.remove(),2500);
    }catch{}
  }

  // ===== 3) UI: Tab ‚ÄûMissionen‚Äú einf√ºgen (falls noch nicht vorhanden) =====
  // Section
  if(!byId("tab-missions")){
    const main = document.querySelector("main");
    const sec = document.createElement("section");
    sec.id = "tab-missions";
    sec.className = "tab space-y-4";
    sec.innerHTML = `
      <div class="flex items-center justify-between">
        <h2 class="text-xl font-bold">üó∫Ô∏è Missionen</h2>
        <div class="flex gap-2">
          <button id="btnAddMissionWizard" class="btn">+ Mission</button>
          <button id="btnImportMission" class="btn">Import</button>
          <input id="fileImportMission" type="file" accept="application/json" class="hidden" />
          <button id="btnExportMissions" class="btn">Export</button>
        </div>
      </div>
      <div id="missionList" class="space-y-3"></div>
    `;
    main.appendChild(sec);
  }

  // Nav-Button
  (function ensureNavButton(){
    const nav = document.querySelector("nav .grid");
    if(!nav) return;
    if(!nav.querySelector("[data-tab='missions']")){
      const btn = document.createElement("button");
      btn.setAttribute("data-tab","missions");
      btn.className="py-3";
      btn.textContent="Missionen";
      nav.appendChild(btn);
      // aktiviert sich durch bestehenden globalen Tab-Handler
    }
  })();

  // ===== 4) Aktionen: Missionen erstellen / exportieren / importieren =====
  function addMissionWizard(){
    const name = prompt("Name der Mission?");
    if(!name) return;

    const m = { id:uid("mis_"), name, tasks:[], done:false };
    alert("Lege jetzt Aufgaben an. Du kannst jede Aufgabe mit einer vorhandenen Katalog-Quest verkn√ºpfen.\n" +
          "Tipps:\n- 'quest:<EXAKTER Katalogname>' verkn√ºpft eine Quest\n- oder 'label:<Anzeigename>' + 'points:<Zahl>'\n" +
          "- 'requires:<id1,id2>' setzt Abh√§ngigkeiten (IDs siehst du nach dem Speichern)\n- 'group:<key>' bildet Alternativen (z. B. '2')\n\n" +
          "Beende durch Abbrechen bei der Eingabe des Typs.");

    while(true){
      const type = prompt("Aufgabentyp (quest/label) ‚Äî Abbrechen zum Beenden");
      if(!type) break;

      const t = { id:uid("t_"), label:"", questName:null, points:null, requires:[], groupKey:null, done:false, skipped:false };

      if(type==="quest"){
        const qn = prompt("EXAKTER Katalog-Quest-Name?");
        if(!qn) continue;
        const q = findCatalogQuest(qn);
        if(!q){ alert("Quest nicht gefunden. Bitte im Katalog anlegen oder exakt schreiben."); continue; }
        t.questName = qn;
        t.label = qn;
      }else{
        // freier Label + Punkte
        const label = prompt("Label / Titel der Aufgabe:");
        if(!label) continue;
        t.label = label;
        const pts = Number(prompt("Punkte (Basis) f√ºr diese Aufgabe?")||0);
        t.points = Math.max(0,pts);
      }

      const req = prompt("Optional: requires (kommagetrennte Task-IDs, sp√§ter bearbeitbar). Leer lassen f√ºr keine Abh√§ngigkeiten.")||"";
      if(req.trim()){
        t.requires = req.split(",").map(s=>s.trim()).filter(Boolean);
      }
      const grp = prompt("Optional: group-Key (z. B. '2' f√ºr alternative 2.0/2.1 Aufgaben). Leer lassen wenn keine Alternativen.")||"";
      if(grp.trim()) t.groupKey = grp.trim();

      m.tasks.push(t);
      if(!confirm("Noch eine Aufgabe hinzuf√ºgen?")) break;
    }

    // Initial freischalten
    recomputeUnlocks(m);
    S.missions.push(m);
    save();
    renderMissions();
  }

  function exportMissions(){
    const blob = new Blob([JSON.stringify(S.missions,null,2)],{type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "missions_export.json";
    a.click();
  }

  function importMissionsFile(file){
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const data = JSON.parse(reader.result);
        if(!Array.isArray(data)) throw new Error("Ung√ºltiges Format.");
        // IDs sichern, grob pr√ºfen
        data.forEach(m=>{
          if(!m.id) m.id = uid("mis_");
          if(!m.tasks) m.tasks=[];
          m.tasks.forEach(t=>{ if(!t.id) t.id=uid("t_"); });
          recomputeUnlocks(m);
        });
        S.missions = data;
        save(); renderMissions();
      }catch(e){ alert("Import fehlgeschlagen: "+e.message); }
    };
    reader.readAsText(file);
  }

  // ===== 5) Aufgaben abschlie√üen =====
  function completeTask(missionId, taskId){
    const m = S.missions.find(x=>x.id===missionId);
    if(!m) return;
    const t = m.tasks.find(x=>x.id===taskId);
    if(!t || t.done || t.skipped) return;

    // Punkte bestimmen
    const base = taskBasePoints(t);
    const pts  = computePoints(base, todayISO());

    // Questname f√ºr Log ableiten
    const questLabel = t.questName || (`${m.name}: ${t.label}`);
    S.log.push({date:todayISO(), quest:questLabel, points:pts, base:base});
    t.done = true;
    t.doneAt = todayISO();

    // Alternativen-Gruppe sperren
    applyAlternativesAfterComplete(m, t);

    // Unlocks neu berechnen
    recomputeUnlocks(m);

    // Mission abgeschlossen?
    if(missionComplete(m)){
      awardMissionBonus(m);
      m.done = true;
    }

    save();
    try{ if(window.FX) window.FX.burst(); if(window.Sound) window.Sound.task(); }catch{}
    renderMissions();
    (window.renderAll||(()=>{}))();
  }

  function resetTask(missionId, taskId){
    const m = S.missions.find(x=>x.id===missionId); if(!m) return;
    const t = m.tasks.find(x=>x.id===taskId); if(!t) return;
    t.done=false; t.skipped=false; t.doneAt=null;
    // Falls Alternativgruppe: alle in der Gruppe wieder freigeben
    if(t.groupKey){
      m.tasks.forEach(x=>{
        if(x.groupKey===t.groupKey && x.id!==t.id){
          x.skipped=false;
        }
      });
    }
    m.done=false; m.bonusGrantedAt=null;
    recomputeUnlocks(m);
    save(); renderMissions(); (window.renderAll||(()=>{}))();
  }

  // ===== 6) Render: Missionen-Tab =====
  function renderMissions(){
    const host = byId("missionList");
    if(!host) return;
    if(!S.missions || S.missions.length===0){
      host.innerHTML = `<div class="text-sm text-slate-500">Noch keine Missionen. Lege eine mit ‚Äû+ Mission‚Äú an.</div>`;
      return;
    }

    host.innerHTML = S.missions.map(m=>{
      const total = m.tasks.length;
      const done  = m.tasks.filter(x=>x.done).length;
      const skipped = m.tasks.filter(x=>x.skipped).length;
      const prog  = done+skipped;
      const pct   = total? Math.round(prog/total*100) : 0;
      const baseSum = missionBaseSum(m);
      const bonusPreview = baseSum*4;

      const tasksHtml = m.tasks.map(t=>{
        const status = t.done? "‚úÖ"
                     : t.skipped? "üü°"
                     : t.unlocked? "‚è≥"
                     : "üîí";
        const deps = (t.requires && t.requires.length>0)
          ? `<span class="text-xs text-slate-500 ml-2">erfordert: ${t.requires.join(", ")}</span>`
          : "";
        const alt  = t.groupKey ? `<span class="text-xs ml-2 px-1 rounded bg-violet-100">Alternative: ${t.groupKey}</span>` : "";
        const basePts = taskBasePoints(t);
        const btns = t.done
          ? `<button class="btn text-xs ml-2" data-reset="${m.id}:${t.id}">R√ºckg√§ngig</button>`
          : t.unlocked && !t.skipped
            ? `<button class="btn text-xs ml-2 bg-blue-600 text-white" data-do="${m.id}:${t.id}">Erledigt</button>`
            : ``;

        return `<div class="p-2 border rounded">
          <div class="flex items-center justify-between">
            <div>${status} ${t.label || t.questName} <span class="text-xs text-slate-500">(Basis: +${basePts})</span>${alt}${deps}</div>
            <div>${btns}</div>
          </div>
        </div>`;
      }).join("");

      return `
        <div class="p-3 border rounded bg-white">
          <div class="flex items-center justify-between">
            <div>
              <div class="font-semibold">üó∫Ô∏è ${m.name}</div>
              <div class="text-xs text-slate-500">Fortschritt: ${prog}/${total} (${pct}%) ‚Ä¢ Abschlussbonus: +${bonusPreview}</div>
            </div>
            <div>
              ${m.done ? `<span class="text-emerald-700 text-sm">üéâ Abgeschlossen</span>` : ``}
            </div>
          </div>
          <div class="mt-2">
            <div class="w-full bg-gray-200 rounded h-2">
              <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
            </div>
          </div>
          <div class="mt-3 space-y-2">${tasksHtml}</div>
        </div>
      `;
    }).join("");

    // Buttons binden
    host.querySelectorAll("[data-do]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const [mid,tid] = btn.getAttribute("data-do").split(":");
        completeTask(mid,tid);
      });
    });
    host.querySelectorAll("[data-reset]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const [mid,tid] = btn.getAttribute("data-reset").split(":");
        resetTask(mid,tid);
      });
    });
  }

  // ===== 7) Buttons im Tab =====
  const addBtn = byId("btnAddMissionWizard");
  if(addBtn) addBtn.addEventListener("click", addMissionWizard);

  const expBtn = byId("btnExportMissions");
  if(expBtn) expBtn.addEventListener("click", exportMissions);

  const impBtn = byId("btnImportMission");
  const impFile= byId("fileImportMission");
  if(impBtn && impFile){
    impBtn.addEventListener("click", ()=>impFile.click());
    impFile.addEventListener("change", e=>{
      const f = e.target.files[0];
      if(!f) return;
      importMissionsFile(f);
      e.target.value = "";
    });
  }

  // ===== 8) Hooks ins Gesamtsystem =====
  // Hook in renderAll, damit Missionen-Tab immer aktuell ist
  const _oldRenderAll_C = window.renderAll;
  window.renderAll = function(){
    if(typeof _oldRenderAll_C === "function") _oldRenderAll_C();
    renderMissions();
  };

  // Beim Start Unlocks berechnen und rendern
  S.missions.forEach(recomputeUnlocks);
  try{ renderMissions(); }catch{}

})();
</script>
<!-- === /PATCH C === -->
<!-- === PATCH D : Quest-spezifisches Levelsystem + t√§glicher Abzug ‚Äî vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  // ---- Guards / Utils ----
  if(!window.state){ console.warn("Patch D: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const TODAY = ()=> new Date().toISOString().slice(0,10);
  const SAVE  = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));

  // Ab Tag X bis (aber ohne) Tag Y iterieren
  function* eachDay(fromISO, toISO){ // fromISO exklusiv, bis toISO exklusiv
    const d=new Date(fromISO); d.setDate(d.getDate()+1);
    const end=new Date(toISO);
    while(d<end){ yield d.toISOString().slice(0,10); d.setDate(d.getDate()+1); }
  }

  // Pr√ºfen, ob an Tag iso eine Log-Zeile f√ºr Quest existiert (positive Punkte)
  function hasQuestOnDate(questName, iso){
    const S=window.state;
    return S.log.some(e=> e.date===iso && e.quest===questName && (e.points||0)>0);
  }

  // Level-Formel: L1=100, L2=+110, L3=+120, ...
  function questLevelFromXp(xp){
    let level=0, need=100, rem=xp;
    while(rem>=need){ rem-=need; level++; need+=10; }
    return { level, inLevel: rem, next: need };
  }

  // ---- State-Erweiterung ----
  const S = window.state;
  S.questLevels = S.questLevels || {}; // Map <questName> -> { xp, lastDone, lastPenaltyCheck }

  // ---- XP/Decay: zentrales Handling bei neuen Log-Eintr√§gen ----
  function isCatalogNormalQuest(name){
    const q=(S.catalog||[]).find(x=>x.name===name);
    return !!(q && !q.boss); // nur "normale" Quests leveln/decayen
  }

  function onLogEntry(e){
    if(!e || typeof e.quest!=="string") return;
    if(!isCatalogNormalQuest(e.quest)) return;         // nur normale Katalog-Quests
    if((e.points||0) <= 0) return;                    // nur positive Punkte geben XP

    const rec = S.questLevels[e.quest] || {xp:0,lastDone:null,lastPenaltyCheck: TODAY()};
    rec.xp = Math.max(0, (rec.xp||0) + (e.points||0));
    rec.lastDone = e.date || TODAY();

    // Erste Initialisierung des Pr√ºftages: mindestens letzter Done-Tag, sonst heute
    if(!rec.lastPenaltyCheck){
      rec.lastPenaltyCheck = rec.lastDone || TODAY();
    }else{
      // falls Eintrag von "gestern" o.√§. nachgetragen wird und lastPenaltyCheck hinterherhinkt,
      // lassen wir die t√§gliche Routine unten sauber abarbeiten
    }

    S.questLevels[e.quest] = rec;
  }

  // Patch: state.log.push hooken (auch nach Import robust halten)
  function patchLogPush(){
    const st=window.state;
    if(!st || !st.log || st._logPushPatched) return;
    const orig = st.log.push.bind(st.log);
    st.log.push = function(...items){
      const res = orig(...items);
      items.forEach(onLogEntry);
      SAVE();
      return res;
    };
    st._logPushPatched = true;
  }
  patchLogPush();
  // falls via Import der Array ersetzt wurde, regelm√§√üig sicherstellen
  setInterval(()=>{ if(window.state && !window.state._logPushPatched) patchLogPush(); }, 1500);

  // ---- T√§glicher Abzug (-15 XP pro Tag ohne Erf√ºllung) ----
  function reconcileQuestDecay(){
    const today = TODAY();
    Object.entries(S.questLevels).forEach(([name,rec])=>{
      // nur normale Katalog-Quests decayen
      if(!isCatalogNormalQuest(name)) return;

      // Initialisieren, falls noch nie gepr√ºft
      if(!rec.lastPenaltyCheck){ rec.lastPenaltyCheck = today; }

      // F√ºr alle Tage seit letztem Check bis gestern pr√ºfen
      for(const iso of eachDay(rec.lastPenaltyCheck, today)){
        if(!hasQuestOnDate(name, iso)){
          rec.xp = Math.max(0, (rec.xp||0) - 15);
        }
      }
      rec.lastPenaltyCheck = today;
      S.questLevels[name] = rec;
    });
    SAVE();
  }

  // bei App-Start einmal ausf√ºhren
  reconcileQuestDecay();

  // t√§glicher Tick (erkennt Datumswechsel)
  let _lastDay = TODAY();
  setInterval(()=>{
    const t = TODAY();
    if(t !== _lastDay){
      _lastDay = t;
      reconcileQuestDecay();
      if(typeof window.renderAll==="function") window.renderAll();
    }
  }, 60*1000);

  // ---- UI: Katalog-Zeilen um Level-Badge erweitern ----
  function augmentCatalogWithLevels(){
    const list = document.getElementById("catalogList");
    if(!list) return;
    // Finde alle <div class="p-2 border ...">, hole erstes <span> = Titel
    const rows = list.querySelectorAll("div.p-2.border.rounded");
    rows.forEach(row=>{
      const titleSpan = row.querySelector("span");
      if(!titleSpan) return;

      // Questnamen aus dem Text herausl√∂sen: "üëë? <name> (+X Punkte)"
      let raw = (titleSpan.textContent||"").trim();
      raw = raw.replace("üëë","").trim();
      const m = raw.match(/^(.*?)\s*\(\+\d+/);
      const questName = (m ? m[1] : raw).trim();
      if(!questName) return;

      const rec = S.questLevels[questName] || {xp:0};
      const info = questLevelFromXp(rec.xp||0);

      // schon vorhanden? (bei erneutem Render vermeiden wir Duplikate)
      if(titleSpan.querySelector(".ql-badge")) return;

      const badge = document.createElement("span");
      badge.className = "ql-badge ml-2 inline-block text-[10px] px-2 py-0.5 rounded-full border bg-slate-50";
      badge.textContent = `LVL ${info.level} ¬∑ ${info.inLevel}/${info.next}`;
      titleSpan.appendChild(badge);
    });
  }

  // hook in renderCatalog
  const _oldRenderCatalog_D = window.renderCatalog;
  window.renderCatalog = function(){
    if(typeof _oldRenderCatalog_D==="function") _oldRenderCatalog_D();
    augmentCatalogWithLevels();
  };

  // ---- UI: Dashboard-Kurz√ºberblick (Top 5 gelevelte Quests) ----
  function renderQuestLevelSummary(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // Container (einmalig anlegen, dann nur Inhalt ersetzen)
    let box = document.getElementById("dashQuestLevelBox");
    if(!box){
      box = document.createElement("div");
      box.id = "dashQuestLevelBox";
      box.className = "mt-4";
      host.appendChild(box);
    }

    const entries = Object.entries(S.questLevels)
      .map(([name,rec])=>({name, xp:rec.xp||0, info:questLevelFromXp(rec.xp||0)}))
      .sort((a,b)=> (b.info.level - a.info.level) || (b.info.inLevel - a.info.inLevel))
      .slice(0,5);

    if(entries.length===0){
      box.innerHTML = `<h3 class="font-bold">Quest-Levels</h3>
      <div class="text-sm text-slate-500">Noch keine gelevelten Quests.</div>`;
      return;
    }

    box.innerHTML = `<h3 class="font-bold">Quest-Levels (Top 5)</h3>` +
      entries.map(e=>{
        const pct = Math.min(100, Math.round((e.info.inLevel / e.info.next)*100));
        return `
          <div class="mt-2">
            <div class="flex justify-between text-sm">
              <span>${e.name}</span>
              <span>LVL ${e.info.level} ¬∑ ${e.info.inLevel}/${e.info.next}</span>
            </div>
            <div class="w-full bg-gray-200 rounded h-2">
              <div class="bg-blue-500 h-2 rounded" style="width:${pct}%"></div>
            </div>
          </div>
        `;
      }).join("");
  }

  // hook in renderDashboard
  const _oldRenderDashboard_D = window.renderDashboard;
  window.renderDashboard = function(){
    if(typeof _oldRenderDashboard_D==="function") _oldRenderDashboard_D();
    renderQuestLevelSummary();
  };

  // ---- Initial pass: existierende Log-Eintr√§ge einmalig auf XP heben ----
  // (Nur wenn noch keine Levels vorhanden; ansonsten nicht anfassen)
  if(Object.keys(S.questLevels).length===0 && Array.isArray(S.log)){
    S.log.forEach(e=>{
      if(e && e.quest && (e.points||0)>0 && isCatalogNormalQuest(e.quest)){
        const rec = S.questLevels[e.quest] || {xp:0,lastDone:null,lastPenaltyCheck: TODAY()};
        rec.xp += e.points;
        rec.lastDone = e.date || rec.lastDone;
        S.questLevels[e.quest] = rec;
      }
    });
    SAVE();
  }

  // Sofort initial rendern
  try{
    if(typeof window.renderAll==="function") window.renderAll();
    else { window.renderCatalog && window.renderCatalog(); window.renderDashboard && window.renderDashboard(); }
  }catch(e){ console.warn("Patch D initial render:", e); }

})();
</script>
<!-- === /PATCH D === -->
<!-- === PATCH E : Dynamische Meilensteine (Quests/Missionen/Bossquests/Kategorien) ‚Äî vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  if(!window.state){ console.warn("Patch E: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const S = window.state;
  const TODAY = ()=> new Date().toISOString().slice(0,10);
  const SAVE  = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));

  // -------- Helpers --------
  const getCatalogByName = (name)=> (S.catalog||[]).find(q=>q.name===name);
  const isPositive = (n)=> Number(n||0) > 0;

  // Robust: Missende Container initialisieren
  S.milestones = Array.isArray(S.milestones) ? S.milestones : [];
  S.categories = S.categories || { list:[], byQuest:{} }; // falls noch nicht vorhanden

  // Z√§hler bestimmen
  function computeStats(){
    const log = Array.isArray(S.log) ? S.log : [];
    let quests=0, boss=0;
    const seenToday = new Set();

    log.forEach(e=>{
      const q = getCatalogByName(e.quest);
      if(!q) return;             // nur Quests aus dem Katalog z√§hlen
      if(!isPositive(e.points)) return; // nur positive Abschl√ºsse

      if(q.boss) boss++;
      else quests++;
    });

    // Missionen (falls Missionssystem vorhanden)
    let missionsDone = 0;
    if(Array.isArray(S.missions)){
      missionsDone = S.missions.filter(m=>m.done===true).length;
    }else{
      missionsDone = S.missionsDone || 0; // Fallback
    }

    // Kategorien-Z√§hler (pro Kategorie: Anzahl positiver Abschl√ºsse zugewiesenem Quest)
    const catCounts = {};
    const catNames  = {};
    (S.categories.list||[]).forEach(c=>{
      catCounts[c.id] = 0;
      catNames[c.id]  = c.name || ("Kategorie "+c.id);
    });
    log.forEach(e=>{
      if(!isPositive(e.points)) return;
      const cid = (S.categories.byQuest||{})[e.quest];
      if(cid && cid in catCounts) catCounts[cid]++;
    });

    return { quests, boss, missionsDone, catCounts, catNames };
  }

  // -------- Regeln / Schwellen --------
  // Feste Beispiele aus deiner Beschreibung + skalierende Fortsetzung
  const RULES = {
    quests: {
      thresholds: [100,200,500,1000,2000,5000,10000,20000,50000],
      fixed: {100:100, 200:400, 500:2500}, growth: 2.0,
      title: (thr)=>`üèÅ ${thr} Quests erledigt`,
      desc:  (thr)=>`Erreiche insgesamt ${thr} normale Quests`
    },
    boss: {
      thresholds: [10,20,50,100,200,500,1000],
      fixed: {10:100, 20:200, 50:2500}, growth: 2.0,
      title: (thr)=>`üëë ${thr} Bossquests besiegt`,
      desc:  (thr)=>`Erledige insgesamt ${thr} Bossquests`
    },
    missions: {
      thresholds: [5,10,20,50,100,200,500,1000],
      fixed: {5:50, 10:100, 20:400, 50:2500}, growth: 2.0,
      title: (thr)=>`üéØ ${thr} Missionen abgeschlossen`,
      desc:  (thr)=>`Schlie√üe insgesamt ${thr} Missionen ab`
    },
    // Kategorien: standardisierte Staffel
    category: {
      thresholds: [10,25,50,100,200,500,1000],
      rewardOf: (thr)=> thr*5, // linear, g√ºnstig & motivierend
      title: (name,thr)=>`üè∑Ô∏è ${name}: ${thr} Abschl√ºsse`,
      desc:  (name,thr)=>`Erledige ${thr} Quests in Kategorie ‚Äû${name}‚Äú`
    }
  };

  function rewardFor(ruleKey, thr){
    const r = RULES[ruleKey];
    if(!r) return 0;
    if(r.fixed && r.fixed[thr]!=null) return r.fixed[thr];
    // fallback: skaliere vom gr√∂√üten bekannten Fixwert an
    let known = Object.keys(r.fixed||{}).map(n=>Number(n)).sort((a,b)=>a-b);
    let baseThr = known.length ? known[known.length-1] : (r.thresholds && r.thresholds[0]) || 10;
    let baseRew = known.length ? r.fixed[baseThr] : 50;
    if(thr<=baseThr) return baseRew;

    let curThr = baseThr, curRew = baseRew;
    while(curThr < thr){
      // n√§chstes Threshold aus Liste oder verdoppeln bis wir >= thr sind
      let next = (r.thresholds||[]).find(x=>x>curThr) || (curThr*2);
      curRew = Math.round(curRew * (r.growth||2));
      curThr  = next;
    }
    return curRew;
  }

  // -------- Meilensteine erzeugen / synchronisieren --------
  function milestoneId(kind, key, thr){ // key: global oder kategorieId
    return `ms:${kind}:${key}:${thr}`;
  }

  function ensureMilestone(obj){
    // Fix gegen "undefined": Felder immer setzen
    obj.id      = obj.id || `ms:${Math.random().toString(36).slice(2)}`;
    obj.title   = obj.title || "Meilenstein";
    obj.desc    = obj.desc  || "";
    obj.kind    = obj.kind  || "misc";
    obj.key     = (obj.key==null ? "all" : obj.key);
    obj.ok      = !!obj.ok;
    obj.claimed = !!obj.claimed;
    obj.thr     = Number(obj.thr||0);
    obj.reward  = Number(obj.reward||0);
    return obj;
  }

  function ensureBaseMilestones(){
    const { catCounts, catNames } = computeStats();

    // Globale Serien
    [
      {kind:"quests",   key:"all", rule:"quests"},
      {kind:"boss",     key:"all", rule:"boss"},
      {kind:"missions", key:"all", rule:"missions"}
    ].forEach(({kind,key,rule})=>{
      (RULES[rule].thresholds||[]).forEach(thr=>{
        const id = milestoneId(kind,key,thr);
        if(!S.milestones.find(m=>m.id===id)){
          const reward = rewardFor(rule,thr);
          const title  = RULES[rule].title(thr);
          const desc   = RULES[rule].desc(thr);
          S.milestones.push(ensureMilestone({id, kind, key, thr, reward, title, desc, ok:false, claimed:false}));
        }
      });
    });

    // Kategorien-Serien (nur, wenn Kategorien existieren)
    Object.keys(catCounts).forEach(cid=>{
      const name = catNames[cid] || "Kategorie";
      (RULES.category.thresholds||[]).forEach(thr=>{
        const id = milestoneId("category",cid,thr);
        if(!S.milestones.find(m=>m.id===id)){
          const reward = RULES.category.rewardOf(thr);
          const title  = RULES.category.title(name,thr);
          const desc   = RULES.category.desc(name,thr);
          S.milestones.push(ensureMilestone({id, kind:"category", key:cid, thr, reward, title, desc, ok:false, claimed:false}));
        }
      });
    });

    SAVE();
  }

  // -------- Pr√ºfen & Belohnen --------
  function currentProgress(kind,key){
    const { quests, boss, missionsDone, catCounts } = computeStats();
    if(kind==="quests")   return quests;
    if(kind==="boss")     return boss;
    if(kind==="missions") return missionsDone;
    if(kind==="category") return (catCounts[key]||0);
    return 0;
  }

  function checkAndAwardMilestones(){
    let changed=false;
    S.milestones.forEach(m=>{
      // immer Felder fixen (gegen undefined)
      ensureMilestone(m);

      const prog = currentProgress(m.kind, m.key);
      if(!m.ok && prog >= Number(m.thr||0)){
        m.ok = true;
        changed = true;
      }
      if(m.ok && !m.claimed){
        // Belohnung vergeben
        const pts = Number(m.reward||0);
        if(pts>0){
          S.log.push({date:TODAY(), quest:`Milestone: ${m.title}`, points:pts});
        }
        m.claimed = true;
        changed = true;
      }
    });
    if(changed) SAVE();
  }

  // -------- UI --------
  function renderMilestonesBox(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    let box = document.getElementById("dashMilestonesBoxV2");
    if(!box){
      box = document.createElement("div");
      box.id = "dashMilestonesBoxV2";
      box.className = "mt-4 p-3 border rounded bg-orange-50";
      host.appendChild(box);
    }

    // Aufteilen: N√§chste anstehende (pro Serie 1) + k√ºrzlich geschaffte
    const groups = {
      quests:   S.milestones.filter(m=>m.kind==="quests").sort((a,b)=>a.thr-b.thr),
      boss:     S.milestones.filter(m=>m.kind==="boss").sort((a,b)=>a.thr-b.thr),
      missions: S.milestones.filter(m=>m.kind==="missions").sort((a,b)=>a.thr-b.thr),
      category: S.milestones.filter(m=>m.kind==="category").sort((a,b)=>a.thr-b.thr)
    };

    function nextPending(list){
      return list.find(m=>!m.ok) || null;
    }
    const nxt = {
      quests:   nextPending(groups.quests),
      boss:     nextPending(groups.boss),
      missions: nextPending(groups.missions)
    };

    // 3 ‚Äûn√§chste‚Äú zeigen + 5 zuletzt geschaffte
    const recentDone = S.milestones
      .filter(m=>m.ok)
      .slice(-5)
      .reverse();

    let html = `<h3 class="font-bold">üéØ Meilensteine</h3>`;

    html += `<div class="grid grid-cols-1 gap-2 mt-2">
      ${nxt.quests   ? milestoneRow(nxt.quests)   : `<div class="text-sm text-slate-600">Alle Quest-Meilensteine erreicht ‚úîÔ∏è</div>`}
      ${nxt.boss     ? milestoneRow(nxt.boss)     : `<div class="text-sm text-slate-600">Alle Boss-Meilensteine erreicht ‚úîÔ∏è</div>`}
      ${nxt.missions ? milestoneRow(nxt.missions) : `<div class="text-sm text-slate-600">Alle Missions-Meilensteine erreicht ‚úîÔ∏è</div>`}
    </div>`;

    // Kategorien ‚Äì nur die n√§chsten 3 f√§lligsten
    const catNext = [];
    Object.values(groups.category).forEach(m=>{
      if(!m.ok) catNext.push(m);
    });
    catNext.sort((a,b)=>a.thr-b.thr);
    const catSlice = catNext.slice(0,3);

    if(catSlice.length){
      html += `<div class="mt-3"><div class="font-semibold mb-1">Kategorien ‚Äì als n√§chstes:</div>
        ${catSlice.map(m=>milestoneRow(m)).join("")}
      </div>`;
    }

    if(recentDone.length){
      html += `<div class="mt-3"><div class="font-semibold mb-1">K√ºrzlich geschafft:</div>
        ${recentDone.map(m=>milestoneRow(m,true)).join("")}
      </div>`;
    }

    box.innerHTML = html;
  }

  function milestoneRow(m, done=false){
    const safeTitle = m.title || "Meilenstein";
    const safeDesc  = m.desc  || "";
    const badge = done ? "‚úÖ" : "‚è≥";
    const style = done ? "bg-green-100 border-green-300" : "bg-white";
    return `<div class="p-2 border rounded ${style}">
      <div class="flex justify-between items-center">
        <div>
          <div class="font-medium">${badge} ${safeTitle}</div>
          <div class="text-xs text-slate-600">${safeDesc}</div>
        </div>
        <div class="text-xs text-slate-700">Belohnung: +${Number(m.reward||0)} P.</div>
      </div>
    </div>`;
  }

  // Hook in renderDashboard
  const _oldRenderDashboard_E = window.renderDashboard;
  window.renderDashboard = function(){
    if(typeof _oldRenderDashboard_E==="function") _oldRenderDashboard_E();
    ensureBaseMilestones();
    checkAndAwardMilestones();
    renderMilestonesBox();
  };

  // -------- Log-Push hook (Belohnungen sofort pr√ºfen) --------
  function patchLogPushMilestones(){
    const st=window.state;
    if(!st || !st.log || st._logPushMilestonesPatched) return;
    const orig = st.log.push.bind(st.log);
    st.log.push = function(...items){
      const res = orig(...items);
      try{
        ensureBaseMilestones();
        checkAndAwardMilestones();
        // Dashboard ggf. aktualisieren
        if(typeof window.renderDashboard==="function") window.renderDashboard();
      }catch(e){ console.warn("Patch E check award failed", e); }
      return res;
    };
    st._logPushMilestonesPatched = true;
  }
  patchLogPushMilestones();
  setInterval(()=>{ if(window.state && !window.state._logPushMilestonesPatched) patchLogPushMilestones(); }, 1500);

  // -------- Init --------
  try{
    ensureBaseMilestones();
    checkAndAwardMilestones();
    if(typeof window.renderAll==="function") window.renderAll();
    else if(typeof window.renderDashboard==="function") window.renderDashboard();
  }catch(e){ console.warn("Patch E init:", e); }

})();
</script>
<!-- === /PATCH E === -->
<!-- === PATCH F : Kategorien-Summen & Verschieben ‚Äî direkt vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  if(!window.state){ console.warn("Patch F: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const S = window.state;
  const TODAY = ()=> new Date().toISOString().slice(0,10);
  const SAVE  = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));

  // --------- Kategorie-Daten initial sicherstellen ---------
  S.categories = S.categories || { list:[], byQuest:{} };

  // Defaults anlegen (nur wenn leer)
  if(!Array.isArray(S.categories.list) || S.categories.list.length===0){
    S.categories.list = [
      {id:"sport",   name:"Sport",            type:"positive"},
      {id:"ordnung", name:"Ordnung / Putzen", type:"positive"},
      {id:"essen",   name:"Ern√§hrung",        type:"positive"},
      {id:"handwerk",name:"Handwerk",         type:"positive"},
      {id:"neg",     name:"Schlechter Lebensstil", type:"negative"} // nur als Platzhalter ‚Äì Logik f√ºr negative Effekte kommt in sp√§terem Patch
    ];
  }
  S.categories.byQuest = S.categories.byQuest || {};

  // Ein paar vorhandene Quests automatisch zuordnen (nur, wenn noch unzugeordnet)
  (S.catalog||[]).forEach(q=>{
    if(!S.categories.byQuest[q.name]){
      const n=q.name.toLowerCase();
      if(n.includes("sport"))        S.categories.byQuest[q.name] = "sport";
      else if(n.includes("aufr√§um") || n.includes("putz")) S.categories.byQuest[q.name] = "ordnung";
      else if(n.includes("essen"))   S.categories.byQuest[q.name] = "essen";
      else if(n.includes("keller") || n.includes("leisten") || n.includes("wand")) S.categories.byQuest[q.name] = "handwerk";
    }
  });
  SAVE();

  // --------- Stats: Punkte & Anzahl pro Kategorie ---------
  function categoryStats(){
    const map = {};  // id -> {points,count}
    (S.categories.list||[]).forEach(c=> map[c.id] = {points:0,count:0});
    (S.log||[]).forEach(entry=>{
      const cid = (S.categories.byQuest||{})[entry.quest];
      if(!cid || !(cid in map)) return;
      // F√ºr die √úbersicht z√§hlen wir nur positive Punkte (negatives Handling kommt separat)
      const pts = Number(entry.points||0);
      if(pts>0){
        map[cid].points += pts;
        map[cid].count  += 1;
      }
    });
    return map;
  }

  // Hilfen
  const categoryById = (id)=> (S.categories.list||[]).find(c=>c.id===id);
  function ensureUniqueId(base){
    let id = base.replace(/\s+/g,"-").toLowerCase().replace(/[^a-z0-9\-]/g,"").slice(0,24) || "cat";
    let idx=1;
    while(S.categories.list.some(c=>c.id===id)) { id = `${base}-${idx++}`.toLowerCase().replace(/\s+/g,"-").replace(/[^a-z0-9\-]/g,""); }
    return id;
  }

  // --------- UI: Kategorien-√úbersicht im Dashboard ---------
  function renderCategoryOverview(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    let box = document.getElementById("categoryOverviewBox");
    const stats = categoryStats();

    const rows = (S.categories.list||[]).map(c=>{
      const s = stats[c.id] || {points:0,count:0};
      const chip = c.type==="negative" ? "bg-red-100 text-red-700" : "bg-green-100 text-green-700";
      return `
        <div class="p-2 border rounded bg-white flex justify-between items-center">
          <div class="font-medium">${c.name}
            <span class="ml-2 text-[10px] px-2 py-0.5 rounded ${chip}">${c.type}</span>
          </div>
          <div class="text-sm text-slate-700">
            <span class="font-semibold">+${s.points}</span> Punkte ¬∑ <span>${s.count}</span> Eintr√§ge
          </div>
        </div>`;
    }).join("");

    const html = `
      <h3 class="font-bold">Kategorien</h3>
      <div class="grid grid-cols-1 gap-2 mt-2">${rows || `<div class="text-sm text-slate-500">Noch keine Kategorien.</div>`}</div>
    `;

    if(!box){
      box = document.createElement("div");
      box.id = "categoryOverviewBox";
      box.className = "mt-4 p-3 border rounded bg-indigo-50";
      box.innerHTML = html;
      host.appendChild(box);
    }else{
      box.innerHTML = html;
    }
  }

  // Hook ins Dashboard
  const _oldRenderDashboard_F = window.renderDashboard;
  window.renderDashboard = function(){
    if(typeof _oldRenderDashboard_F==="function") _oldRenderDashboard_F();
    renderCategoryOverview();
  };

  // --------- UI: Katalog ‚Äì Quests verschieben (Kategorie-Select) ---------
  function renderCatalogEnhanced(){
    const list = document.getElementById("catalogList");
    const tab  = document.getElementById("tab-catalog");
    if(!list || !tab) return;

    // Kopfzeile: kleine Manager-Zeile
    let manager = document.getElementById("categoryManager");
    if(!manager){
      manager = document.createElement("div");
      manager.id = "categoryManager";
      manager.className = "mt-4 p-3 border rounded bg-slate-50";
      tab.appendChild(manager);
    }

    // Stats f√ºr Anzeige im Manager
    const stats = categoryStats();
    const catRows = (S.categories.list||[]).map(c=>{
      const s = stats[c.id] || {points:0,count:0};
      return `
        <div class="flex items-center justify-between p-2 border rounded bg-white">
          <div>
            <div class="font-medium">${c.name}</div>
            <div class="text-xs text-slate-600">${c.type==="negative"?"negative":"positive"} ¬∑ +${s.points} Punkte ¬∑ ${s.count} Eintr√§ge</div>
          </div>
          <div class="flex items-center gap-2">
            <button class="btn text-xs" data-cat-edit="${c.id}">Umbenennen</button>
            <button class="btn text-xs text-red-700" data-cat-del="${c.id}">L√∂schen</button>
          </div>
        </div>`;
    }).join("");

    manager.innerHTML = `
      <h3 class="font-bold mb-2">Kategorie-Manager</h3>
      <div class="space-y-2">${catRows || `<div class="text-sm text-slate-500">Noch keine Kategorien.</div>`}</div>
      <div class="grid grid-cols-3 gap-2 mt-3">
        <input id="newCatName" class="input col-span-2" placeholder="Neue Kategorie (Name)" />
        <select id="newCatType" class="input">
          <option value="positive">positiv</option>
          <option value="negative">negativ</option>
        </select>
      </div>
      <button id="btnAddCat" class="btn mt-2 bg-purple-600 text-white">+ Kategorie hinzuf√ºgen</button>
    `;

    // Events: Add / Rename / Delete
    manager.querySelector("#btnAddCat").addEventListener("click", ()=>{
      const name = manager.querySelector("#newCatName").value.trim();
      const type = manager.querySelector("#newCatType").value;
      if(!name) return alert("Bitte Kategorienamen eingeben.");
      const id = ensureUniqueId(name);
      S.categories.list.push({id,name,type});
      SAVE(); renderAll();
    });

    manager.querySelectorAll("[data-cat-edit]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-cat-edit");
        const cat = categoryById(id);
        if(!cat) return;
        const n = prompt("Neuer Name f√ºr Kategorie:", cat.name);
        if(!n) return;
        cat.name = n.trim();
        SAVE(); renderAll();
      });
    });

    manager.querySelectorAll("[data-cat-del]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-cat-del");
        const used = Object.values(S.categories.byQuest||{}).some(cid=>cid===id);
        if(used) return alert("Kategorie ist noch Quests zugeordnet. Bitte zuerst umh√§ngen.");
        S.categories.list = S.categories.list.filter(c=>c.id!==id);
        SAVE(); renderAll();
      });
    });

    // ---- Questliste mit Kategorie-Select & L√∂schen/Timed-Button ----
    const options = (S.categories.list||[]).map(c=>`<option value="${c.id}">${c.name}</option>`).join("");

    list.innerHTML = (S.catalog||[]).map((q,i)=>{
      const catSel = `
        <label class="text-xs text-slate-600">Kategorie:
          <select class="input text-xs" data-csel="${q.name}">
            <option value="">(keine)</option>
            ${options}
          </select>
        </label>`;
      return `
        <div class="p-2 border rounded ${q.boss?'bg-yellow-50':'bg-white'}">
          <div class="flex items-center justify-between">
            <div class="font-medium">${q.boss?'üëë ':''}${q.name} <span class="text-sm text-slate-600">(+${q.points} P.)</span></div>
            <div class="flex items-center gap-2">
              <button class="text-red-600 text-sm" data-del="${i}">L√∂schen</button>
            </div>
          </div>
          <div class="mt-2">${catSel}</div>
        </div>`;
    }).join("");

    // Timed-Quest Button unten (falls Funktion vorhanden)
    if(typeof window.addTimedQuest==="function"){
      const btn = document.createElement("button");
      btn.textContent = "+ Timed Quest";
      btn.className = "btn w-full bg-purple-600 text-white mt-2";
      btn.addEventListener("click", window.addTimedQuest);
      list.appendChild(btn);
    }

    // Events: Delete
    list.querySelectorAll("[data-del]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const idx = Number(btn.getAttribute("data-del"));
        // Zuordnung l√∂schen
        const q = S.catalog[idx];
        if(q && S.categories.byQuest[q.name]) delete S.categories.byQuest[q.name];
        S.catalog.splice(idx,1);
        SAVE(); renderAll();
      });
    });

    // Events: Kategorie-Select setzen & reagieren
    list.querySelectorAll("[data-csel]").forEach(sel=>{
      const qname = sel.getAttribute("data-csel");
      sel.value = S.categories.byQuest[qname] || "";
      sel.addEventListener("change", ()=>{
        const val = sel.value || "";
        if(val==="") delete S.categories.byQuest[qname];
        else S.categories.byQuest[qname] = val;
        SAVE(); renderAll();
      });
    });
  }

  // Wir √ºbersteuern das Katalog-Rendering komplett (um Duplikate zu vermeiden)
  const _oldRenderCatalog = window.renderCatalog;
  window.renderCatalog = function(){
    // Vorherige Varianten nicht aufrufen, wir rendern alles konsistent neu:
    // if(typeof _oldRenderCatalog==="function") _oldRenderCatalog();
    // Stattdessen: die oberen Eingabefelder bleiben (HTML), wir f√ºllen nur #catalogList + Kategorie-Manager.
    renderCatalogEnhanced();
  };

  // --------- Re-Render triggern nach Log-√Ñnderungen ----------
  // (damit Dashboard-Kategorien live updaten)
  function patchLogPushCats(){
    if(!S || !S.log || S._logPushCatsPatched) return;
    const orig = S.log.push.bind(S.log);
    S.log.push = function(...items){
      const r = orig(...items);
      try{
        if(typeof window.renderDashboard==="function") window.renderDashboard();
      }catch(e){}
      return r;
    };
    S._logPushCatsPatched = true;
  }
  patchLogPushCats();
  setInterval(()=>{ if(window.state && !window.state._logPushCatsPatched) patchLogPushCats(); }, 1500);

  // --------- Init ---------
  try{
    if(typeof window.renderAll==="function") window.renderAll();
    else{
      if(typeof window.renderDashboard==="function") window.renderDashboard();
      if(typeof window.renderCatalog==="function") window.renderCatalog();
    }
  }catch(e){ console.warn("Patch F init:", e); }

})();
</script>
<!-- === /PATCH F === -->
  // =======>>>>>  // [EXTENSION-POINT] F√úR K√úNFTIGE TEILE  <<<<<=======
  // Ab Schritt 2 werden neue Features genau HIER eingef√ºgt.
  // Ich sage dir dann immer: "F√ºge Part X direkt √úBER dem EXTENSION-POINT ein."
  </script>
  <!-- === PATCH G : Kategorie-Verkn√ºpfungen (projektbasiert) + Projekt-Zuweisung ‚Äî direkt vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  if(!window.state){ console.warn("Patch G: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }
  const S = window.state;
  const TODAY = ()=> new Date().toISOString().slice(0,10);
  const SAVE  = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));
  const byId  = id => (S.categories && S.categories.list || []).find(c=>c.id===id);

  // --------- Basis-Strukturen absichern ---------
  S.categories = S.categories || { list:[], byQuest:{} };
  S.projects   = S.projects   || { byQuest:{} };     // Zuordnung Quest -> Projekt/Mission-Key
  S.catLinks   = S.catLinks   || [];                 // Verkn√ºpfungen: {id,from,to,bonusType,amount,projectKey,active}

  // Hilfen
  function uniqueId(prefix="link"){
    return prefix + "_" + Math.random().toString(36).slice(2,9);
  }

  // --------- Bonus-Anwendung beim Loggen (projektbasiert) ---------
  function applyCategoryLinksFor(entry){
    if(!entry || !entry.quest) return;

    const qname  = entry.quest;
    const fromId = (S.categories.byQuest||{})[qname];
    if(!fromId) return; // Quest keiner Quelle-Kategorie zugeordnet

    const projectKey = (S.projects.byQuest||{})[qname];
    if(!projectKey) return; // keine Projektbindung -> keine globale Verkn√ºpfung zul√§ssig

    const candidates = (S.catLinks||[]).filter(l=>
      l.active && l.from===fromId && l.projectKey === projectKey && l.to && l.to!==fromId
    );
    if(candidates.length===0) return;

    candidates.forEach(link=>{
      const basePts = Number(entry.points||0);
      if(basePts<=0) return; // nur auf positive Basis loggen

      let bonus = 0;
      if(link.bonusType==="percent"){
        bonus = Math.round(basePts * (Number(link.amount||0)/100));
      }else{
        bonus = Math.round(Number(link.amount||0));
      }
      if(bonus<=0) return;

      const fromName = (byId(link.from)?.name)||link.from;
      const toName   = (byId(link.to)?.name)||link.to;
      const bonusQuest = `Kategorie-Bonus: ${fromName} ‚Üí ${toName} [${projectKey}]`;

      // Bonus-Quest der Zielkategorie zuordnen (damit die Kategorien-Summen korrekt sind)
      S.categories.byQuest[bonusQuest] = link.to;

      // Doppelbuchung verhindern: Pr√ºfe, ob f√ºr genau dieses Original-Log bereits Bonus mit dieser Link-ID existiert
      const already = S.log.slice(-5).some(e=> e.meta && e.meta.catLinkId===link.id && e.meta.srcQuest===qname && e.date===entry.date);
      if(already) return;

      S.log.push({
        date: entry.date,
        quest: bonusQuest,
        points: bonus,
        meta: { catBonus:true, catLinkId:link.id, project:projectKey, srcQuest:qname }
      });
      SAVE();
    });
  }

  // addLog wrappen (nach ALLEN anderen Patches)
  (function wrapAddLog(){
    if(S._catLinkPatched) return;
    const old = window.addLog;
    if(typeof old!=="function"){ console.warn("Patch G: addLog nicht gefunden."); return; }
    window.addLog = function(){
      const beforeLen = S.log.length;
      old.apply(this, arguments);
      const afterLen  = S.log.length;
      if(afterLen>beforeLen){
        const last = S.log[afterLen-1];
        applyCategoryLinksFor(last);
      }
    };
    S._catLinkPatched = true;
  })();

  // --------- Katalog: Projekt/Mission-Key je Quest editieren ---------
  function injectProjectInputs(){
    const list = document.getElementById("catalogList");
    if(!list) return;
    // F√ºr jedes vorhandene Kategorie-Select (data-csel="<QuestName>") ein Projektfeld daneben setzen
    list.querySelectorAll('select[data-csel]').forEach(sel=>{
      const qname = sel.getAttribute('data-csel');
      // Existiert schon?
      if(sel.closest('.p-2.border.rounded').querySelector(`[data-proj="${CSS.escape(qname)}"]`)) return;

      const wrap = document.createElement("div");
      wrap.className = "mt-2";
      wrap.innerHTML = `
        <label class="text-xs text-slate-600">Projekt/Mission:
          <input class="input text-xs" placeholder="z. B. Wohnzimmer" data-proj="${qname}">
        </label>
      `;
      sel.parentElement.parentElement.appendChild(wrap);
      const inp = wrap.querySelector(`[data-proj="${CSS.escape(qname)}"]`);
      inp.value = (S.projects.byQuest||{})[qname] || "";
      inp.addEventListener("change", ()=>{
        const v = (inp.value||"").trim();
        if(!S.projects.byQuest) S.projects.byQuest = {};
        if(v) S.projects.byQuest[qname] = v;
        else  delete S.projects.byQuest[qname];
        SAVE();
      });
    });
  }

  // Bestehendes Katalog-Render um Projektfelder erweitern
  (function wrapCatalog(){
    const old = window.renderCatalog;
    if(typeof old!=="function"){ console.warn("Patch G: renderCatalog nicht gefunden."); return; }
    window.renderCatalog = function(){
      old.apply(this, arguments);
      try{ injectProjectInputs(); }catch(e){ console.warn("Patch G injectProjectInputs",e); }
    };
  })();

  // --------- Settings: Manager f√ºr Kategorie-Verkn√ºpfungen (projektbasiert) ---------
  function renderCatLinkManager(){
    const host = document.getElementById("tab-settings");
    if(!host) return;

    let box = document.getElementById("catLinkManager");
    if(!box){
      box = document.createElement("div");
      box.id = "catLinkManager";
      box.className = "space-y-2 mt-4 p-3 border rounded bg-indigo-50";
      host.appendChild(box);
    }

    const catOpts = (S.categories.list||[]).map(c=>`<option value="${c.id}">${c.name}</option>`).join("");

    const rows = (S.catLinks||[]).map(l=>{
      const from = byId(l.from)?.name || l.from;
      const to   = byId(l.to)?.name   || l.to;
      const bonusTxt = l.bonusType==="percent" ? `${l.amount}%` : `+${l.amount}`;
      return `
        <div class="p-2 border rounded bg-white flex items-center justify-between">
          <div class="text-sm">
            <b>${from}</b> ‚ûú <b>${to}</b>
            <span class="ml-2">Projekt: <code>${l.projectKey}</code></span>
            <span class="ml-2">Bonus: <b>${bonusTxt}</b></span>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-xs flex items-center gap-1">
              Aktiv <input type="checkbox" data-link-on="${l.id}" ${l.active?'checked':''}>
            </label>
            <button class="btn text-xs text-red-700" data-link-del="${l.id}">L√∂schen</button>
          </div>
        </div>
      `;
    }).join("");

    box.innerHTML = `
      <h3 class="font-bold">Kategorie-Verkn√ºpfungen (projektbasiert)</h3>
      <div class="text-xs text-slate-600">
        Wenn du eine Quest loggst, die der <b>Quelle</b>-Kategorie zugeordnet ist <u>und</u> denselben <b>Projekt/Mission-Key</b> tr√§gt,
        wird automatisch ein Bonus in der <b>Ziel</b>-Kategorie verbucht. Keine globalen Boni.
      </div>

      <div class="grid grid-cols-1 md:grid-cols-5 gap-2 mt-2">
        <label class="text-xs">Quelle
          <select id="linkFrom" class="input text-xs">${catOpts}</select>
        </label>
        <label class="text-xs">Ziel
          <select id="linkTo" class="input text-xs">${catOpts}</select>
        </label>
        <label class="text-xs">Projekt/Mission-Key
          <input id="linkProject" class="input text-xs" placeholder="z. B. Wohnzimmer">
        </label>
        <label class="text-xs">Bonus-Typ
          <select id="linkType" class="input text-xs">
            <option value="percent">% vom Basis-Log</option>
            <option value="flat">+ feste Punkte</option>
          </select>
        </label>
        <label class="text-xs">Wert
          <input id="linkAmount" type="number" class="input text-xs" value="20" step="1">
        </label>
      </div>
      <button id="btnAddCatLink" class="btn bg-purple-600 text-white mt-2">+ Verkn√ºpfung hinzuf√ºgen</button>

      <div class="mt-3 space-y-2">${rows || `<div class="text-sm text-slate-500">Noch keine Verkn√ºpfungen.</div>`}</div>
    `;

    // Add
    box.querySelector("#btnAddCatLink").addEventListener("click", ()=>{
      const from = box.querySelector("#linkFrom").value;
      const to   = box.querySelector("#linkTo").value;
      const projectKey = (box.querySelector("#linkProject").value||"").trim();
      const bonusType  = box.querySelector("#linkType").value;
      const amount     = Number(box.querySelector("#linkAmount").value||0);

      if(!projectKey) return alert("Bitte einen Projekt/Mission-Key angeben (keine globalen Verkn√ºpfungen).");
      if(!from || !to) return alert("Bitte Quelle und Ziel w√§hlen.");
      if(from===to)    return alert("Quelle und Ziel d√ºrfen nicht identisch sein.");
      if(amount<=0)    return alert("Bitte einen Bonus > 0 angeben.");

      S.catLinks.push({ id:uniqueId(), from, to, projectKey, bonusType, amount, active:true });
      SAVE(); renderAll();
    });

    // Toggle
    box.querySelectorAll("[data-link-on]").forEach(chk=>{
      chk.addEventListener("change", ()=>{
        const id = chk.getAttribute("data-link-on");
        const l = (S.catLinks||[]).find(x=>x.id===id);
        if(!l) return;
        l.active = chk.checked;
        SAVE();
      });
    });

    // Delete
    box.querySelectorAll("[data-link-del]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-link-del");
        S.catLinks = (S.catLinks||[]).filter(x=>x.id!==id);
        SAVE(); renderAll();
      });
    });
  }

  // Settings hooken
  (function wrapSettings(){
    const old = window.renderSettings;
    if(typeof old!=="function"){ console.warn("Patch G: renderSettings nicht gefunden."); return; }
    window.renderSettings = function(){
      old.apply(this, arguments);
      try{ renderCatLinkManager(); }catch(e){ console.warn("Patch G renderCatLinkManager",e); }
    };
  })();

  // --------- Init ---------
  try{
    if(typeof window.renderAll==="function") window.renderAll();
    else{
      if(typeof window.renderSettings==="function") window.renderSettings();
      if(typeof window.renderCatalog==="function")  window.renderCatalog();
      if(typeof window.renderDashboard==="function")window.renderDashboard();
    }
  }catch(e){ console.warn("Patch G init:", e); }

})();
</script>
<!-- === /PATCH G === -->
<!-- === PATCH H : Negative Kategorien + doppelte Buchung + Milestone-Decay ‚Äî direkt vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  if(!window.state){ console.warn("Patch H: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }

  const S     = window.state;
  const SAVE  = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));
  const today = ()=> new Date().toISOString().slice(0,10);

  // -------- Basis-Strukturen absichern --------
  S.categories = S.categories || { list:[], byQuest:{} };
  S.categories.list = Array.isArray(S.categories.list) ? S.categories.list : [];
  S.categories.byQuest = S.categories.byQuest || {};
  // pro Kategorie-Config (negativ?, ratio usw.)
  S.categories.config = S.categories.config || {}; // { [catId]: { negative:boolean, ratio:number } }

  // Hilfen
  const findCatById   = id => (S.categories.list||[]).find(c=>c.id===id);
  const findCatByName = name => (S.categories.list||[]).find(c=>(c.name||"").toLowerCase()===String(name||"").toLowerCase());

  // Falls noch keine Kategorien existieren, minimal zwei vorschlagen
  if(!S.categories.__seededH){
    if(!S.categories.list || S.categories.list.length===0){
      S.categories.list = [
        { id:"cat_general", name:"Allgemein" },
        { id:"cat_bad",     name:"Schlechter Lebensstil" }
      ];
      // Standard: "Schlechter Lebensstil" negativ mit Ratio 2 (z. B. +15 Kategorie, ‚àí30 Total)
      S.categories.config["cat_bad"] = { negative:true, ratio:2 };
    }else{
      // vorhandene pr√ºfen: falls eine mit Name "Schlechter Lebensstil" existiert, default negativ
      const bad = findCatByName("Schlechter Lebensstil");
      if(bad && !S.categories.config[bad.id]){
        S.categories.config[bad.id] = { negative:true, ratio:2 };
      }
    }
    S.categories.__seededH = true;
    SAVE();
  }

  // -------- Negative Kategorie-Logik (doppelte Buchung) --------
  /**
   * Wenn der zuletzt geloggte Eintrag einer NEGATIVEN Kategorie zugeordnet ist:
   *  - behalte KATEGORIE-Credit positiv (idealerweise "base" verwenden)
   *  - buche zus√§tzlich einen Malus auf die Gesamtpunkte (‚àíbase*ratio)
   *  Ergebnis: Kategorie sammelt +X, Gesamtpunkte sinken netto um (ratio*X ‚àí X) = (ratio‚àí1)*X,
   *  wenn der urspr√ºngliche Eintrag bereits +X war. Um **exakt** z. B. ‚àí30 bei +15 Credit zu erzeugen,
   *  setzen wir den urspr√ºnglichen Eintrag auf +catPts und buchen **zus√§tzlich** ‚àí(catPts*ratio + opt.ausgleich).
   */
  function applyNegativeCategoryDoubleEntry(last){
    if(!last) return;

    const qname = last.quest;
    const catId = S.categories.byQuest[qname];
    if(!catId) return;

    const cfg = S.categories.config[catId] || { negative:false, ratio:2 };
    if(!cfg.negative) return;

    // Punkte-Basis: bevorzugt "base", sonst absoluter Wert der Punkte
    const catPts = Math.max(0, Number(last.base ?? Math.abs(last.points) || 0));
    const ratio  = Math.max(1, Number(cfg.ratio || 2));

    // Keine doppelten Malus-Buchungen (z. B. mehrfaches Wrapping)
    if(last.meta && last.meta.negSourceApplied) return;

    // 1) Urspr√ºnglichen Eintrag als KATEGORIE-Credit setzen (positiv, damit Kategorie-Summe stimmt)
    last.points = catPts;
    last.meta = Object.assign({}, last.meta, { negSourceApplied:true, negCategoryId:catId });

    // 2) Zus√§tzlichen Malus buchen, der NICHT einer Kategorie zugeordnet ist
    const penalty = -Math.round(catPts * ratio);
    // Ausgleich vermeiden: Wir wollen GESAMT ‚àí30 (Beispiel), Kategorie +15 -> Netto total ‚àí30 +15 = ‚àí15 (falsch).
    // Daher buchen wir den Malus separat und lassen den Credit stehen. Gesamt √§ndert sich um penalty (+ last.points).
    // Beispiel catPts=15, ratio=2 -> last.points=+15, penalty=‚àí30 -> Netto total ‚àí15.
    // **Der Nutzerwunsch ist explizit ‚àí30 total**, die Kategorie soll aber +15 zeigen.
    // L√∂sung: Wir buchen einen *zus√§tzlichen* Gegen-Ausgleich ‚àí(catPts) damit total = ‚àí30 und Kategorie bleibt +15:
    //   total delta = +15 (Credit) ‚àí30 (Malus) ‚àí15 (Ausgleich) = ‚àí30
    const compensation = -catPts;

    // Malus-Questname und kein Kategorie-Mapping setzen
    const malusName = `Malus (negativ): ${qname}`;
    const compName  = `Malus Ausgleich: ${qname}`;
    // Sicherstellen, dass diese Ausgleichsbuchungen NICHT in Kategorien z√§hlen:
    delete S.categories.byQuest[malusName];
    delete S.categories.byQuest[compName];

    S.log.push({
      date: last.date,
      quest: malusName,
      points: penalty,
      meta: { negPenalty:true, fromQuest:qname, catId }
    });
    S.log.push({
      date: last.date,
      quest: compName,
      points: compensation,
      meta: { negComp:true, fromQuest:qname, catId }
    });

    SAVE();
  }

  // addLog ein letztes Mal wrappen (nach allen anderen Patches),
  // damit wir den final erzeugten Eintrag transformieren k√∂nnen.
  (function wrapAddLogNegative(){
    if(S.__patchH_addLogWrapped) return;
    const old = window.addLog;
    if(typeof old!=="function"){ console.warn("Patch H: addLog nicht gefunden."); return; }
    window.addLog = function(){
      const before = S.log.length;
      old.apply(this, arguments);
      const after = S.log.length;
      if(after>before){
        const last = S.log[after-1];
        try{
          applyNegativeCategoryDoubleEntry(last);
        }catch(e){ console.warn("Patch H applyNegativeCategoryDoubleEntry", e); }
        // (Optional) Re-Render
        if(typeof window.renderAll==="function") window.renderAll();
      }
    };
    S.__patchH_addLogWrapped = true;
  })();

  // -------- Settings: Kategorie-Manager (negativ/Ratio) --------
  function renderNegativeCategoryManager(){
    const host = document.getElementById("tab-settings");
    if(!host) return;

    // Container anlegen/holen
    let box = document.getElementById("negCatManager");
    if(!box){
      box = document.createElement("div");
      box.id = "negCatManager";
      box.className = "space-y-2 mt-4 p-3 border rounded bg-rose-50";
      host.appendChild(box);
    }

    // Optionen rendern
    const rows = (S.categories.list||[]).map(cat=>{
      const cfg = S.categories.config[cat.id] || {};
      const neg = !!cfg.negative;
      const ratio = Number(cfg.ratio ?? 2);
      return `
        <div class="p-2 border rounded bg-white">
          <div class="flex items-center justify-between">
            <div>
              <div class="font-medium">${cat.name}</div>
              <div class="text-xs text-slate-500">ID: ${cat.id}</div>
            </div>
            <div class="flex items-center gap-3">
              <label class="text-xs flex items-center gap-1">
                Negativ?
                <input type="checkbox" data-neg="${cat.id}" ${neg?'checked':''}>
              </label>
              <label class="text-xs">Ratio
                <input type="number" min="1" step="1" class="input text-xs w-20" data-ratio="${cat.id}" value="${ratio}">
              </label>
            </div>
          </div>
        </div>
      `;
    }).join("");

    box.innerHTML = `
      <h3 class="font-bold">Negative Kategorien</h3>
      <div class="text-xs text-slate-700">
        F√ºr Kategorien, die <b>negativ</b> markiert sind (z. B. ‚ÄûSchlechter Lebensstil‚Äú),
        wird beim Loggen automatisch doppelt gebucht:<br>
        ‚Ä¢ Kategorie erh√§lt <b>+X</b> Punkte (Credit) &nbsp;‚Ä¢ Gesamtpunkte erhalten <b>‚àí(X√óRatio)</b> und zus√§tzlich <b>‚àíX</b> Ausgleich,<br>
        sodass z. B. bei X=15 und Ratio=2 die Kategorie +15 zeigt, die Gesamtpunkte jedoch um ‚àí30 sinken.
      </div>
      ${rows || `<div class="text-sm text-slate-500">Noch keine Kategorien definiert.</div>`}
      <div class="flex gap-2 mt-2">
        <input id="newNegCatName" class="input text-xs flex-1" placeholder="Neue Kategorie (optional)">
        <button id="btnAddNegCat" class="btn text-xs">+ Kategorie</button>
      </div>
    `;

    // Events: toggles & ratio
    box.querySelectorAll("[data-neg]").forEach(chk=>{
      chk.addEventListener("change", ()=>{
        const id = chk.getAttribute("data-neg");
        const cfg = S.categories.config[id] || (S.categories.config[id]={});
        cfg.negative = chk.checked;
        if(cfg.negative && (cfg.ratio==null)) cfg.ratio = 2;
        SAVE();
      });
    });
    box.querySelectorAll("[data-ratio]").forEach(inp=>{
      inp.addEventListener("change", ()=>{
        const id = inp.getAttribute("data-ratio");
        const cfg = S.categories.config[id] || (S.categories.config[id]={});
        let v = Math.max(1, Number(inp.value||2));
        cfg.ratio = v;
        SAVE();
      });
    });

    // Neue Kategorie anlegen (schnell)
    const addBtn = box.querySelector("#btnAddNegCat");
    const addInp = box.querySelector("#newNegCatName");
    if(addBtn && addInp){
      addBtn.addEventListener("click", ()=>{
        const name = (addInp.value||"").trim();
        if(!name) return;
        const id = "cat_"+Math.random().toString(36).slice(2,9);
        S.categories.list.push({id,name});
        S.categories.config[id] = { negative:false, ratio:2 };
        addInp.value="";
        SAVE();
        if(typeof window.renderAll==="function") window.renderAll();
        else renderNegativeCategoryManager();
      });
    }
  }

  // Settings hooken
  (function wrapSettings(){
    const old = window.renderSettings;
    if(typeof old!=="function"){ console.warn("Patch H: renderSettings nicht gefunden."); return; }
    window.renderSettings = function(){
      old.apply(this, arguments);
      try{ renderNegativeCategoryManager(); }catch(e){ console.warn("Patch H renderNegativeCategoryManager", e); }
    };
  })();

  // -------- Milestone-Decay: Wiedererreichen = 1/10 Belohnung --------
  /**
   * Ersetzt/erweitert checkMilestones so, dass:
   *  - m.ok spiegelt den AKTUELLEN Zustand von m.check() wider
   *  - √úbergang false->true: Belohnung
   *      * beim ersten Mal volle Belohnung
   *      * wenn seitdem unterschritten (true->false) und erneut erreicht: nur 1/10
   */
  (function wrapMilestonesDecay(){
    // Wenn kein Milestones-System existiert, still aussteigen
    if(!Array.isArray(S.milestones)) return;

    // Original, falls vorhanden
    const orig = window.checkMilestones;

    window.checkMilestones = function(){
      let updated = false;
      (S.milestones||[]).forEach(m=>{
        try{
          const nowOk = !!(m.check && m.check());
          // interne Felder initialisieren
          m.__ok  = (m.__ok===undefined) ? !!m.ok : m.__ok;
          m.__awarded = m.__awarded || 0;            // wie oft schon belohnt
          m.__lost    = m.__lost || false;           // seit letztem Award unterschritten?

          // √úberg√§nge feststellen
          const prevOk = !!m.__ok;

          if(!prevOk && nowOk){
            // Wiedererreicht
            let reward = Number(m.reward||0);
            if(m.__awarded>=1 && m.__lost){
              reward = Math.max(1, Math.round(reward * 0.1)); // 1/10
            }
            if(reward>0){
              S.log.push({date:today(), quest:`Milestone erreicht: ${m.text}`, points:reward, meta:{milestone:true, id:m.id||m.text}});
              updated = true;
            }
            m.__awarded += 1;
            m.__lost = false;
          }else if(prevOk && !nowOk){
            // Unterschritten
            m.__lost = true;
          }

          // Sichtbarer Status
          m.ok   = nowOk;
          m.__ok = nowOk;
        }catch(e){
          // robuste Pr√ºfung: einzelne Milestones d√ºrfen nicht alles blockieren
          console.warn("Patch H milestone check error", e, m);
        }
      });

      if(updated) SAVE();
    };

    // renderMilestones hooken (damit unser check l√§uft)
    const oldRenderM = window.renderMilestones;
    if(typeof oldRenderM === "function"){
      window.renderMilestones = function(){
        try{ window.checkMilestones(); }catch(e){ console.warn("Patch H checkMilestones run", e); }
        oldRenderM.apply(this, arguments);
      };
    }
  })();

  // -------- Init einmalig ausf√ºhren --------
  try{
    if(typeof window.renderAll==="function") window.renderAll();
    else{
      if(typeof window.renderSettings==="function") window.renderSettings();
      if(typeof window.renderDashboard==="function") window.renderDashboard();
      if(typeof window.renderLog==="function") window.renderLog();
      if(typeof window.renderCatalog==="function") window.renderCatalog();
    }
  }catch(e){ console.warn("Patch H init", e); }

})();
</script>
<!-- === /PATCH H === -->
<!-- === PATCH I : Dynamische Meilenstein-Leitern ‚Äî direkt vor </body> einf√ºgen === -->
<script>
(function(){
  "use strict";

  if(!window.state){ console.warn("Patch I: state nicht gefunden ‚Äì bitte nach dem Hauptscript laden."); return; }

  const S    = window.state;
  const save = ()=> (window.save ? window.save() : localStorage.setItem("lifeRPG_p1", JSON.stringify(window.state)));
  const todayISO = ()=> new Date().toISOString().slice(0,10);

  // ---------- Sanity ----------
  S.milestones   = Array.isArray(S.milestones) ? S.milestones : [];
  S.mLadders     = S.mLadders || { ladders:{}, lastSync: null };
  S.categories   = S.categories || { list:[], byQuest:{}, config:{} };
  S.catalog      = Array.isArray(S.catalog) ? S.catalog : [];

  // Falls alte Milestones ohne Text existieren: freundliche Defaults setzen
  S.milestones.forEach(m=>{
    if(!m.text){
      const id = m.id || "milestone";
      m.text = "Meilenstein: "+id;
    }
  });

  // ---------- Fortschritt aus State berechnen ----------
  function isSystemEntry(e){
    const q = (e.quest||"").toLowerCase();
    return (
      q.startsWith("malus") ||
      q.startsWith("reward") ||
      q.startsWith("event-") ||
      q.startsWith("tagesziel") ||
      q.startsWith("milestone erreicht") ||
      q.startsWith("timed quest verpasst") ||
      (e.meta && (e.meta.negPenalty || e.meta.negComp || e.meta.milestone))
    );
  }

  function progressSnapshot(){
    const log = Array.isArray(S.log) ? S.log : [];

    // "User-Quests" (keine System-/Hilfsbuchungen), nur positive Abschl√ºsse z√§hlen
    const userEntries = log.filter(e => e && typeof e.quest==="string" && !isSystemEntry(e) && Number(e.points||0) > 0);

    // Quest-Z√§hler
    const questsDone = userEntries.length;

    // Bossquests: aus Katalog ableiten
    const bossSet = new Set(S.catalog.filter(q=>q && q.boss).map(q=>q.name));
    const bossDone = userEntries.filter(e => bossSet.has(e.quest)).length;

    // Missionen abgeschlossen
    let missionsDone = 0;
    if(Array.isArray(S.missions)){
      missionsDone = S.missions.filter(m=>m && m.done===true).length;
    }else{
      // Fallback: Log-Eintr√§ge mit Hinweis
      missionsDone = log.filter(e => (e.meta && e.meta.missionDone) || String(e.quest||"").toLowerCase().startsWith("mission abgeschlossen")).length;
    }

    // Kategorie-Z√§hler (Anzahl erledigter Eintr√§ge je Kategorie)
    const catCounts = {};
    userEntries.forEach(e=>{
      const catId = S.categories.byQuest[e.quest];
      if(catId){
        catCounts[catId] = (catCounts[catId]||0) + 1;
      }
    });

    return { questsDone, bossDone, missionsDone, catCounts };
  }

  // ---------- Ladder-Generator ----------
  // Ein Ladder-Step wird als Meilenstein im bestehenden System angelegt (mit eigener id & check-Funktion),
  // damit Patch H (Decay 1/10 bei Wiedererreichen) automatisch gilt.
  function ensureLadderSteps(opts){
    // opts: { type, key, label, thresholds[], rewardFn, progressFn }
    const { type, key, label, thresholds, rewardFn, progressFn } = opts;
    const ladderId = `${type}:${key||"__"}`;

    // in Registry halten
    S.mLadders.ladders[ladderId] = S.mLadders.ladders[ladderId] || { created:new Set(), lastSeries:[] };
    const L = S.mLadders.ladders[ladderId];

    // Bereits vorhandene Meilenstein-IDs im State f√ºr Lookup
    const existingIds = new Set(S.milestones.map(m=>m.id));

    // Steps anlegen
    thresholds.forEach(T=>{
      const id = `LADDER:${type}:${key||"-"}:${T}`;
      if(existingIds.has(id) || L.created.has(id)) return;

      const text = `${label} ‚Äì ${T}`;
      const rew  = Number(rewardFn(T))||0;

      // Dynamische Check-Funktion liest IMMER live den Fortschritt
      const check = (function(threshold,progressFn){
        return function(){
          try{ return Number(progressFn()) >= Number(threshold); }
          catch(_){ return false; }
        };
      })(T, progressFn);

      S.milestones.push({ id, text, reward: rew, ok:false, check });
      L.created.add(id);
    });

    // Merke Serie (f√ºr sp√§tere Erweiterung)
    L.lastSeries = thresholds.slice();
  }

  // "Unendlich" erweitern: Wenn der h√∂chste Step "ok" ist, weitere generieren.
  function extendLadderIfCompleted(opts){
    const { type, key, nextFn, label, rewardFn, progressFn } = opts;
    const ladderPrefix = `LADDER:${type}:${key||"-"}:`;

    const ladderSteps = S.milestones
      .filter(m => (m.id||"").startsWith(ladderPrefix))
      .sort((a,b)=> Number(a.id.split(":").pop()) - Number(b.id.split(":").pop()));

    if(ladderSteps.length===0) return;

    const last = ladderSteps[ladderSteps.length-1];
    // Wenn der h√∂chste Step bereits erf√ºllt, n√§chsten erzeugen
    try{
      const nowOk = last.check && last.check();
      if(nowOk){
        const lastT = Number(last.id.split(":").pop());
        const nextT = nextFn(lastT);
        // id pr√ºfen
        const nid = `${ladderPrefix}${nextT}`;
        if(!S.milestones.some(m=>m.id===nid)){
          const text = `${label} ‚Äì ${nextT}`;
          const rew  = Number(rewardFn(nextT))||0;
          const check = (function(threshold,progressFn){
            return function(){
              try{ return Number(progressFn()) >= Number(threshold); }
              catch(_){ return false; }
            };
          })(nextT, progressFn);
          S.milestones.push({ id:nid, text, reward:rew, ok:false, check });
        }
      }
    }catch(e){ /* robust */ }
  }

  // ---------- Ladders definieren ----------
  function syncAllLadders(){
    const prog = progressSnapshot();

    // 1) Missionen (Beispielfolge + unendlich durch Verdopplung)
    const missBase = [5,10,20,50,100,200,500,1000];
    ensureLadderSteps({
      type:"missions",
      key:"_",
      label:"üèÅ Missionen abgeschlossen",
      thresholds: missBase,
      rewardFn: T => T*T,                 // 5‚Üí25, 10‚Üí100, 20‚Üí400, 50‚Üí2500, ...
      progressFn: ()=> progressSnapshot().missionsDone
    });
    extendLadderIfCompleted({
      type:"missions",
      key:"_",
      label:"üèÅ Missionen abgeschlossen",
      rewardFn: T => T*T,
      progressFn: ()=> progressSnapshot().missionsDone,
      nextFn: last => last<50 ? (last===5?10:last===10?20:50) : last*2
    });

    // 2) Quests gesamt
    const questBase = [100,200,500,1000,2000,5000,10000];
    ensureLadderSteps({
      type:"quests",
      key:"_",
      label:"‚úÖ Quests erledigt (gesamt)",
      thresholds: questBase,
      rewardFn: T => Math.round((T*T)/100),  // 100‚Üí100, 200‚Üí400, 500‚Üí2500, ...
      progressFn: ()=> progressSnapshot().questsDone
    });
    extendLadderIfCompleted({
      type:"quests",
      key:"_",
      label:"‚úÖ Quests erledigt (gesamt)",
      rewardFn: T => Math.round((T*T)/100),
      progressFn: ()=> progressSnapshot().questsDone,
      nextFn: last => (last>=5000 ? last+5000 : (last>=1000 ? last*2 : (last===500?1000:last*2)))
    });

    // 3) Bossquests
    const bossBase = [10,20,50,100,200,500];
    ensureLadderSteps({
      type:"boss",
      key:"_",
      label:"üëë Bossquests erledigt",
      thresholds: bossBase,
      rewardFn: T => T*T,                 // 10‚Üí100, 20‚Üí400, 50‚Üí2500, ...
      progressFn: ()=> progressSnapshot().bossDone
    });
    extendLadderIfCompleted({
      type:"boss",
      key:"_",
      label:"üëë Bossquests erledigt",
      rewardFn: T => T*T,
      progressFn: ()=> progressSnapshot().bossDone,
      nextFn: last => (last>=200 ? last*2 : (last===50?100:last*2))
    });

    // 4) Kategorien: F√ºr JEDE Kategorie eine Ladder
    const cats = Array.isArray(S.categories.list) ? S.categories.list : [];
    cats.forEach(cat=>{
      const catId = cat.id;
      const catName = cat.name || "Kategorie";
      const base = [25,50,100,200,500,1000];
      ensureLadderSteps({
        type:"cat",
        key: catId,
        label:`üè∑Ô∏è ${catName} ‚Äì erledigte Quests`,
        thresholds: base,
        rewardFn: T => Math.round((T*T)/25),  // 25‚Üí25, 50‚Üí100, 100‚Üí400, 200‚Üí1600, ...
        progressFn: ()=> (progressSnapshot().catCounts[catId]||0)
      });
      extendLadderIfCompleted({
        type:"cat",
        key: catId,
        label:`üè∑Ô∏è ${catName} ‚Äì erledigte Quests`,
        rewardFn: T => Math.round((T*T)/25),
        progressFn: ()=> (progressSnapshot().catCounts[catId]||0),
        nextFn: last => (last>=500 ? last*2 : (last===200?500:last*2))
      });
    });

    S.mLadders.lastSync = todayISO();
    save();
  }

  // Ersten Sync durchf√ºhren
  syncAllLadders();

  // ---------- Anzeige im Dashboard (zus√§tzlich zum bestehenden Milestone-Block) ----------
  function renderLadderPanel(){
    const host = document.getElementById("tab-dashboard");
    if(!host) return;

    // Altes Panel entfernen (Re-Render)
    let panel = document.getElementById("ladderPanel");
    if(panel) panel.remove();

    panel = document.createElement("div");
    panel.id = "ladderPanel";
    panel.className = "mt-4 p-3 border rounded bg-orange-50";

    const P = progressSnapshot();

    // Helper: n√§chsten Step finden
    function nextStepOf(prefix, current){
      const steps = S.milestones
        .filter(m => (m.id||"").startsWith(prefix))
        .map(m => Number(m.id.split(":").pop()))
        .sort((a,b)=>a-b);
      for(const t of steps){
        if(current < t) return t;
      }
      return steps[steps.length-1] || null;
    }

    // Missions-NEXT
    const missCur = P.missionsDone;
    const missNext = nextStepOf("LADDER:missions:_:", missCur);
    const missRew  = missNext ? (missNext*missNext) : 0;

    // Quests-NEXT
    const qCur = P.questsDone;
    const qNext = nextStepOf("LADDER:quests:_:", qCur);
    const qRew  = qNext ? Math.round((qNext*qNext)/100) : 0;

    // Boss-NEXT
    const bCur = P.bossDone;
    const bNext = nextStepOf("LADDER:boss:_:", bCur);
    const bRew  = bNext ? (bNext*bNext) : 0;

    // Kategorien ‚Äì Top 3 (nach offenem Œî)
    const catRows = [];
    (Array.isArray(S.categories.list)?S.categories.list:[]).forEach(cat=>{
      const cCur = P.catCounts[cat.id] || 0;
      const cNext = nextStepOf(`LADDER:cat:${cat.id}:`, cCur);
      if(cNext){
        catRows.push({
          name: cat.name||"Kategorie",
          cur: cCur,
          next: cNext,
          rew: Math.round((cNext*cNext)/25)
        });
      }
    });
    catRows.sort((a,b)=> (a.next-a.cur) - (b.next-b.cur)); // ‚Äûn√§chster Meilenstein am n√§chsten‚Äú nach oben
    const catTop = catRows.slice(0,3);

    panel.innerHTML = `
      <h3 class="font-bold">üéØ N√§chste Meilensteine</h3>
      <div class="grid grid-cols-1 gap-2 text-sm">
        <div class="p-2 rounded bg-white border">
          üèÅ Missionen: <b>${missCur}/${missNext||"-"}</b>
          ${missNext?`<span class="text-xs text-slate-600">‚Äì N√§chste Belohnung: +${missRew} Punkte</span>`:""}
        </div>
        <div class="p-2 rounded bg-white border">
          ‚úÖ Quests gesamt: <b>${qCur}/${qNext||"-"}</b>
          ${qNext?`<span class="text-xs text-slate-600">‚Äì N√§chste Belohnung: +${qRew} Punkte</span>`:""}
        </div>
        <div class="p-2 rounded bg-white border">
          üëë Bossquests: <b>${bCur}/${bNext||"-"}</b>
          ${bNext?`<span class="text-xs text-slate-600">‚Äì N√§chste Belohnung: +${bRew} Punkte</span>`:""}
        </div>
        ${catTop.length?`
          <div class="p-2 rounded bg-white border">
            üè∑Ô∏è Kategorien (Top):
            ${catTop.map(c=>
              `<div class="mt-1">‚Ä¢ ${c.name}: <b>${c.cur}/${c.next}</b>
                <span class="text-xs text-slate-600">(+${c.rew})</span></div>`).join("")}
          </div>`:""}
      </div>
      <div class="text-xs text-slate-500 mt-2">
        Hinweis: Wird ein Meilenstein unterschritten und sp√§ter erneut erreicht, betr√§gt die Belohnung nur <b>1/10</b> (Decay).
      </div>
    `;

    host.appendChild(panel);
  }

  // ---------- Hooks: vor Rendern Ladders syncen & pr√ºfen ----------
  function safe(fn){ try{ fn(); }catch(e){ console.warn("Patch I:",e); } }

  // checkMilestones l√§uft (inkl. Decay) bereits in Patch H ‚Äì wir stellen sicher,
  // dass unsere Ladders vorher existieren & ggf. erweitert werden.
  const oldRenderMilestones = window.renderMilestones;
  if(typeof oldRenderMilestones === "function"){
    window.renderMilestones = function(){
      safe(syncAllLadders);
      // Patch-H-check wird im originalen renderMilestones bereits getriggert (via Wrapper) ‚Äì ansonsten:
      if(typeof window.checkMilestones === "function"){
        safe(window.checkMilestones);
      }
      oldRenderMilestones.apply(this, arguments);
      safe(renderLadderPanel);
    };
  }else{
    // Falls es kein separates renderMilestones gibt, h√§ngen wir uns an Dashboard
    const oldDash = window.renderDashboard;
    window.renderDashboard = function(){
      safe(syncAllLadders);
      if(typeof window.checkMilestones === "function"){
        safe(window.checkMilestones);
      }
      if(oldDash) oldDash.apply(this, arguments);
      safe(renderLadderPanel);
    };
  }

  // Beim Initial-Load einmal anzeigen
  if(typeof window.renderDashboard === "function"){
    safe(()=>window.renderDashboard());
  }

})();
</script>
<!-- === /PATCH I === -->
</body>
</html>